<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
<meta name="viewport"
      content="width=device-width, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
<meta http-equiv="X-UA-Compatible" content="ie=edge">

    <meta name="author" content="Cynyard Qiu">





<title>面向对象设计原则 | Cynyard&#39;s Blog</title>



    <link rel="icon" href="/cloud.ico">




    <!-- stylesheets list from _config.yml -->
    
    <link rel="stylesheet" href="/css/style.css">
    



    <!-- scripts list from _config.yml -->
    
    <script src="/js/script.js"></script>
    
    <script src="/js/tocbot.min.js"></script>
    



    
    
        
    


<meta name="generator" content="Hexo 5.3.0"></head>
<body>
    <div class="wrapper">
        <header>
    <nav class="navbar">
        <div class="container">
            <div class="navbar-header header-logo"><a href="/">Cynyard&#39;s Blog</a></div>
            <div class="menu navbar-right">
                
                    <a class="menu-item" href="/archives">Posts</a>
                
                    <a class="menu-item" href="/category">Categories</a>
                
                    <a class="menu-item" href="/tag">Tags</a>
                
                    <a class="menu-item" href="/about">About</a>
                
                <input id="switch_default" type="checkbox" class="switch_default">
                <label for="switch_default" class="toggleBtn"></label>
            </div>
        </div>
    </nav>

    
    <nav class="navbar-mobile" id="nav-mobile">
        <div class="container">
            <div class="navbar-header">
                <div>
                    <a href="/">Cynyard&#39;s Blog</a><a id="mobile-toggle-theme">·&nbsp;Light</a>
                </div>
                <div class="menu-toggle" onclick="mobileBtn()">&#9776; Menu</div>
            </div>
            <div class="menu" id="mobile-menu">
                
                    <a class="menu-item" href="/archives">Posts</a>
                
                    <a class="menu-item" href="/category">Categories</a>
                
                    <a class="menu-item" href="/tag">Tags</a>
                
                    <a class="menu-item" href="/about">About</a>
                
            </div>
        </div>
    </nav>

</header>
<script>
    var mobileBtn = function f() {
        var toggleMenu = document.getElementsByClassName("menu-toggle")[0];
        var mobileMenu = document.getElementById("mobile-menu");
        if(toggleMenu.classList.contains("active")){
           toggleMenu.classList.remove("active")
            mobileMenu.classList.remove("active")
        }else{
            toggleMenu.classList.add("active")
            mobileMenu.classList.add("active")
        }
    }
</script>
        <div class="main">
            <div class="container">
    
    
        <div class="post-toc">
    <div class="tocbot-list">
    </div>
    <div class="tocbot-list-menu">
        <a class="tocbot-toc-expand" onclick="expand_toc()">Expand all</a>
        <a onclick="go_top()">Back to top</a>
        <a onclick="go_bottom()">Go to bottom</a>
    </div>
</div>

<script>
    document.ready(
        function () {
            tocbot.init({
                tocSelector: '.tocbot-list',
                contentSelector: '.post-content',
                headingSelector: 'h1, h2, h3, h4, h5',
                collapseDepth: 1,
                orderedList: false,
                scrollSmooth: true,
            })
        }
    )

    function expand_toc() {
        var b = document.querySelector(".tocbot-toc-expand");
        tocbot.init({
            tocSelector: '.tocbot-list',
            contentSelector: '.post-content',
            headingSelector: 'h1, h2, h3, h4, h5',
            collapseDepth: 6,
            orderedList: false,
            scrollSmooth: true,
        });
        b.setAttribute("onclick", "collapse_toc()");
        b.innerHTML = "Collapse all"
    }

    function collapse_toc() {
        var b = document.querySelector(".tocbot-toc-expand");
        tocbot.init({
            tocSelector: '.tocbot-list',
            contentSelector: '.post-content',
            headingSelector: 'h1, h2, h3, h4, h5',
            collapseDepth: 1,
            orderedList: false,
            scrollSmooth: true,
        });
        b.setAttribute("onclick", "expand_toc()");
        b.innerHTML = "Expand all"
    }

    function go_top() {
        window.scrollTo(0, 0);
    }

    function go_bottom() {
        window.scrollTo(0, document.body.scrollHeight);
    }

</script>
    

    
    <article class="post-wrap">
        <header class="post-header">
            <h1 class="post-title">面向对象设计原则</h1>
            
                <div class="post-meta">
                    
                        Author: <a itemprop="author" rel="author" href="/">Cynyard Qiu</a>
                    

                    
                        <span class="post-time">
                        Date: <a href="#">June 29, 2021&nbsp;&nbsp;20:00:00</a>
                        </span>
                    
                    
                        <span class="post-category">
                    Category:
                            
                                <a href="/categories/Design/">Design</a>
                            
                        </span>
                    
                    
                </div>
            
        </header>

        <div class="post-content">
            <h1 id="面向对象设计原则"><a href="#面向对象设计原则" class="headerlink" title="面向对象设计原则"></a>面向对象设计原则</h1><h2 id="可维护性和可复用性"><a href="#可维护性和可复用性" class="headerlink" title="可维护性和可复用性"></a>可维护性和可复用性</h2><h3 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h3><p>两者某种程度上可以等同，我们一般希望达成的是可复用的可维护性<br>软件的可维护性较低，通常由下面四个原因构成</p>
<ul>
<li>僵硬：很难添加一个新的功能，造成代码的改动很大，所有的修改都要基于源代码的改动；与可拓展性相对</li>
<li>脆弱：和过于僵硬同时存在；与灵活性相对</li>
<li>低复用：组成部分很难在其他部分或者不同项目进行使用（黑盒）</li>
<li>黏度过高：架构层面上，如果需要破坏原始的框架和结构；与可插入性相对</li>
</ul>
<h3 id="重构"><a href="#重构" class="headerlink" title="重构"></a>重构</h3><p>调整程序代码改善软件的质量</p>
<h2 id="单一职责原则"><a href="#单一职责原则" class="headerlink" title="单一职责原则"></a>单一职责原则</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><ul>
<li>一个对象只包含单一的职责，职责被完整的封装在一个类中；就像链表的添加删除获取等职责</li>
<li>就一个类而言，应该只有一个引起它变化的原因，也就是只对单一的职责负责</li>
</ul>
<h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><ul>
<li>一个类承担的职责越多，被复用的可能性越小，当职责越来越多，就相当于职责之间的耦合越来越多，一个职责的变化就会影响其他职责的运作</li>
<li>数据职责和行为职责，数据职责通过属性来体现，行为职责通过方法来体现</li>
<li>高内聚，低耦合，就像 迭代器现在被独立出来成为一个类，专门负责迭代</li>
</ul>
<h3 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h3><p>不要让login又负责连接又负责登陆校验</p>
<img src="https://cynyard-blog-pics.oss-cn-beijing.aliyuncs.com/image/1614654763598-d8787145-cfbe-4c35-9dbd-8e93552e4b70.png" alt="image.png" style="zoom: 33%; " />

<img src="https://cynyard-blog-pics.oss-cn-beijing.aliyuncs.com/image/1614654784715-35ea1da3-6326-4453-b265-0a31d796c846.png" alt="image.png" style="zoom:50%; " />

<h2 id="开闭原则"><a href="#开闭原则" class="headerlink" title="开闭原则"></a>开闭原则</h2><h3 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h3><ul>
<li>一个软件实体应该对拓展开放，对修改关闭。软件实体可以指一个软件模块，一个由多个类组成的局部结构或一个独立的类</li>
<li>也就是说，在设计一个模块的时候，这个模块可以在不被修改的前提下被扩展</li>
<li>也就是，在增加一个功能的时候，可以在不修改源代码的情况下改变这个模块的行为，通过新的代码实现</li>
</ul>
<h3 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h3><ul>
<li>抽象化，抽象类和具体类，具体类实现具体的功能</li>
<li>对可变性封装原则，找到系统的可变因素并将其封装起来，当你预判可能会发生变化的时候，使用抽象</li>
</ul>
<h3 id="举例-1"><a href="#举例-1" class="headerlink" title="举例"></a>举例</h3><img src="https://cynyard-blog-pics.oss-cn-beijing.aliyuncs.com/image/1614655590114-55754f35-5812-4d2f-91c9-1d90af000bbc.png" alt="image.png" style="zoom:50%; " />

<p>当修改一个需求的时候，需要修改源代码，例如改变Button的形状</p>
<img src="https://cynyard-blog-pics.oss-cn-beijing.aliyuncs.com/image/1614655646123-a60a1319-4a03-4af5-8ff0-d66263599ade.png" alt="image.png" style="zoom:50%; " />

<p>表驱动也是类似的思想</p>
<h2 id="里式代换原则"><a href="#里式代换原则" class="headerlink" title="里式代换原则"></a>里式代换原则</h2><h3 id="定义-2"><a href="#定义-2" class="headerlink" title="定义"></a>定义</h3><ul>
<li><p>如果对于每一个类型为S的对象o1，都有类型为T的对象o2，使得以T定义的所有程序P在所有的对象o1都代换成o2的时候，程序P的行为没有变化，那么类型S是类型T的子类型</p>
</li>
<li><p>也就是说，所有引用基类的地方，都能透明的使用子类的对象</p>
</li>
</ul>
<h3 id="分析-2"><a href="#分析-2" class="headerlink" title="分析"></a>分析</h3><ul>
<li>在软件中，如果能够使用基类对象，那么一定能够使用其子类对象。也就是说，<strong>把基类都变成它的子类，程序将不会产生任何错误和异常</strong></li>
<li>里氏代换原则是实现开闭原则的重要方式之一，由于<strong>使用基类对象的地方都可以使用子类对象</strong>，因此在程序中，尽量使用基类类型来对对象进行定义，而在运行的时候，再确定其子类类型，用子类对象来替换父类对象</li>
<li>不应该给子类添加新的公开方法（私有方法可以添加，被共有方法调用），<strong>子类应该是对父类功能的复用</strong>，新增父类的功能可以使用组合而不是继承</li>
<li>增加新的功能，就只用增加新的子类</li>
<li>子类可以被其他子类进行替换</li>
</ul>
<h3 id="举例-2"><a href="#举例-2" class="headerlink" title="举例"></a>举例</h3><img src="https://cynyard-blog-pics.oss-cn-beijing.aliyuncs.com/image/1614656744078-8a550acd-b919-4ae1-a4fc-73a20dfa45b2.png" alt="image.png" style="zoom:50%; " />

<p>需要增加新的加密方法就需要增加DataOperator中的代码，违背了开闭原则，可以将其封装起来，并且保证抽象类和具体类之间满足里氏代换原则，接口需要一样（子类实现的方法，父类中都有声明）</p>
<img src="https://cynyard-blog-pics.oss-cn-beijing.aliyuncs.com/image/1614656832093-5367702b-c631-4ea2-9a3f-ae6e04964fb6.png" alt="image.png" style="zoom:50%; " />

<p>也可以实现abstractCipher，增加新的功能就增加新的子类</p>
<h2 id="依赖倒转原则"><a href="#依赖倒转原则" class="headerlink" title="依赖倒转原则"></a>依赖倒转原则</h2><h3 id="定义-3"><a href="#定义-3" class="headerlink" title="定义"></a>定义</h3><p>Dependence Inversion Principle</p>
<ul>
<li>高层模块不应该依赖底层模块，都应该依赖抽象，抽象不应该依赖于细节，细节应该依赖于抽象</li>
<li>要针对接口编程，不要针对实现编程</li>
<li>高层和细节都依赖抽象，一种倒置关系</li>
</ul>
<h3 id="分析-3"><a href="#分析-3" class="headerlink" title="分析"></a>分析</h3><ul>
<li>开闭原则是面向对象设计的目标，依赖倒转原则就是面向对象设计的主要手段</li>
<li>也就是说，代码依赖于抽象的类，而不是具体的类；<strong>针对接口或者抽象类编程而不是针对实现编程</strong></li>
<li>只要发生了耦合关系的地方，就尽量使用抽象作为依赖</li>
</ul>
<h4 id="常用实现方式"><a href="#常用实现方式" class="headerlink" title="常用实现方式"></a>常用实现方式</h4><ul>
<li>在代码中使用抽象类，将具体类放进配置文件中，“将抽象放进代码，将细节放进元数据”</li>
<li>在程序中尽量不说明具体的实现，而在运行时通过文件才能体现，系统需要发生变化的时候，修改配置文件就可以满足需求</li>
</ul>
<h3 id="举例-3"><a href="#举例-3" class="headerlink" title="举例"></a>举例</h3><img src="https://cynyard-blog-pics.oss-cn-beijing.aliyuncs.com/image/1614657463099-9e9a2889-7613-4fd7-9860-9bdb616c2ebf.png" alt="image.png" style="zoom:50%; " />

<p>以上都是面向具体编程的，当需要添加新的数据源和新的文件格式的时候，客户类和Main都需要修改源代码，以便使用新的类。（当然，下图也可以将抽象类换为接口，接口是对行为的封装）</p>
<img src="https://cynyard-blog-pics.oss-cn-beijing.aliyuncs.com/image/image-20210624121413034.png" alt="image-20210624121413034" style="zoom:50%; " />

<h2 id="接口隔离原则"><a href="#接口隔离原则" class="headerlink" title="接口隔离原则"></a>接口隔离原则</h2><h3 id="定义-4"><a href="#定义-4" class="headerlink" title="定义"></a>定义</h3><ul>
<li>客户端不应该依赖那些它不需要的接口</li>
<li>一旦一个接口太大，需要将它分割为一些更细小的接口，使用该接口的客户端仅需知道与它相关的方法</li>
</ul>
<h3 id="分析-4"><a href="#分析-4" class="headerlink" title="分析"></a>分析</h3><ul>
<li>使用多个专门的接口，而不是用单一的总接口，每一个接口应该承担一种相对独立的角色，一个行为</li>
<li>接口仅仅提供客户端需要的行为，将客户端不需要的行为隐藏起来，所以要尽量提供小的接口</li>
<li>如果一个实现类只用一个功能，一个方法，一个行为，那么就提供只包含着一个行为的接口</li>
</ul>
<h3 id="举例-4"><a href="#举例-4" class="headerlink" title="举例"></a>举例</h3><p>三角形+虚线代表实现<br>三角形+实现代表继承</p>
<img src="https://cynyard-blog-pics.oss-cn-beijing.aliyuncs.com/image/1614824564978-c06d2225-9375-4335-8c43-6cbb5fb27be3.png" alt="image.png" style="zoom:50%; " />

<p>由于是共有的方法，无法限制ClientA使用OperatorB和OperatorC</p>
<img src="https://cynyard-blog-pics.oss-cn-beijing.aliyuncs.com/image/1614824785017-9bb4c3f8-d29a-4c0f-8aca-65a47406dc54.png" alt="image.png" style="zoom:50%; " />

<h2 id="合成复用原则"><a href="#合成复用原则" class="headerlink" title="合成复用原则"></a>合成复用原则</h2><h3 id="定义-5"><a href="#定义-5" class="headerlink" title="定义"></a>定义</h3><ul>
<li><p>组合/聚合复用原则</p>
</li>
<li><p>在一个新的对象里通过关联关系来使用一些已有的对象，使之成为新对象的一部分，新对象通过调用已有对象的方法达到复用其已有功能的目的，即<strong>尽量使用对象组合/聚合has a而不是继承is a来达到复用的目的</strong></p>
</li>
</ul>
<h3 id="分析-5"><a href="#分析-5" class="headerlink" title="分析"></a>分析</h3><h4 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h4><ul>
<li>继承实现的复用是一种透明的复用，白箱复用（类似于代码的拷贝），继承的实现是静态的，不能实时发生改变</li>
<li>一旦发生基类的改变，所有的派生类都会收到影响</li>
</ul>
<h4 id="组合"><a href="#组合" class="headerlink" title="组合"></a>组合</h4><ul>
<li>内部细节对于新对象是不可见的，黑箱复用</li>
<li>旧的成员的变化对于新对象是影响不大的，只用保证接口不变就行</li>
<li>新对象可以动态引用，更有一定的灵活性</li>
</ul>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><ul>
<li>一般来说首选组合/聚合来实现复用，复用<strong>接口的实现</strong>，降低类之间的耦合度</li>
<li>其次再考虑继承，在使用继承的时候，需要严格遵守里氏代换原则，复用<strong>接口的定义</strong>，父类确定不会有变化的部分才会使用子类进行继承</li>
</ul>
<h3 id="举例-5"><a href="#举例-5" class="headerlink" title="举例"></a>举例</h3><ul>
<li>StudentDAO和TeacherDAO复用getConnection这个方法</li>
<li>但是如果更换了数据库的连接方式，需要更改DBUtil的源代码</li>
<li>如果StudentDAO和TeacherDAO需要编程不同的数据库连接方式，需要增加新的DBUtil类别，并且修改子类的源代码，使他们分别继承不同的数据库类，违背了开闭原则</li>
</ul>
<img src="https://cynyard-blog-pics.oss-cn-beijing.aliyuncs.com/image/1614825885305-a1c7f7a5-4232-4bde-982b-81bb00096926.png" alt="image.png" style="zoom:50%; " />

<img src="https://cynyard-blog-pics.oss-cn-beijing.aliyuncs.com/image/1614826060095-ecec16e0-266a-4fe5-9c0c-73b7bf0e7559.png" alt="image.png" style="zoom:50%; " />

<ul>
<li>增加新的实现，就可以增加新的DBUtil的子类，甚至是放在配置文件中（不用改源代码），这里也有依赖倒转原则</li>
</ul>
<h2 id="迪米特法则（最小知识原则）"><a href="#迪米特法则（最小知识原则）" class="headerlink" title="迪米特法则（最小知识原则）"></a>迪米特法则（最小知识原则）</h2><h3 id="定义-6"><a href="#定义-6" class="headerlink" title="定义"></a>定义</h3><ul>
<li>不要直接和陌生人说话</li>
<li>只与你的直接朋友通信</li>
<li>每一个软件单位都受限制的了解其他的单位，并且还仅仅局限于那些与本单位密切相关的软件单位</li>
</ul>
<h3 id="分析-6"><a href="#分析-6" class="headerlink" title="分析"></a>分析</h3><ul>
<li>简单的说，就是一个软件实体应该尽可能少的与其他实体发生相互作用</li>
<li>这样当一个模块修改的时候，就会尽量少的影响其他的模块，拓展相互容易</li>
</ul>
<h4 id="所谓的朋友"><a href="#所谓的朋友" class="headerlink" title="所谓的朋友"></a>所谓的朋友</h4><ul>
<li>对象本身</li>
<li>以参数形式传入到当前对象方法中的对象</li>
<li>成员对象，以及集合型成员对象中的元素</li>
<li>当前对象创建的对象</li>
</ul>
<h4 id="狭义"><a href="#狭义" class="headerlink" title="狭义"></a>狭义</h4><img src="https://cynyard-blog-pics.oss-cn-beijing.aliyuncs.com/image/1614826730021-0609dbf9-292f-4e35-bf95-d2817e20b07c.png" alt="image.png" style="zoom:50%; " />

<ul>
<li>如果两个类不<strong>必彼此直接通信，那就不应当发生直接的相互作用</strong>，一个类需要调用另一个类的某一个方法的时候，可以<strong>通过第三者转发这个调用</strong></li>
<li>降低类之间的耦合，但是会增加大量的小方法，可以让一个系统的局部设计简化，因为每一个局部都不会与远距离的对象有直接的关联，但是会造成系统的不同模块的通信效率降低，不容易协调，（方法的调用是一个复杂的过程，付出了性能的代价）</li>
</ul>
<h4 id="广义"><a href="#广义" class="headerlink" title="广义"></a>广义</h4><ul>
<li>对对象之间的<strong>信息流量、流向以及信息的影响的控制</strong>，主要是对于<strong>信息隐藏的控制</strong>，便于各个子系统之间脱耦，从而允许他们独立的开发，优化，使用和修改，同时可以促进软件的复用。</li>
<li>由于每个模块不依赖其他模块而存在，因此每一个模块都可以独立地在其他的地方使用</li>
</ul>
<h4 id="用途"><a href="#用途" class="headerlink" title="用途"></a>用途</h4><p>控制信息的过载</p>
<ul>
<li>创建低耦合的类，易于复用，并且便于修改</li>
<li>每一个类应该尽量<strong>降低成员变量和成员函数的访问权限</strong></li>
<li>只要有可能，一个类应该设计成不变类；并且对于其他类的引用上，一个对象对于其他对象的引用应该降到最低</li>
</ul>
<h3 id="举例-6"><a href="#举例-6" class="headerlink" title="举例"></a>举例</h3><p>调用关系较为复杂，找朋友，通过第三者转发</p>
<img src="https://cynyard-blog-pics.oss-cn-beijing.aliyuncs.com/image/1614828405307-79fa529d-d2cf-4769-8f2d-0d70e1277e3e.png" alt="image.png" style="zoom:50%; " />

<img src="https://cynyard-blog-pics.oss-cn-beijing.aliyuncs.com/image/1614828412617-4f31e701-0732-41d8-87e7-54f28a5be2ec.png" alt="image.png" style="zoom:50%; " />

<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>目标：开闭原则</p>
<p>指导：最小知识原则</p>
<p>基础：单一职责原则、可变性封装原则</p>
<p>实现：依赖倒转原则、合成复用原则、里式代换原则、接口隔离原则</p>

        </div>

        
            <section class="post-copyright">
                
                    <p class="copyright-item">
                        <span>Author:</span>
                        <span>Cynyard Qiu</span>
                    </p>
                
                
                
                

            </section>
        
        <section class="post-tags">
            <div>
                <span>Tag(s):</span>
                <span class="tag">
                    
                    
                        <a href="/tags/design/"># design</a>
                    
                        <a href="/tags/object-oriented/"># object-oriented</a>
                    
                        <a href="/tags/code/"># code</a>
                    
                        
                </span>
            </div>
            <div>
                <a href="javascript:window.history.back();">back</a>
                <span>· </span>
                <a href="/">home</a>
            </div>
        </section>
        <section class="post-nav">
            
                <a class="prev" rel="prev" href="/2021/10/04/Daemon-Thread/">用户线程与守护线程</a>
            
            
            <a class="next" rel="next" href="/2021/06/29/design-patterns/">常见设计模式</a>
            
        </section>


    </article>
</div>

        </div>
        <footer id="footer" class="footer">
    <div class="copyright">
        <span>© Cynyard Qiu | Powered by <a href="https://hexo.io" target="_blank">Hexo</a> & <a href="https://github.com/Siricee/hexo-theme-Chic" target="_blank">Chic</a> 
        
        </span>
    </div>
</footer>

    </div>
</body>
</html>

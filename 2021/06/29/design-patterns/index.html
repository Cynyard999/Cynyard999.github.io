<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
<meta name="viewport"
      content="width=device-width, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
<meta http-equiv="X-UA-Compatible" content="ie=edge">
<meta name="referrer" content="no-referrer" />

    <meta name="author" content="Cynyard Qiu">





<title>常见设计模式 | Cynyard&#39;s Blog</title>



    <link rel="icon" href="/cloud.ico">




    <!-- stylesheets list from _config.yml -->
    
    <link rel="stylesheet" href="/css/style.css">
    



    <!-- scripts list from _config.yml -->
    
    <script src="/js/script.js"></script>
    
    <script src="/js/tocbot.min.js"></script>
    



    
    
        
    


<meta name="generator" content="Hexo 5.3.0"></head>
<body>
    <div class="wrapper">
        <header>
    <nav class="navbar">
        <div class="container">
            <div class="navbar-header header-logo"><a href="/">Cynyard&#39;s Blog</a></div>
            <div class="menu navbar-right">
                
                    <a class="menu-item" href="/archives">Posts</a>
                
                    <a class="menu-item" href="/category">Categories</a>
                
                    <a class="menu-item" href="/tag">Tags</a>
                
                    <a class="menu-item" href="/about">About</a>
                
                <input id="switch_default" type="checkbox" class="switch_default">
                <label for="switch_default" class="toggleBtn"></label>
            </div>
        </div>
    </nav>

    
    <nav class="navbar-mobile" id="nav-mobile">
        <div class="container">
            <div class="navbar-header">
                <div>
                    <a href="/">Cynyard&#39;s Blog</a><a id="mobile-toggle-theme">·&nbsp;Light</a>
                </div>
                <div class="menu-toggle" onclick="mobileBtn()">&#9776; Menu</div>
            </div>
            <div class="menu" id="mobile-menu">
                
                    <a class="menu-item" href="/archives">Posts</a>
                
                    <a class="menu-item" href="/category">Categories</a>
                
                    <a class="menu-item" href="/tag">Tags</a>
                
                    <a class="menu-item" href="/about">About</a>
                
            </div>
        </div>
    </nav>

</header>
<script>
    var mobileBtn = function f() {
        var toggleMenu = document.getElementsByClassName("menu-toggle")[0];
        var mobileMenu = document.getElementById("mobile-menu");
        if(toggleMenu.classList.contains("active")){
           toggleMenu.classList.remove("active")
            mobileMenu.classList.remove("active")
        }else{
            toggleMenu.classList.add("active")
            mobileMenu.classList.add("active")
        }
    }
</script>
        <div class="main">
            <div class="container">
    
    
        <div class="post-toc">
    <div class="tocbot-list">
    </div>
    <div class="tocbot-list-menu">
        <a class="tocbot-toc-expand" onclick="expand_toc()">Expand all</a>
        <a onclick="go_top()">Back to top</a>
        <a onclick="go_bottom()">Go to bottom</a>
    </div>
</div>

<script>
    document.ready(
        function () {
            tocbot.init({
                tocSelector: '.tocbot-list',
                contentSelector: '.post-content',
                headingSelector: 'h1, h2, h3, h4, h5',
                collapseDepth: 1,
                orderedList: false,
                scrollSmooth: true,
            })
        }
    )

    function expand_toc() {
        var b = document.querySelector(".tocbot-toc-expand");
        tocbot.init({
            tocSelector: '.tocbot-list',
            contentSelector: '.post-content',
            headingSelector: 'h1, h2, h3, h4, h5',
            collapseDepth: 6,
            orderedList: false,
            scrollSmooth: true,
        });
        b.setAttribute("onclick", "collapse_toc()");
        b.innerHTML = "Collapse all"
    }

    function collapse_toc() {
        var b = document.querySelector(".tocbot-toc-expand");
        tocbot.init({
            tocSelector: '.tocbot-list',
            contentSelector: '.post-content',
            headingSelector: 'h1, h2, h3, h4, h5',
            collapseDepth: 1,
            orderedList: false,
            scrollSmooth: true,
        });
        b.setAttribute("onclick", "expand_toc()");
        b.innerHTML = "Expand all"
    }

    function go_top() {
        window.scrollTo(0, 0);
    }

    function go_bottom() {
        window.scrollTo(0, document.body.scrollHeight);
    }

</script>
    

    
    <article class="post-wrap">
        <header class="post-header">
            <h1 class="post-title">常见设计模式</h1>
            
                <div class="post-meta">
                    
                        Author: <a itemprop="author" rel="author" href="/">Cynyard Qiu</a>
                    

                    
                        <span class="post-time">
                        Date: <a href="#">June 29, 2021&nbsp;&nbsp;20:00:00</a>
                        </span>
                    
                    
                        <span class="post-category">
                    Category:
                            
                                <a href="/categories/Design/">Design</a>
                            
                        </span>
                    
                    
                </div>
            
        </header>

        <div class="post-content">
            <h1 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h1><h2 id="引子"><a href="#引子" class="headerlink" title="引子"></a>引子</h2><img src="https://cynyard-blog-pics.oss-cn-beijing.aliyuncs.com/image/1614828637800-1b17de0f-4e61-4a49-82ad-64da1df49bd5.png" alt="image.png" style="zoom:50%;" />

<p>超类之间的某些行为对于子类来说，是不能实现的<br>橡皮鸭可以对fly方法进行override<br>但我们完全可以用接口的方法改变：</p>
<img src="https://cynyard-blog-pics.oss-cn-beijing.aliyuncs.com/image/1614828833997-162d5b97-4d8d-462e-a3c3-07e886aba92a.png" alt="image.png" style="zoom:50%;" />

<p>但是也有问题，如果需要更改很多只鸭子的飞行的行为，需要逐一改动</p>
<h3 id="封装变化原则"><a href="#封装变化原则" class="headerlink" title="封装变化原则"></a>封装变化原则</h3><blockquote>
<p>区别应用中变化并且能起区分作用的部分，分开变化和不变的部分</p>
</blockquote>
<ul>
<li>从而能够区分和封装变化的部分，可以在不影响其他部分的情况下做出改变</li>
<li>把飞行，叫的行为封装成行为类，实现行为接口</li>
<li>每个鸭子拥有一个抽象接口，从而可以赋予不同的飞的具体行为</li>
<li>同理于叫</li>
</ul>
<img src="https://cynyard-blog-pics.oss-cn-beijing.aliyuncs.com/image/1615256150552-606726a4-9368-40fd-97bb-72efe4281ffb.png" alt="image.png" style="zoom: 33%;" />

<img src="https://cynyard-blog-pics.oss-cn-beijing.aliyuncs.com/image/1615256417904-35a18c87-baa9-42be-a406-92189e8284af.png" alt="image.png" style="zoom:50%;" />

<h3 id="面向接口编程而不面向实现"><a href="#面向接口编程而不面向实现" class="headerlink" title="面向接口编程而不面向实现"></a>面向接口编程而不面向实现</h3><p>并非是鸭子的类来实现飞行的接口，是一些具体飞行行为实现飞行的接口</p>
<p>回想多态，被声明的类一般都是超类，即抽象类或者接口，所以负责声明的类并不需要知道具体的对象类型是什么，</p>
<h3 id="组合优于继承"><a href="#组合优于继承" class="headerlink" title="组合优于继承"></a>组合优于继承</h3><ul>
<li>组合带来了更多的灵活性</li>
<li>组合封装了一系列的行为/算法，并且能够在运行的时候实时改变</li>
</ul>
<h2 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h2><blockquote>
<p>由多态形成的</p>
</blockquote>
<p><a target="_blank" rel="noopener" href="http://c.biancheng.net/view/1378.html">http://c.biancheng.net/view/1378.html</a></p>
<img src="https://cynyard-blog-pics.oss-cn-beijing.aliyuncs.com/image/1615258496260-d2d29039-068d-4149-ab08-38514e842fc5.png" alt="image.png" style="zoom:50%;" />

<h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><ul>
<li>定义并且包装一系列的策略/算法，并将其设计为可相互替换的（面向接口）</li>
<li>通过策略让不同的使用者（Client）使用不同的算法</li>
</ul>
<h3 id="动机"><a href="#动机" class="headerlink" title="动机"></a>动机</h3><ul>
<li>当我们需要用很多条件语句来定义行为的时候，<strong>消除条件语句</strong></li>
<li>这种hard-wiring的注入方法并不理想，<strong>替代继承</strong></li>
<li>不同的时候需要不同的算法，但是我们并不想支持我们并不实用的算法</li>
<li>增加和改变新的算法的时候，将会非常困难</li>
</ul>
<h3 id="适用性"><a href="#适用性" class="headerlink" title="适用性"></a>适用性</h3><ul>
<li>许多行为中的一个行为用来配置类，许多相关的类的差别就在于行为的不同</li>
<li>一个相同的算法/行为，可能会有不同的实现形式，基于不同tradeoff的考虑进行选择</li>
<li>算法使用了客户不应该知道的数据，通过策略模式可以隐藏具体的算法实现，也就是数据结构的隐藏</li>
<li>代替了条件语句的移入</li>
</ul>
<h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ul>
<li>暴露了实现细节，客户<strong>必须了解不同的策略</strong>，如果要选择一个合适的策略/算法给Context使用，就必须知道这些策略到底有什么不同，可能就会暴露具体的实现问题</li>
<li>通信开销，每个不同的算法，都共享了Strategy共享的接口，有些具体算法并不会用到通过接口传递给他们的信息。也就意味着使用具体算法的Context会创建一些永远用不到的参数</li>
<li>增加了对象的数目</li>
</ul>
<h2 id="简单工厂模式"><a href="#简单工厂模式" class="headerlink" title="简单工厂模式"></a>简单工厂模式</h2><img src="https://cynyard-blog-pics.oss-cn-beijing.aliyuncs.com/image/1615259244963-e5975dbc-f3fe-4b41-b016-dfe95dc61676.png" alt="image.png" style="zoom: 33%;" />

<h3 id="动机-1"><a href="#动机-1" class="headerlink" title="动机"></a>动机</h3><ul>
<li>我们在使用一个工具的时候，他有许多相同层次的兄弟工具，修改了部分属性，并且他们都继承于一个相同的基类</li>
<li>我们在使用这些工具的时候，不想知道这些工具到底叫做什么，我们只想知道表示不同工具的参数，并且有一个调用工具的方法，只要把参数传入给方法就可以获得对应的工具，例如给我一个圆的按钮，给我一个长的板凳</li>
</ul>
<h3 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h3><ul>
<li>静态工厂方法</li>
<li>可以根据参数的不同，返回不同类的实例</li>
<li>定义了一个工厂类来负责创建其他类的实例</li>
<li>被创建的实例通常都有共同的父类（可以是Abstract）</li>
</ul>
<h3 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h3><ul>
<li>Factory：工厂角色，一个</li>
<li>Product：抽象产品角色，一个</li>
<li>ConcreteProduct：具体产品角色，多个</li>
</ul>
<h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><ul>
<li>需要什么就能得到什么，客户端只需要知道<strong>参数</strong>，不用知道创建细节</li>
<li>对象的创建以及对象的业务处理分离，降低耦合性</li>
<li>静态方法使用方便，参数甚至可以保存在配置文件中，不需要修改源代码</li>
<li>工厂是知道具体的产品的，所以工厂需要依赖具体的产品而不是产品接口</li>
</ul>
<h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ul>
<li>责任的分割</li>
<li>减少使用者的记忆量</li>
<li>配置文件的引入避免了一些代码的修改</li>
</ul>
<h3 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h3><ul>
<li>工厂职责过重，增加新的产品需要修改工厂的判断逻辑，与开闭原则相互违背，</li>
<li>工厂能否正常工作决定了系统能否正常工作</li>
<li>系统拓展困难</li>
<li>工厂角色无法形成基于继承的等级结构</li>
</ul>
<h3 id="适用性-1"><a href="#适用性-1" class="headerlink" title="适用性"></a>适用性</h3><ul>
<li>对象比较少</li>
<li>客户不关心</li>
</ul>
<h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><h4 id="创建用户"><a href="#创建用户" class="headerlink" title="创建用户"></a>创建用户</h4><img src="https://cynyard-blog-pics.oss-cn-beijing.aliyuncs.com/image/20210624163339.png" alt="image-20210624163312114" style="zoom: 33%;" />

<h4 id="JDK"><a href="#JDK" class="headerlink" title="JDK"></a>JDK</h4><img src="https://cynyard-blog-pics.oss-cn-beijing.aliyuncs.com/image/1615259964305-33f27b0a-89f5-4fbd-a877-011ab63edf91.png" alt="image.png" style="zoom: 33%;" />

<h4 id="Java加密"><a href="#Java加密" class="headerlink" title="Java加密"></a>Java加密</h4><img src="https://cynyard-blog-pics.oss-cn-beijing.aliyuncs.com/image/1615259977446-bd1f6246-57ee-4758-83ff-74ee9eab09ab.png" alt="image.png" style="zoom: 33%;" />

<h3 id="拓展"><a href="#拓展" class="headerlink" title="拓展"></a>拓展</h3><blockquote>
<p>抽象类可以没有抽象方法，抽象方法一定属于抽象类</p>
</blockquote>
<ul>
<li>工厂类可以由抽象产品扮演，通过抽象产品来创建子类产品的实例</li>
<li><strong>使用静态工厂方法创建子类</strong></li>
</ul>
<img src="https://cynyard-blog-pics.oss-cn-beijing.aliyuncs.com/image/image-20210624163753762.png" alt="image-20210624163753762" style="zoom: 50%;" />

<h2 id="工厂方法模式"><a href="#工厂方法模式" class="headerlink" title="工厂方法模式"></a>工厂方法模式</h2><blockquote>
<p>工厂父类负责定义创建产品对象的公共接口，而工厂子类则负责生成具体的产品对象，这样做的目的是将产品类的实例化操作延迟到工厂子类中完成，即通过工厂子类来确定究竟应该实例化哪一个具体 产品类</p>
</blockquote>
<img src="https://cynyard-blog-pics.oss-cn-beijing.aliyuncs.com/image/1615260396929-147f8e6c-41b1-43ea-a754-f56d2e0b66b5.png" alt="image.png" style="zoom: 33%;" />

<h3 id="动机-2"><a href="#动机-2" class="headerlink" title="动机"></a>动机</h3><ul>
<li>在简单工厂方法中，需要增加新的产品</li>
<li>那么现在我们不设计一个按钮工厂类来统一负责所有产品的创建，而是每个具体产品对应着每个具体的工厂</li>
<li>这样就可以在不修改具体工厂类的情况下引进新的产品，更加符合开闭原则</li>
</ul>
<h3 id="定义-2"><a href="#定义-2" class="headerlink" title="定义"></a>定义</h3><ul>
<li>工厂模式，或者多态工厂模式，或者虚拟构造器模式</li>
<li>工厂抽象类负责定义创建产品对象的方法，也就是公共接口</li>
<li>工厂子类则负责生成具体的产品对象</li>
<li>每次声明一个抽象工厂对象和抽象产品对象，然后用具体工厂来赋值，然后创建具体产品</li>
</ul>
<h3 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h3><ul>
<li>核心的工厂类将不会再负责所有产品的创建</li>
<li>具体的创建功能交给子类去完成</li>
<li>(也可以接受一个参数，一个工厂产生不同产品)</li>
<li>核心工厂类只用给出具体工厂类需要实现的接口，不用负责哪个产品被实例化</li>
<li>这可以允许系统在不修改工厂角色的情况下引进新产品，一个新产品只需要一个具体产品对象以及一个具体工厂对象</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">PayMethodFactory</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> AbstractPay <span class="title">getPayMethod</span><span class="params">()</span></span>; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CashPayFactory</span> <span class="keyword">extends</span> <span class="title">PayMethodFactory</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> AbstractPay <span class="title">getPayMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    	<span class="keyword">return</span> <span class="keyword">new</span> CashPay(); &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">		PayMethodFactory factory; </span><br><span class="line">    factory=<span class="keyword">new</span> CashPayFactory(); </span><br><span class="line">    AbstractPay payMethod; </span><br><span class="line">    payMethod =factory.getPayMethod();</span><br><span class="line">    payMethod.pay();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="实例-1"><a href="#实例-1" class="headerlink" title="实例"></a>实例</h3><h4 id="Java反射创建举例"><a href="#Java反射创建举例" class="headerlink" title="Java反射创建举例"></a>Java反射创建举例</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot;?&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">config</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">className</span>&gt;</span>CashPayFactory<span class="tag">&lt;/<span class="name">className</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">config</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">PayMethodFactory factory;</span><br><span class="line">AbstractPay payMethod;</span><br><span class="line">factory=(PayMethodFactory)XMLUtil.getBean(); <span class="comment">//getBean()的返回类型 为Object，此处需要进行强制类型转换</span></span><br><span class="line">payMethod =factory.getPayMethod(); </span><br><span class="line">payMethod.pay();</span><br></pre></td></tr></table></figure>
<h4 id="日志记录器"><a href="#日志记录器" class="headerlink" title="日志记录器"></a>日志记录器</h4><img src="https://cynyard-blog-pics.oss-cn-beijing.aliyuncs.com/image/1615261257284-fadf24f0-39be-49a9-ae9d-4a3d3849c181.png" alt="image.png" style="zoom:50%;" />

<h3 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h3><ul>
<li>只需要关心产品对应的工厂，甚至都不用关心具体产品类的类名</li>
<li>系统加入新产品的时候，不需要修改抽象工厂和抽象产品提供的接口，只需要增加</li>
<li>工厂创建的细节对用户不可见，工厂决定创建</li>
</ul>
<h3 id="缺点-2"><a href="#缺点-2" class="headerlink" title="缺点"></a>缺点</h3><ul>
<li>类的个数<strong>成对增加</strong></li>
<li>引入抽象层，增加了抽象性和理解难度</li>
</ul>
<h3 id="适用性-2"><a href="#适用性-2" class="headerlink" title="适用性"></a>适用性</h3><ul>
<li>一个类可以不知道具体需要的对象的类，只需要知道具体的工厂就好</li>
<li>系统更容易扩展，工厂的子类负责具体的创建，运用多态和里式代换原则，子类对象覆盖父类对象</li>
<li>客户端在使用的时候可以无须关心哪个工厂子类创建产品，需要的时候动态制定，可以将具体工厂的类存储在配置文件或者数据库</li>
</ul>
<h2 id="抽象工厂"><a href="#抽象工厂" class="headerlink" title="抽象工厂"></a>抽象工厂</h2><blockquote>
<p>工厂方法模式中具体工厂负责生产具体的产品，每一个具体工厂对应一种具体产品，有时候我们需要一个工厂可以提供多个产品对象，而不是单一的产品对象</p>
</blockquote>
<h3 id="动机-3"><a href="#动机-3" class="headerlink" title="动机"></a>动机</h3><ul>
<li>我们需要一个工厂可以提供多个产品对象，而不是单一的产品对象</li>
</ul>
<h3 id="新概念"><a href="#新概念" class="headerlink" title="新概念"></a>新概念</h3><h4 id="产品等级结构"><a href="#产品等级结构" class="headerlink" title="产品等级结构"></a>产品等级结构</h4><ul>
<li>产品的继承结构，例如电视机是抽象的父类，子类就有小米电视机，华为电视机，TCL电视机</li>
<li>抽象电视机和具体品牌的电视机之间就构成了一个产品等级结构</li>
</ul>
<h4 id="产品族"><a href="#产品族" class="headerlink" title="产品族"></a>产品族</h4><ul>
<li>产品族就指，同一个工厂生产的，但是处于不同产品等级结构中的一组产品</li>
<li>例如小米电器工厂生产的小米电视，小米手机，小米冰箱</li>
</ul>
<img src="https://cynyard-blog-pics.oss-cn-beijing.aliyuncs.com/image/1615875503856-84f88474-037f-49c9-9e7c-d3b282649f19.png" alt="image.png" style="zoom:50%;" />

<h3 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h3><ul>
<li>工厂方法模式针对的是一个产品等级结构，抽象工厂模式需要面对多个产品等级结构</li>
<li>一个具体工厂生产的产品必定是属于同一个产品族的，可以创建出分属于不同的产品等级结构（不同类型）的一个产品族（同一品牌）中的所有对象时</li>
<li>当一个产品族只有一个产品的时候，退化为工厂方法模式</li>
<li>当具体工厂合并，使用统一的工厂中的静态方法来创建产品时，工厂方法模式退化为简单工厂模式</li>
</ul>
<h3 id="定义-3"><a href="#定义-3" class="headerlink" title="定义"></a>定义</h3><ul>
<li>提供一个创建一系列相关或者相互依赖对象的接口，而无需指定具体的类</li>
<li>对象创建型模式</li>
</ul>
<h3 id="分析-2"><a href="#分析-2" class="headerlink" title="分析"></a>分析</h3><ul>
<li>一般包含四个角色，抽象工厂，具体工厂，抽象产品，具体产品</li>
<li>变化的是产品族</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractFactory</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> AbstractProductA <span class="title">createProductA</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> AbstractProductB <span class="title">createProductB</span><span class="params">()</span></span>; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteFactory1</span> <span class="keyword">extends</span> <span class="title">AbstractFactory</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> AbstractProductA <span class="title">createProductA</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> ConcreteProductA1(); </span><br><span class="line">    &#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> AbstractProductB <span class="title">createProductB</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> ConcreteProductB1(); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteFactory2</span> <span class="keyword">extends</span> <span class="title">AbstractFactory</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> AbstractProductA <span class="title">createProductA</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> ConcreteProductA2(); </span><br><span class="line">    &#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> AbstractProductB <span class="title">createProductB</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> ConcreteProductB2(); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="实例-2"><a href="#实例-2" class="headerlink" title="实例"></a>实例</h3><img src="https://cynyard-blog-pics.oss-cn-beijing.aliyuncs.com/image/1615875659848-5180943b-3067-4561-9c1d-27f3be99c4ee.png" alt="image.png" style="zoom:50%;" />

<img src="https://cynyard-blog-pics.oss-cn-beijing.aliyuncs.com/image/1615876820243-04723d23-a81d-4012-b64f-a35b67e205c5.png" alt="image.png" style="zoom:50%;" />

<h3 id="优点-2"><a href="#优点-2" class="headerlink" title="优点"></a>优点</h3><ul>
<li><strong>隔离了具体类的生成</strong>，客户并不知道什么被创建</li>
<li>所有的具体工厂都实现了抽象工厂中定义的那些公共接口，所以<strong>只需要改变具体工厂的实例就可以在某种程度上改变整个软件系统的行为</strong></li>
<li>高内聚，低耦合</li>
<li>当一个产品族的多个对象被设计成一起工作的时候，能够保证客户端始终<strong>只是用同一个产品族的对象</strong>，因为只使用了一个具体工厂</li>
<li>增加新的产品族和工厂很方便，符合开闭原则</li>
</ul>
<h3 id="缺点-3"><a href="#缺点-3" class="headerlink" title="缺点"></a>缺点</h3><ul>
<li>难以扩展，如果要支持新种类的产品，就代表着对接口的扩展</li>
<li>例如已经有了洗衣机和电视机，增加电脑就意味着对接口进行拓展，在抽象工厂类，所有具体工厂类都需要增加生产新产品的方法，不能很好的支持开闭原则</li>
<li>增加新的工厂以及产品族容易，但是增加新的产品等级结构麻烦</li>
</ul>
<h3 id="适用性-3"><a href="#适用性-3" class="headerlink" title="适用性"></a>适用性</h3><ul>
<li>一个系统并不依赖产品实例如何被创建，组合，和表达的细节</li>
<li>一个系统中有多个产品族，而每次都只使用其中某一个产品族</li>
<li>属于同一个产品族的产品将在一起被使用</li>
<li>系统提供一个产品类的库，所有的产品以同样的接口出现</li>
</ul>
<h2 id="建造者模式"><a href="#建造者模式" class="headerlink" title="建造者模式"></a>建造者模式</h2><img src="https://cynyard-blog-pics.oss-cn-beijing.aliyuncs.com/image/image-20210624172157351.png" alt="image-20210624172157351" style="zoom:50%;" />

<h3 id="动机-4"><a href="#动机-4" class="headerlink" title="动机"></a>动机</h3><ul>
<li>无论是在现实世界中还是在软件系统中，都存在一些复杂的对象，它们拥有一系列<strong>成员属性</strong>，并且有些成员属性还是成员对象，并且在这些负责对象中，还有<strong>属性之间的限制条件</strong>，如汽车，它包括车轮、 方向盘、发送机等各种部件。</li>
<li>而对于大多数用户而言，无须知道这些部件的装配细节，也几乎不会使用单独某个部件，而是使用一辆完整的汽车</li>
<li>可以通过建造者模式对其进行设计与描述，建造者模式可以将部件和其组装过程分开，一步一步创建一个复杂的对象。</li>
<li>用户只需要指定复杂对象的类型就可以得到该对象，而<strong>无须知道其内部的具体构造细节</strong>，<strong>也无需关心改复杂对象包含的属性</strong></li>
</ul>
<h3 id="定义-4"><a href="#定义-4" class="headerlink" title="定义"></a>定义</h3><ul>
<li>将一个复杂对象的创建与他的表示分离，使得同样的构建过程可以创建不同的表示</li>
<li>一步一步创建一个复杂的对象，用户只需要指定复杂对象的类型和内容就可以构建他们</li>
</ul>
<h3 id="结构-1"><a href="#结构-1" class="headerlink" title="结构"></a>结构</h3><ul>
<li>抽象建造者Builder</li>
<li>具体建造者ConcreteBuilder</li>
<li>指挥者Director，负责控制产品的生成过程，隔绝了客户与生产过程，针对抽象建造者编程，而客户端只需要知道具体建造者的类型，通过调用Director的setBuilder(…)，然后再调用construct()</li>
<li>产品角色Product（包含了多个part）</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Builder builder = <span class="keyword">new</span> ConcreteBuilder();</span><br><span class="line">Director director = <span class="keyword">new</span> Director(builder);</span><br><span class="line">Product product = director.construct();</span><br></pre></td></tr></table></figure>
<h3 id="分析-3"><a href="#分析-3" class="headerlink" title="分析"></a>分析</h3><ul>
<li>不变的是构建过程</li>
<li>变化的是产品表示，抽象的就是产品的表示</li>
</ul>
<h3 id="实例-3"><a href="#实例-3" class="headerlink" title="实例"></a>实例</h3><h4 id="点餐"><a href="#点餐" class="headerlink" title="点餐"></a>点餐</h4><p>用户告诉（setMealBuilder）waiter（director）我要套餐1（SubMealBuilderA），然后waiter调用construct，然后依次调用SubMealBuilderA的方法，最后通过getMeal方法，组装成具体的Meal，返回给waiter</p>
<img src="https://cynyard-blog-pics.oss-cn-beijing.aliyuncs.com/image/1615878950829-8516fc0f-a2af-4555-905c-826a003b2564.png" alt="image.png" style="zoom: 50%;" />

<p>如果Food和Drink都是对象的话，感觉抽象工厂也来了啊</p>
<h4 id="邮件对象"><a href="#邮件对象" class="headerlink" title="邮件对象"></a>邮件对象</h4><p>这里的</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//由邮件会话对象新建一个邮件消息对象</span></span><br><span class="line">MimeMessage message=<span class="keyword">new</span> MimeMessage(session); <span class="comment">// 这里是建造者模式的简化版，director和builder结合了</span></span><br><span class="line"><span class="comment">//设置邮件地址</span></span><br><span class="line">InternetAddress from=<span class="keyword">new</span> InternetAddress(<span class="string">&quot;sunny@test.com&quot;</span>); message.setFrom(from);</span><br><span class="line"><span class="comment">//设置发件人</span></span><br><span class="line">InternetAddress to=<span class="keyword">new</span> InternetAddress(to_mail); </span><br><span class="line"><span class="comment">//设置收件人，并设置其接收类型为TO</span></span><br><span class="line">message.setRecipient(Message.RecipientType.TO,to);</span><br><span class="line"><span class="comment">//设置主题</span></span><br><span class="line">message.setSubject(to_title);</span><br><span class="line"><span class="comment">//设置内容</span></span><br><span class="line">message.setText(to_content);</span><br><span class="line"><span class="comment">//设置发信时间</span></span><br><span class="line">message.setSentDate(<span class="keyword">new</span> Date());</span><br><span class="line"><span class="comment">//存储邮件信息</span></span><br><span class="line">message.saveChanges();</span><br><span class="line">Transport transport=session.getTransport(<span class="string">&quot;smtp&quot;</span>); </span><br><span class="line">transport.connect(<span class="string">&quot;smtp.test.com&quot;</span>,<span class="string">&quot;test&quot;</span>,<span class="string">&quot;test&quot;</span>); </span><br><span class="line">transport.sendMessage(message,message.getAllRecipients());</span><br></pre></td></tr></table></figure>
<h3 id="优点-3"><a href="#优点-3" class="headerlink" title="优点"></a>优点</h3><ul>
<li>新产品只用增加新的建造者</li>
<li>使用不同建造者就可以得到不同的产品对象</li>
<li>能够控制产品的创建过程</li>
<li>客户端只用给指挥者传入建造者，调用指挥者的construct方法</li>
</ul>
<h3 id="缺点-4"><a href="#缺点-4" class="headerlink" title="缺点"></a>缺点</h3><ul>
<li>产品都具有较多的共同点，至少在创建流程上需要一样</li>
<li>如果产品的内部变化复杂，可能会导致需要定义很多具体的建造者来实现这种变化，导致系统变得很庞大</li>
</ul>
<h3 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h3><ul>
<li>建造者返回一个组装好的完整产品，抽象工厂模式返回一系列相关的产品（同一个产品族）</li>
<li>抽象工厂模式中，客户端实例化工厂类，然后点用工厂方法获取需要的产品族；在建造者模式中，客户端可以不直接调用建造者的方法，而是通过director来指导如何生成对象，客户端只是告诉director需要哪个产品</li>
<li>抽象模式就是汽车配件生产工厂，生产一个产品族的各种配件，建造者模式就是汽车组装工厂，通过对配件的组装，可以返回一辆完整的车</li>
</ul>
<h2 id="原型模式"><a href="#原型模式" class="headerlink" title="原型模式"></a>原型模式</h2><img src="https://cynyard-blog-pics.oss-cn-beijing.aliyuncs.com/image/image-20210624182118396.png" alt="image-20210624182118396" style="zoom:50%;" />

<h3 id="动机-5"><a href="#动机-5" class="headerlink" title="动机"></a>动机</h3><ul>
<li><p>使用原型模式来复制一个对象自身，从而克隆出多个与原型对象一模一样的对象</p>
</li>
<li><p>有些对象的创建过程比较复杂，这样可以使用原型模式</p>
</li>
</ul>
<h3 id="定义-5"><a href="#定义-5" class="headerlink" title="定义"></a>定义</h3><ul>
<li>一种对象创建型模式</li>
<li>用原型实例指定创建对象的种类，并且通过复制这些prototype来创建新的对象</li>
<li>基本工作原理就是通过将一个原型对象传给那个要发动创建的对象，这个对象通过<strong>请求原型对象拷贝原型自己</strong>来实现创建过程</li>
</ul>
<h3 id="结构-2"><a href="#结构-2" class="headerlink" title="结构"></a>结构</h3><ul>
<li>Prototype：抽象原型</li>
<li>ConcretePrototype：具体原型</li>
<li>Client：客户</li>
</ul>
<h3 id="分析-4"><a href="#分析-4" class="headerlink" title="分析"></a>分析</h3><ul>
<li><p>Java语言中Object对象都有一个clone方法</p>
</li>
<li><p>能够被克隆的原型对象，必须实现接口<strong>Cloneable</strong>，表示这个对象支持复制</p>
</li>
<li><p>深度克隆表示成员对象也克隆</p>
</li>
<li><p>clone()返回的对象满足，与原对象不同，但是属于一个类，并且在定义合理的情况下，equals()也应该返回true</p>
</li>
</ul>
<h3 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h3><h4 id="邮件浅克隆"><a href="#邮件浅克隆" class="headerlink" title="邮件浅克隆"></a>邮件浅克隆</h4><p>复制邮件的同时不复制附件</p>
<img src="https://cynyard-blog-pics.oss-cn-beijing.aliyuncs.com/image/image-20210624182835699.png" alt="image-20210624182835699" style="zoom:50%;" />

<h3 id="优点-4"><a href="#优点-4" class="headerlink" title="优点"></a>优点</h3><ul>
<li>简化对象的创建过程，提供了简化的创建结构</li>
<li>动态增加或者减少产品类</li>
<li>可以使用深克隆的方式保存对象的状态</li>
</ul>
<h3 id="缺点-5"><a href="#缺点-5" class="headerlink" title="缺点"></a>缺点</h3><ul>
<li>需要给每一个类配备一个克隆方法</li>
<li>深克隆很复杂</li>
<li>对克隆方法进行改造的时候必须修改源代码</li>
</ul>
<h3 id="对比-1"><a href="#对比-1" class="headerlink" title="对比"></a>对比</h3><p>重点在于从已有对象上克隆，模版方法重点在于在父类上修改，精细化，工厂模式在于生产不同的类型的对象</p>
<h3 id="模式举例"><a href="#模式举例" class="headerlink" title="模式举例"></a>模式举例</h3><ul>
<li>Spring Bean</li>
<li>Control C V</li>
</ul>
<h3 id="模式拓展"><a href="#模式拓展" class="headerlink" title="模式拓展"></a>模式拓展</h3><ul>
<li>原型管理器</li>
<li>相似对象的复制，即复制后修改属性</li>
</ul>
<h2 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h2><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/u011386173/article/details/82454714">https://blog.csdn.net/u011386173/article/details/82454714</a><br><a target="_blank" rel="noopener" href="https://www.kancloud.cn/dengyigegushi/details-dahua/100445">https://www.kancloud.cn/dengyigegushi/details-dahua/100445</a></p>
<h2 id="状态模式"><a href="#状态模式" class="headerlink" title="状态模式"></a>状态模式</h2><h3 id="动机-6"><a href="#动机-6" class="headerlink" title="动机"></a>动机</h3><ul>
<li>一个对象的行为取决于它的状态，这些状态就是一个或者 多个可以动态变化的属性</li>
<li>有状态的对象的状态是可以从实现定义好的一系列值/属性中取出</li>
<li>当对象与外部时间产生互动的时候，内部状态就会发生改变，系统的行为就发生改变（我们希望对象能够与外界交互并发生改变）</li>
</ul>
<h3 id="定义-6"><a href="#定义-6" class="headerlink" title="定义"></a>定义</h3><ul>
<li>当一个对象的内在状态改变的时候，允许改变其行为，这个对象看起来就像是改变了类</li>
<li>状态模式主要解决的是，当<strong>控制一个对象状态转换的条件表达式过于复杂的</strong>时候（太多的if-else，switch）</li>
<li>可以把状态的判断逻辑转移到表示<strong>不同状态</strong>的一系列<strong>类</strong>中，可以把复杂的判断逻辑简化</li>
<li>在用户看来，就像是对象自己在运行的时候改变了自己的代码，变化被隐藏</li>
</ul>
<img src="https://cynyard-blog-pics.oss-cn-beijing.aliyuncs.com/image/1616048446681-22dd0cbf-f3b0-45df-b709-4831b11619fd.png" alt="image.png" style="zoom:50%;" />

<h3 id="结构-3"><a href="#结构-3" class="headerlink" title="结构"></a>结构</h3><ul>
<li>Context环境类，拥有状态，每次调用request，调用自己的状态对象实例的handle（将自己的引用传入）</li>
<li>State抽象状态类，可以是抽象类，可以是接口，封装行为</li>
<li>ConcreteState具体状态类，用来进行context的状态切换</li>
</ul>
<h3 id="分析-5"><a href="#分析-5" class="headerlink" title="分析"></a>分析</h3><ul>
<li>与策略模式的图，没有一点差别，但是目的不同，状态模式中，向用户保留了透明性</li>
<li>关于状态的转换保留到了具体状态的内部</li>
<li>状态模式描述了对象状态的变换，以及对象如何在每一种变化之下表现出不同的行为</li>
</ul>
<img src="https://cynyard-blog-pics.oss-cn-beijing.aliyuncs.com/image/1616049247903-c5944cec-fbee-43a0-842a-59c66f29c8b1.png" alt="image.png" style="zoom:50%;" />

<ul>
<li>当然，每个具体状态的handle里面，也可以根据用户的下一个行为，或者context的数据，决定下一个状态：</li>
</ul>
<img src="https://cynyard-blog-pics.oss-cn-beijing.aliyuncs.com/image/1616049503079-f61198e4-213d-4c1c-b3f8-d07b4a96b795.png" alt="image.png" style="zoom:50%;" />

<img src="https://cynyard-blog-pics.oss-cn-beijing.aliyuncs.com/image/1616049331619-d9d7662f-5b52-4d34-9f74-656f6a5f57fd.png" alt="image.png" style="zoom:50%;" />

<ul>
<li>但是还是不符合开闭原则，如果需要加一个新的状态，需要修改相关状态的代码，为了获得完全的透明性，付出了代价</li>
<li><strong>策略模式是符合开闭原则的</strong></li>
<li>由于每次切换都要new状态，所以状态对象尽可能小，更好的是，状态本身是没有状态的，也就是说状态对象可以重用</li>
</ul>
<h3 id="实例-4"><a href="#实例-4" class="headerlink" title="实例"></a>实例</h3><img src="https://cynyard-blog-pics.oss-cn-beijing.aliyuncs.com/image/1616049983115-300b0e39-79ba-4779-b14e-8b26a119cdf8.png" alt="image.png" style="zoom:50%;" />

<ul>
<li>由行为导致的状态切换→由数据导致的状态切换，前者应该由具体的状态类完成，后者用context类来完成（他知道自己的所有状态</li>
<li>所以，具体的状态对象只放行为以及由行为表示的切换</li>
</ul>
<h3 id="优点-5"><a href="#优点-5" class="headerlink" title="优点"></a>优点</h3><ul>
<li>封装了转换规则</li>
<li>枚举可能的状态，可以方便地增加新的状态</li>
<li>允许状态转换逻辑与状态对象合成一体，而不是一个巨大的条件语句块</li>
<li>可以让多个环境对象共享一个状态对象（状态对象可以重用，静态成员对象），我可以不开心，你也可以同时不开心</li>
</ul>
<h3 id="缺点-6"><a href="#缺点-6" class="headerlink" title="缺点"></a>缺点</h3><ul>
<li>增加系统类和对象的个数</li>
<li>状态模式的结构较为复杂</li>
<li>对开闭原则不友好，对于可以切换状态的状态模式，增加新的状态类需要修改那些负责转换的源代码</li>
</ul>
<h2 id="命令模式"><a href="#命令模式" class="headerlink" title="命令模式"></a>命令模式</h2><img src="https://cynyard-blog-pics.oss-cn-beijing.aliyuncs.com/image/1616051539317-4babacb9-d286-490e-b04a-7719309360f0.png" alt="image.png" style="zoom:50%;" />

<h3 id="动机-7"><a href="#动机-7" class="headerlink" title="动机"></a>动机</h3><ul>
<li><p>发送者和接受者完全解耦，两者之间没有任何引用关系，发送请求的对象只需要知道如何发送请求，但是不知道如何完成请求</p>
</li>
<li><p>将不同的receiver的方法调用包装成同一个对象</p>
</li>
</ul>
<h3 id="定义-7"><a href="#定义-7" class="headerlink" title="定义"></a>定义</h3><ul>
<li>将一个请求封装为一个对象，从而你可以用不同的请求对客户进行参数化：对请求排队或者记录请求日志，以及支持可以撤销的操作</li>
<li>对象行为型模式</li>
</ul>
<h3 id="结构-4"><a href="#结构-4" class="headerlink" title="结构"></a>结构</h3><ul>
<li>Command：抽象命令类</li>
<li>Concrete Command：具体命令类，每个命令类有自己对应的receiver（每道菜有对应的厨师）</li>
<li>Invoker调用者</li>
<li>Receiver接收者</li>
<li>Client客户类</li>
</ul>
<h3 id="分析-6"><a href="#分析-6" class="headerlink" title="分析"></a>分析</h3><ul>
<li>请求本身成为了一个对象，发送命令的一方 面向抽象命令接口编程，只有实现了抽象命令接口的具体命令才能与接受者关联</li>
</ul>
<ul>
<li>invoker从client获取具体的command，自己本身只有接口，然后调用command的execute，每个command中有receiver的对象，调用receiver的action（不同的command调用不同的receiver的方法）</li>
<li>Client只是负责产生receiver和把command给服务员</li>
<li>invoker可以实现一个command队列：</li>
</ul>
<img src="https://cynyard-blog-pics.oss-cn-beijing.aliyuncs.com/image/1616052855855-8643077f-2adf-4854-b34c-596fa74d63cd.png" alt="image.png" style="zoom: 33%;" />

<h3 id="实例-5"><a href="#实例-5" class="headerlink" title="实例"></a>实例</h3><img src="https://cynyard-blog-pics.oss-cn-beijing.aliyuncs.com/image/1616052382194-464a6a19-04a2-4928-a371-e25439a271d3.png" alt="image.png" style="zoom: 50%;" />

<p>Television是receiver</p>
<p>Controller是invoker</p>
<img src="https://cynyard-blog-pics.oss-cn-beijing.aliyuncs.com/image/1616052729663-535aee4b-704a-4419-a881-607ad913539d.png" alt="image.png" style="zoom: 33%;" />

<p>功能键设置，设置这个键是的 功能</p>
<p>通过setCommand指定功能，然后下次点击的时候，调用execute，然后就调用指定的命令实例的execute，对receiver执行不同的操作</p>
<img src="https://cynyard-blog-pics.oss-cn-beijing.aliyuncs.com/image/1616052690816-d4dd2484-59c4-47af-bc3a-ba507ea20768.png" alt="image.png" style="zoom: 33%;" />

<h3 id="优点-6"><a href="#优点-6" class="headerlink" title="优点"></a>优点</h3><ul>
<li>降低耦合度</li>
<li>新命令的添加</li>
<li>设计命令队列和宏命令（组合命令，命令模式和组合模式联用，notifyAll，foreach）</li>
<li>方便实现Undo和Redo（调用一个完全相反的方法抵消行为，redo就是传入新的command覆盖）</li>
</ul>
<h3 id="缺点-7"><a href="#缺点-7" class="headerlink" title="缺点"></a>缺点</h3><ul>
<li>导致某些系统有过多的具体命令类，因为一个命令就是一个类</li>
</ul>
<h3 id="适用性-4"><a href="#适用性-4" class="headerlink" title="适用性"></a>适用性</h3><ul>
<li>需要将请求者invoker和接收者解耦，使得不直接交互</li>
<li>系统需要在不同的时间，制定请求，请求排队和执行请求</li>
<li>支持命令的撤销和恢复操作</li>
<li>一组操作结合在一起</li>
</ul>
<h3 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h3><h4 id="Java事件委派"><a href="#Java事件委派" class="headerlink" title="Java事件委派"></a>Java事件委派</h4><ul>
<li>页面组件发送请求，AWT提供的事件监听器接口是抽象命令接口，用户自己写具体命令实现事件处理</li>
<li>具体命令类中，可以调用业务处理的方法来执行命令‘</li>
</ul>
<h4 id="撤销操作的实现"><a href="#撤销操作的实现" class="headerlink" title="撤销操作的实现"></a>撤销操作的实现</h4><img src="https://cynyard-blog-pics.oss-cn-beijing.aliyuncs.com/image/image-20210626224548989.png" alt="image-20210626224548989" style="zoom: 50%;" />

<h4 id="宏命令"><a href="#宏命令" class="headerlink" title="宏命令"></a>宏命令</h4><img src="https://cynyard-blog-pics.oss-cn-beijing.aliyuncs.com/image/image-20210626224926146.png" alt="image-20210626224926146" style="zoom:50%;" />

<h2 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h2><h3 id="模式动机"><a href="#模式动机" class="headerlink" title="模式动机"></a>模式动机</h3><ul>
<li><p>建立一种对象与对象之间的依赖关系</p>
</li>
<li><p>一个对象发生改变时将自动通知其他对象其他对象将相应做出反应。</p>
</li>
<li><p>在此， 发生改变的对象称为观察目标，而被通知的对象称为观察者，一个观察目标可以对应多个观察者，</p>
</li>
<li><p>而且这些观察者之间没有相互联系，可以根据需要增加和删除观察者，使得系统更易于扩展</p>
</li>
</ul>
<h3 id="定义-8"><a href="#定义-8" class="headerlink" title="定义"></a>定义</h3><ul>
<li>发布-定义模式，模型-视图模式，源-监听器模式，从属者模式，是一种对象行为模式</li>
<li>每当被观察对象的状态发生改变的时候，相关的依赖对象都能得到通知并且被自动更新</li>
</ul>
<h3 id="结构-5"><a href="#结构-5" class="headerlink" title="结构"></a>结构</h3><img src="https://cynyard-blog-pics.oss-cn-beijing.aliyuncs.com/image/1616466124939-dd463e2e-3712-46d0-bbef-1ca71cdf5cfe.png" alt="image.png" style="zoom:50%;" />

<img src="https://cynyard-blog-pics.oss-cn-beijing.aliyuncs.com/image/1616466965214-3dcac242-5e9d-4f5a-899a-dbbb62d67538.png" alt="image.png" style="zoom:50%;" />

<ul>
<li>目标，具体目标，观察者，具体观察者</li>
<li>观察者使用update方法接收传递过来的数据，必须持有subject的引用，subject引用 方便detach以及pull模式</li>
<li>被观察者维持了观察者的列表（一个反向的引用），发生改动过后就遍历，notify，通知时并不需要知道谁是它的观察者， 可以有任意数目的观察者订阅它并接收通知，观察者也不知道其他观察者的存在</li>
<li>使用抽象的观察者（observer）和被观察者（subject），减少具体类的耦，不同具体类可以重写具体的通知，接收通知方法</li>
</ul>
<h3 id="实例解析"><a href="#实例解析" class="headerlink" title="实例解析"></a>实例解析</h3><h4 id="猫叫，老鼠狗跑"><a href="#猫叫，老鼠狗跑" class="headerlink" title="猫叫，老鼠狗跑"></a>猫叫，老鼠狗跑</h4><img src="https://cynyard-blog-pics.oss-cn-beijing.aliyuncs.com/image/1616467052530-dba1aea7-db12-48d8-807f-0c87f8d0ad65.png" alt="image.png" style="zoom:50%;" />

<h4 id="自定义登陆"><a href="#自定义登陆" class="headerlink" title="自定义登陆"></a>自定义登陆</h4><p>如果LoginEvent发生了，那么就通知给Listener，给他们传入自己的引用，然后让他们进行validate</p>
<img src="https://cynyard-blog-pics.oss-cn-beijing.aliyuncs.com/image/1616467779804-928b4bdf-e111-4353-b02e-d901a5fc471e.png" alt="image.png" style="zoom:50%;" />

<h3 id="优点-7"><a href="#优点-7" class="headerlink" title="优点"></a>优点</h3><ul>
<li>表示层和数据逻辑层的分离，定义了隐式的信息更新传递机制，可以有各种各样的不同的表示层作为观察者</li>
<li>符合开闭原则</li>
<li>支持广播</li>
<li>目标和观察者之间是抽象的耦合</li>
</ul>
<h3 id="缺点-8"><a href="#缺点-8" class="headerlink" title="缺点"></a>缺点</h3><ul>
<li>通知很多观察者会花费很多时间</li>
<li>循环依赖会触发循环调用</li>
<li>观察者并不能知道目标是<strong>如何变化的</strong>，只知道发生了变化</li>
</ul>
<h3 id="适用性-5"><a href="#适用性-5" class="headerlink" title="适用性"></a>适用性</h3><ul>
<li>一个对象的改变导致多个对象的改变，并且不知道具体的数量</li>
<li>一个对象必须通知其他对象，尽管不知道这些对象是谁</li>
<li>系统中创建一个触发链</li>
</ul>
<h3 id="拓展-1"><a href="#拓展-1" class="headerlink" title="拓展"></a>拓展</h3><h4 id="Java包"><a href="#Java包" class="headerlink" title="Java包"></a>Java包</h4><img src="https://cynyard-blog-pics.oss-cn-beijing.aliyuncs.com/image/image-20210626230449799.png" alt="image-20210626230449799" style="zoom:50%;" />

<h4 id="MVC"><a href="#MVC" class="headerlink" title="MVC"></a>MVC</h4><img src="https://cynyard-blog-pics.oss-cn-beijing.aliyuncs.com/image/image-20210626230514112.png" alt="image-20210626230514112" style="zoom:50%;" />

<h2 id="中介者模式"><a href="#中介者模式" class="headerlink" title="中介者模式"></a>中介者模式</h2><h3 id="动机-8"><a href="#动机-8" class="headerlink" title="动机"></a>动机</h3><ul>
<li>系统结构复杂：对象之间存在大量的关联和相互调用，如果有一<strong>个对象发生变化，需要跟踪和该对象关联的所有对象</strong>，进行适当的处理，系统结构复杂</li>
<li>可重用性差：由于一个对象和其他对象具有很强的关联，若没有其他对象的支持，一个对象很难被另一个系统或模块重用，这些对象表现出来更像 一个不可分割的整体，<strong>职责较为混乱。</strong></li>
<li>系统扩展性低：增加一个新的对象需要在原有相关对象上增加引用，增加新的引用关系也需要调整原有对象，系统耦合度很高，对象操作很不灵活，扩展性差。</li>
</ul>
<h3 id="定义-9"><a href="#定义-9" class="headerlink" title="定义"></a>定义</h3><ul>
<li>用一个中介对象来封装一系列的对象交互，中介者使各对象不需要显式地相互引用，从而使其耦合松散</li>
<li>而且可以独立地改变它们之间的交互。</li>
<li>中介者模式又称为调停者模式</li>
<li>它是一种对象行为型模式。</li>
</ul>
<h3 id="结构-6"><a href="#结构-6" class="headerlink" title="结构"></a>结构</h3><img src="https://cynyard-blog-pics.oss-cn-beijing.aliyuncs.com/image/1616470118205-567f21d6-1f90-4bb0-9829-8a6919033c70.png" alt="image.png" style="zoom:50%;" />

<ul>
<li>抽象中介者：包含了抽象同事的列表，并且支持更多的同事注册，以及声明了中介者的行为</li>
<li>具体中介者：定义了中介者的行为</li>
<li>抽象同事类：包含一个抽象中介者的引用，以及声明了同事的方法</li>
<li>具体同事类：定义了自身的方法即拿着中介者的引用如何操作</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Mediator</span> </span>&#123;</span><br><span class="line">	<span class="keyword">protected</span> ArrayList colleagues;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">register</span><span class="params">(Colleague colleague)</span> </span>&#123;  </span><br><span class="line">		colleagues.add(colleague); </span><br><span class="line">  &#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">operation</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteMediator</span> <span class="keyword">extends</span> <span class="title">Mediator</span></span>&#123;</span><br><span class="line">  <span class="function">publiv <span class="keyword">void</span> <span class="title">operation</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ((Colleague)(colleagues.get(<span class="number">0</span>))).method1();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Colleague</span> </span>&#123;</span><br><span class="line">	<span class="keyword">protected</span> Mediator mediator;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Colleague</span><span class="params">(Mediator mediator)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.mediator=mediator;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span></span>; </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteColleague</span> <span class="keyword">extends</span> <span class="title">Colleague</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">ConcreteColleague</span><span class="params">(Mediator mediator)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">super</span>(mediator);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		......</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		mediator.operation1();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="分析-7"><a href="#分析-7" class="headerlink" title="分析"></a>分析</h3><ul>
<li>每个colleague想要给其他colleague进行通信的时候，所有的消息通过中介者进行传递</li>
<li>使得对象之间的关系数量急剧减少</li>
<li>中介者需要中转和协调，中转属于结构性的作用，协调属于行为性的作用，具体中介者需要知道所有具体同事类</li>
<li>通过创造出一个中介者对象，将系统中有关的对象索引用的其他对象数目减少到最小，使得一个对象与其同事对象之间的交互作用被对象与中介者之间的相互作用所替代，迪米特法则</li>
</ul>
<h3 id="实例-6"><a href="#实例-6" class="headerlink" title="实例"></a>实例</h3><p>ChatGroup作为中介者，保存了所有成员的列表</p>
<p>成员自身也有聊天室的引用</p>
<p>钻石会员可以发送图片</p>
<p>聊天室在执行的时候也会对发送内容进行过滤</p>
<img src="https://cynyard-blog-pics.oss-cn-beijing.aliyuncs.com/image/1616470868506-c0916017-8f16-45a9-831f-a0dd61220bfe.png" alt="image.png" style="zoom:50%;" />

<h3 id="优点-8"><a href="#优点-8" class="headerlink" title="优点"></a>优点</h3><ul>
<li>解耦，简化了对象的交互</li>
<li>简化同事类之间的设计和实现</li>
</ul>
<h3 id="缺点-9"><a href="#缺点-9" class="headerlink" title="缺点"></a>缺点</h3><ul>
<li>中介类包含了同事之间的交互细节，可能会导致具体中介者类非常复杂，使得系统难以维护</li>
</ul>
<h3 id="适用性-6"><a href="#适用性-6" class="headerlink" title="适用性"></a>适用性</h3><ul>
<li>对象之间存在复杂的引用关系，并且一个对象引用了其他很多对象并且直接和他们通信</li>
<li>通过一个中间类来封装多个类中的行为，并且不想生成太多的子类</li>
<li>迪米特法则的典型应用（最小知识法则）</li>
</ul>
<h2 id="模版方法模式"><a href="#模版方法模式" class="headerlink" title="模版方法模式"></a>模版方法模式</h2><h3 id="动机-9"><a href="#动机-9" class="headerlink" title="动机"></a>动机</h3><ul>
<li><p>是基于继承的代码复用</p>
</li>
<li><p>面向对象设计的核心之一。</p>
</li>
<li><p>在模板方法模式中，可以将相同的代码放在父类中，而将不同的方法实现放在不同的子类中。</p>
</li>
</ul>
<h3 id="定义-10"><a href="#定义-10" class="headerlink" title="定义"></a>定义</h3><ul>
<li>定义一个算法的骨架，将一些步骤延迟到子类中，子类可以不改变一个算法的结构就可以重定义该算法的特定步骤</li>
<li>类行为型模式</li>
</ul>
<h3 id="分析-8"><a href="#分析-8" class="headerlink" title="分析"></a>分析</h3><ul>
<li>只有类之间的继承关系，没有对象关联关系</li>
<li>抽象类设计师可以给出一个算法的轮廓和骨架，另一个设计是可以负责给出算法的逻辑步骤，实现逻辑步骤的方法是基本方法，汇总起来后被称为模版方法</li>
<li>基本子类的基本方法可以覆盖父类中定义的基本方法，子类中的钩子方法（例如条件判断方法）可以覆盖父类的钩子方法，从而可以通过在子类中实现的钩子方法对父类方法的执行进行约束，实现子类对于父类行为的反向控制</li>
</ul>
<img src="https://cynyard-blog-pics.oss-cn-beijing.aliyuncs.com/image/1616471537757-14984657-978e-4543-a15f-47af22ec6712.png" alt="image.png" style="zoom:50%;" />

<img src="https://cynyard-blog-pics.oss-cn-beijing.aliyuncs.com/image/1616471448041-69632741-d897-4c2f-8bd1-1b8d5a64575e.png" alt="image.png" style="zoom:50%;" />

<img src="https://cynyard-blog-pics.oss-cn-beijing.aliyuncs.com/image/1616471455212-74fff1fe-ccdc-44b2-9156-1e5ce06cab83.png" alt="image.png" style="zoom:50%;" />

<h3 id="模式结构"><a href="#模式结构" class="headerlink" title="模式结构"></a>模式结构</h3><img src="https://cynyard-blog-pics.oss-cn-beijing.aliyuncs.com/image/image-20210627130936235.png" alt="image-20210627130936235" style="zoom:50%;" />

<h3 id="实例-7"><a href="#实例-7" class="headerlink" title="实例"></a>实例</h3><h4 id="银行办理业务"><a href="#银行办理业务" class="headerlink" title="银行办理业务"></a>银行办理业务</h4><p>实现了不同的transact</p>
<img src="https://cynyard-blog-pics.oss-cn-beijing.aliyuncs.com/image/image-20210627131134394.png" alt="image-20210627131134394" style="zoom: 50%;" />

<h4 id="数据库操作的模版"><a href="#数据库操作的模版" class="headerlink" title="数据库操作的模版"></a>数据库操作的模版</h4><img src="https://cynyard-blog-pics.oss-cn-beijing.aliyuncs.com/image/image-20210627131241470.png" alt="image-20210627131241470" style="zoom:50%;" />

<h3 id="优点-9"><a href="#优点-9" class="headerlink" title="优点"></a>优点</h3><ul>
<li>代码复用的基本技术</li>
<li>在一个类中抽象地定义算法，子类中实现对细节的处理</li>
<li>反向的控制结构，<strong>通过父类调用其子类的操作</strong>，通过对子类的拓展添加新的行为，钩子方法使得子类可以控制父类的行为</li>
</ul>
<h3 id="缺点-10"><a href="#缺点-10" class="headerlink" title="缺点"></a>缺点</h3><ul>
<li>不同的实现都需要定义一个子类，导致类的个数增加，但是符合单一职责原则</li>
</ul>
<h3 id="适用性-7"><a href="#适用性-7" class="headerlink" title="适用性"></a>适用性</h3><ul>
<li>一次性实现一个算法的不变的部分，并将可变的行为留给自类</li>
<li>公共的行为被提取出来并且集中到一个公共父类中</li>
</ul>
<h3 id="拓展-2"><a href="#拓展-2" class="headerlink" title="拓展"></a>拓展</h3><h4 id="好莱坞原则"><a href="#好莱坞原则" class="headerlink" title="好莱坞原则"></a>好莱坞原则</h4><p>子类不需要调用父类而是通过父类的方法来调用子类</p>
<h4 id="勾子方法"><a href="#勾子方法" class="headerlink" title="勾子方法"></a>勾子方法</h4><p>为了对其他方法进行约束，通常返回一个布尔类型</p>
<h2 id="适配器模式"><a href="#适配器模式" class="headerlink" title="适配器模式"></a>适配器模式</h2><blockquote>
<p>想想电源适配器</p>
</blockquote>
<h3 id="模式动机-1"><a href="#模式动机-1" class="headerlink" title="模式动机"></a>模式动机</h3><ul>
<li>服务端升级导致的接口不一致的问题，遵循开闭原则又不想改变客户端的原有代码</li>
<li>现有的接口需要转化为客户类期望的接口，保证了对现有类的重用</li>
<li>适配器模式中，定义一个包装类，叫做适配器Adapter，被包装的类叫做适配者（Adaptee）</li>
<li>适配器的作用就是把客户端的请求转发为对适配者的相应接口的调用</li>
<li>客户并不直接访问适配者类，但是是对客户端透明的</li>
<li>既可以通过对象组合，也可以通过类的继承来实现</li>
</ul>
<h3 id="模式结构-1"><a href="#模式结构-1" class="headerlink" title="模式结构"></a>模式结构</h3><ul>
<li>客户端调用request，然后adapter是继承或者实现Target接口，request实际上调用的adaptee的specificRequest</li>
<li>客户端本身不是这个模式的一部分</li>
<li>下面是对象适配器，左边是继承，右边是依赖</li>
</ul>
<img src="https://cynyard-blog-pics.oss-cn-beijing.aliyuncs.com/image/1617087965633-78bb3261-56c0-4660-88ee-d0aacf88cc13.png" alt="image.png" style="zoom:50%;" />

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Adapter</span> <span class="keyword">extends</span> <span class="title">Target</span></span>&#123;</span><br><span class="line">  <span class="keyword">private</span> Adaptee adaptee;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Adapter</span><span class="params">(Adaptee adaptee)</span></span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.adaptee = adaptee;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">request</span><span class="params">()</span></span>&#123;</span><br><span class="line">    adaptee.specificRequest();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<ul>
<li>下面是类适配器，左边是接口实现，右边是继承</li>
<li>adapter在request中直接调用继承下来的specificRequest，好处在于在类的继承的时候是白盒继承的，适配的过程中，是可以对其中的一些方法进行重写，修改</li>
<li>适配器很多时候是进行模块组合的，对类的新的部分进行修改</li>
</ul>
<img src="https://cynyard-blog-pics.oss-cn-beijing.aliyuncs.com/image/1617088188668-2457189e-56be-401a-82de-ef6a223ab119.png" alt="image.png" style="zoom:50%;" />

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Adapter</span> <span class="keyword">extends</span> <span class="title">Adaptee</span> <span class="keyword">implements</span> <span class="title">Target</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">request</span><span class="params">()</span> </span>&#123; <span class="comment">// this method is declared in Target</span></span><br><span class="line">    specificRequest(); <span class="comment">// this method is declared in Adaptee</span></span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="实例分析"><a href="#实例分析" class="headerlink" title="实例分析"></a>实例分析</h3><h4 id="仿生机器人"><a href="#仿生机器人" class="headerlink" title="仿生机器人"></a>仿生机器人</h4><img src="https://cynyard-blog-pics.oss-cn-beijing.aliyuncs.com/image/1617088528529-79f53b53-e1e9-4098-b202-57883f1a2011.png" alt="image.png" style="zoom:50%;" />

<h4 id="加密适配器"><a href="#加密适配器" class="headerlink" title="加密适配器"></a>加密适配器</h4><p>对象适配器，不同的Adapter针对于不同的Adaptee</p>
<img src="https://cynyard-blog-pics.oss-cn-beijing.aliyuncs.com/image/1617088591866-a209eed6-0e5f-482c-9673-1a9f89d7fe7d.png" alt="image.png" style="zoom:50%;" />

<h3 id="优点缺点"><a href="#优点缺点" class="headerlink" title="优点缺点"></a>优点缺点</h3><ul>
<li>目标类和适配者类解耦</li>
<li>增加了类的透明性和复用性</li>
<li>灵活性和拓展性很好</li>
<li>类适配器中，可以通过继承置换一些方法，更加灵活，但是有些语言不能多重继承，一个适配器只能针对一个适配者</li>
<li>对象适配器可以一次性适配多个适配者，但是想要替换适配者类的方法就不容易，只能再做一个适配者的子类，替换掉适配者的方法，然后将子类作为真正的适配者<code>Adaptee subAdaptee = new SubAdaptee();</code></li>
</ul>
<h3 id="应用-1"><a href="#应用-1" class="headerlink" title="应用"></a>应用</h3><h4 id="JDBC"><a href="#JDBC" class="headerlink" title="JDBC"></a>JDBC</h4><ul>
<li>JDBC给出一个客户端的通用接口，具体的数据库的JDBC驱动就是一个适配器</li>
</ul>
<h3 id="模式拓展-1"><a href="#模式拓展-1" class="headerlink" title="模式拓展"></a>模式拓展</h3><h4 id="默认适配器"><a href="#默认适配器" class="headerlink" title="默认适配器"></a>默认适配器</h4><ul>
<li>抽象类实现接口，每个方法有一个默认实现，哦那个方法，抽象类的子类可以选择的覆盖某些方法</li>
<li>单接口适配器模式</li>
</ul>
<img src="https://cynyard-blog-pics.oss-cn-beijing.aliyuncs.com/image/image-20210627142335844.png" style="zoom:50%;" />

<h4 id="双向适配器"><a href="#双向适配器" class="headerlink" title="双向适配器"></a>双向适配器</h4><ul>
<li>对象模式：持有对Target和Adaptee的引用</li>
<li><strong>问题</strong>：如何使用类模式</li>
</ul>
<img src="https://cynyard-blog-pics.oss-cn-beijing.aliyuncs.com/image/1617089197837-46be4d83-dd1d-4279-a1ee-f948cca9dcf0.png" alt="image.png" style="zoom:50%;" />

<h2 id="组合模式"><a href="#组合模式" class="headerlink" title="组合模式"></a>组合模式</h2><blockquote>
<p>更像是一个容器<br>将对象组合成树形结构以表示 部分-整体 的层次结构，组合模式使得用户对单个对象以及组合对象的使用具有一致性</p>
</blockquote>
<h3 id="模式动机-2"><a href="#模式动机-2" class="headerlink" title="模式动机"></a>模式动机</h3><ul>
<li>对于树形结构（例如文件夹），当容器对象的某一个方法被调用的时候，将会遍历整个树形结构，寻找也包含这个方法的成员对象（可以是子容器，也可以是叶子对象），并且调用执行</li>
<li>客户端希望能够有<strong>区别的对待</strong>容器对象和叶子对象，但是希望<strong>一致的处理</strong>，而不需要去具体考虑</li>
<li>组合模式描述了如何将<strong>容器对象和叶子对象进行递归组合</strong>，使得用户在使用的时候无须对他们进行区分，可以一致的处理他们</li>
</ul>
<h3 id="定义-11"><a href="#定义-11" class="headerlink" title="定义"></a>定义</h3><ul>
<li>可以称为 <strong>整体-部分</strong> 模式，属于对象的结构模式，将对象组织到树结构中，可以用来描述整体与部分的关系。</li>
</ul>
<h3 id="模式结构-2"><a href="#模式结构-2" class="headerlink" title="模式结构"></a>模式结构</h3><img src="https://cynyard-blog-pics.oss-cn-beijing.aliyuncs.com/image/1617242824329-d96721e7-1b96-4017-8943-e83dca749db4.png" alt="image.png" style="zoom:50%;" />

<ul>
<li>Component 抽象构件：为叶子构件和容器构件对象声明接口，在该角色中可以包含所有子类共有行为的声明和实现。聚合组成了容器构件</li>
<li>Leaf 叶子构件：在组合结构中表示叶子节点对象，叶子节点没有子节点</li>
<li>Composite 容器构件：在组合结构中表示容器节点对象，容器节点包含子节点，其子节点可以是叶子节点，也可以是容器节点，它提供一个集合用于存储子节点，实现了在抽象构件中定义的行为</li>
<li>Client 客户类</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(Component c)</span></span>; </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(Component c)</span></span>; </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> Component <span class="title">getChild</span><span class="params">(<span class="keyword">int</span> i)</span></span>; </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">operation</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Leaf</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(Component c)</span> </span>&#123; </span><br><span class="line">    <span class="comment">//异常处理或错误提示 </span></span><br><span class="line">  &#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(Component c)</span> </span>&#123; </span><br><span class="line">    <span class="comment">//异常处理或错误提示 </span></span><br><span class="line">  &#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> Component <span class="title">getChild</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123; </span><br><span class="line">    <span class="comment">//异常处理或错误提示 </span></span><br><span class="line">  &#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operation</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">  	<span class="comment">//实现代码</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Composite</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> ArrayList list = <span class="keyword">new</span> ArrayList();</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(Component c)</span> </span>&#123;</span><br><span class="line">  	list.add(c); </span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(Component c)</span> </span>&#123;</span><br><span class="line">    list.remove(c); </span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> Component <span class="title">getChild</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    (Component)list.get(i); </span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operation</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(Object obj:list) &#123;</span><br><span class="line">      ((Component)obj).operation();</span><br><span class="line">    &#125; </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="分析-9"><a href="#分析-9" class="headerlink" title="分析"></a>分析</h3><ul>
<li>定义了一个抽象构件类，既可以代表叶子，又可以代表容器，客户端是针对这个接口进行编程的，不需要知道他是叶子还是容器</li>
<li>容器对象和抽象构件类之间还建立了一个<strong>聚合</strong>关联关系(看那个空菱形的线)，在容器对象中包含多个抽象构件，即既可以包含叶子，又可以包含容器</li>
</ul>
<img src="https://cynyard-blog-pics.oss-cn-beijing.aliyuncs.com/image/1617243279507-fc9fd36d-4b3d-4e1e-b71b-18b9719d247e.png" alt="image.png" style="zoom:50%;" />

<h3 id="优点-10"><a href="#优点-10" class="headerlink" title="优点"></a>优点</h3><ul>
<li>层次清楚，调用简单，树形结构</li>
</ul>
<h3 id="缺点-11"><a href="#缺点-11" class="headerlink" title="缺点"></a>缺点</h3><ul>
<li>设计抽象，并不是所有的方法都是与叶子对象类有关系的</li>
</ul>
<h3 id="拓展-3"><a href="#拓展-3" class="headerlink" title="拓展"></a>拓展</h3><h4 id="透明组合模式"><a href="#透明组合模式" class="headerlink" title="透明组合模式"></a>透明组合模式</h4><img src="https://cynyard-blog-pics.oss-cn-beijing.aliyuncs.com/image/image-20210627144139642.png" alt="image-20210627144139642" style="zoom:50%;" />

<h4 id="安全组合模式"><a href="#安全组合模式" class="headerlink" title="安全组合模式"></a>安全组合模式</h4><img src="https://cynyard-blog-pics.oss-cn-beijing.aliyuncs.com/image/image-20210627144212589.png" alt="image-20210627144212589" style="zoom: 50%;" />

<h2 id="桥接模式"><a href="#桥接模式" class="headerlink" title="桥接模式"></a>桥接模式</h2><h3 id="模式动机-3"><a href="#模式动机-3" class="headerlink" title="模式动机"></a>模式动机</h3><blockquote>
<p>设想如果要绘制矩形、圆形、椭圆、正方形，我们至 少需要4个形状类，但是如果绘制的图形需要具有不 同的颜色，如红色、绿色、蓝色等</p>
</blockquote>
<img src="https://cynyard-blog-pics.oss-cn-beijing.aliyuncs.com/image/1617243662269-defb747c-5fc8-492d-9a3f-7524fd30eae5.png" alt="image.png" style="zoom:50%;" />

<ul>
<li>方案一：每个形状都提供一套各种颜色的版本（违反了单一职责）</li>
<li>方案二：根据实际情况对形状和颜色进行组合，将继承关系转换为关联关系，组合优于继承，从而降低了类与类之间的耦合，减少了代码编写量</li>
<li>对于有两个变化纬度的系统</li>
</ul>
<h3 id="模式结构-3"><a href="#模式结构-3" class="headerlink" title="模式结构"></a>模式结构</h3><img src="https://cynyard-blog-pics.oss-cn-beijing.aliyuncs.com/image/1617244548015-47e3a394-5f7c-4d28-865b-f2737e62ce83.png" alt="image.png" style="zoom:50%;" />

<ul>
<li>Abstraction 抽象类</li>
<li>RefinedAbstraction 扩充抽象类，可以有多个</li>
<li>Implementor 实现类接口</li>
<li>ConcreteImplementor 具体实现类，可以有多个</li>
</ul>
<h3 id="分析-10"><a href="#分析-10" class="headerlink" title="分析"></a>分析</h3><ul>
<li>实现上是一样，思想不一样，与策略模式的区别就在于桥接模式的目的就在于创建类型，减少类，但是能有同样多的类型使用，每一种类型都要出现</li>
</ul>
<h3 id="实例-8"><a href="#实例-8" class="headerlink" title="实例"></a>实例</h3><p>一个维度是继承</p>
<p>另一个维度是聚合+接口</p>
<img src="https://cynyard-blog-pics.oss-cn-beijing.aliyuncs.com/image/1617244758589-eea9589d-1155-4f8f-b3e4-846748fc2651.png" alt="image.png" style="zoom:50%;" />

<img src="https://cynyard-blog-pics.oss-cn-beijing.aliyuncs.com/image/1617244939184-1e433152-89cf-49af-966b-c51b8f610582.png" alt="image.png" style="zoom:50%;" />

<h3 id="优点-11"><a href="#优点-11" class="headerlink" title="优点"></a>优点</h3><ul>
<li>符合开闭原则</li>
<li>可扩展性，在已有维度中任意拓展都不需要修改原有系统</li>
<li>可以向用户隐藏实现细节</li>
</ul>
<h3 id="缺点-12"><a href="#缺点-12" class="headerlink" title="缺点"></a>缺点</h3><ul>
<li>理解与设计难度，需要针对抽象进行设计</li>
<li>设计的时候需要识别出两个独立变化的维度</li>
</ul>
<h3 id="模式应用"><a href="#模式应用" class="headerlink" title="模式应用"></a>模式应用</h3><h4 id="Java虚拟机"><a href="#Java虚拟机" class="headerlink" title="Java虚拟机"></a>Java虚拟机</h4><p><img src="https://cynyard-blog-pics.oss-cn-beijing.aliyuncs.com/image/image-20210627145105201.png" alt="image-20210627145105201"></p>
<h4 id="AWT-GUI"><a href="#AWT-GUI" class="headerlink" title="AWT GUI"></a>AWT GUI</h4><p>GUI构件在获得操作系统的类型过后，自动配置对应的display</p>
<h4 id="JDBC-1"><a href="#JDBC-1" class="headerlink" title="JDBC"></a>JDBC</h4><p>JDBC驱动程序可以动态的将一个特定类型的数据库与一个Java应用程序绑定在一起；</p>
<p>使用JDBC的应用系统就是抽象角色，使用的数据库就是实现角色（不同的数据库，而不同的数据库使用相同JDBC作为适配器）</p>
<h3 id="模式拓展-2"><a href="#模式拓展-2" class="headerlink" title="模式拓展"></a>模式拓展</h3><h4 id="与适配器模式的联动"><a href="#与适配器模式的联动" class="headerlink" title="与适配器模式的联动"></a>与适配器模式的联动</h4><ul>
<li>桥接模式用于系统的初步设计，独立存在的两个纬度的类，可以将其分别抽象化和实现化两个角色，可以分别进行变化</li>
<li>但是在设计完成后，系统与已有类无法协同工作，就可以采用适配器模式，特别是那些涉及到大量第三方应用接口的情况</li>
</ul>
<img src="https://cynyard-blog-pics.oss-cn-beijing.aliyuncs.com/image/1617245250548-a0f2f140-2f23-473b-9393-c0fa93f16699.png" alt="image.png" style="zoom:50%;" />

<h2 id="装饰模式"><a href="#装饰模式" class="headerlink" title="装饰模式"></a>装饰模式</h2><h3 id="模式动机-4"><a href="#模式动机-4" class="headerlink" title="模式动机"></a>模式动机</h3><ul>
<li>一般有两个方式给一个类或者对象，添加行为</li>
<li>继承机制：子类拓展和使用父类的方法</li>
<li>关联机制：将一个类的对象嵌入到另一个对象中，由另一个对象来决定是否调用嵌入对象的行为</li>
<li>用不用装饰者取决于添加行为的方式是不是不确定的</li>
<li>装饰者以<strong>对客户透明</strong>的方式，动态地给对象附加上更多的责任，客户端<strong>并不知道对象在装饰前和装饰后有什么不同</strong>。装饰者模式可以在<strong>不需要创建更多子类的情况下</strong>，将对象的功能拓展。</li>
</ul>
<h3 id="定义-12"><a href="#定义-12" class="headerlink" title="定义"></a>定义</h3><ul>
<li>动态地给一个对象添加一些额外的职责</li>
<li>与适配器的别名相同，但是适用于不同的场合</li>
</ul>
<h3 id="结构-7"><a href="#结构-7" class="headerlink" title="结构"></a>结构</h3><img src="https://cynyard-blog-pics.oss-cn-beijing.aliyuncs.com/image/1617246852299-24db7749-3573-4484-8ca0-d56c104c376d.png" alt="image.png" style="zoom:50%;" />

<ul>
<li>抽象构件：聚合到抽象装饰类</li>
<li>具体构件：不能去掉，否则右边成了递归，没有对于抽象构件的引用</li>
<li>抽象装饰类：继承了抽象构件¥</li>
<li>具体装饰类：增加职责可以通过增加状态，也可以通过增加行为，不能破坏里氏代换原则，那个addBehavior应该是-</li>
</ul>
<h3 id="分析-11"><a href="#分析-11" class="headerlink" title="分析"></a>分析</h3><img src="https://cynyard-blog-pics.oss-cn-beijing.aliyuncs.com/image/1617247478705-313bc48d-de3e-4cf7-814f-ff2e0775fef9.png" alt="image.png" style="zoom:50%;" />

<img src="https://cynyard-blog-pics.oss-cn-beijing.aliyuncs.com/image/1617247486500-656cb740-b999-4e79-a927-277bbed98509.png" alt="image.png" style="zoom:50%;" />

<p>在操作了父类（Component）的operation过后，再执行新增的方法</p>
<h3 id="实例-9"><a href="#实例-9" class="headerlink" title="实例"></a>实例</h3><h4 id="变形金刚"><a href="#变形金刚" class="headerlink" title="变形金刚"></a>变形金刚</h4><p>让车能够变身为机器人或者飞机，以进行说话和飞行</p>
<img src="https://cynyard-blog-pics.oss-cn-beijing.aliyuncs.com/image/1617247730511-1eb7148b-1795-43fb-bbcf-1afba9d7b236.png" alt="image.png" style="zoom:50%;" />

<h4 id="多重加密系统"><a href="#多重加密系统" class="headerlink" title="多重加密系统"></a>多重加密系统</h4><p>给SimpleCipher添加多种行为，添加不同的行为</p>
<img src="https://cynyard-blog-pics.oss-cn-beijing.aliyuncs.com/image/1617247893912-41f6587b-939b-4b91-bccf-e0624e8c1cba.png" alt="image.png" style="zoom:50%;" />

<h3 id="优点-12"><a href="#优点-12" class="headerlink" title="优点"></a>优点</h3><ul>
<li>动态拓展行为，可以选择不同的装饰器，不同的行为</li>
<li>装饰类的不同的排列组合可以得到不同功能的对象</li>
<li>符合开闭原则，根据需要添加新的构件类和装饰类</li>
</ul>
<h3 id="缺点-13"><a href="#缺点-13" class="headerlink" title="缺点"></a>缺点</h3><ul>
<li>不受控制，比继承更加灵活的特性让装饰模式比继承更加容易出错，经过多次装饰的对象，排错也很困难</li>
<li>产生很多小对象，产生很多具体装饰类</li>
</ul>
<h3 id="应用-2"><a href="#应用-2" class="headerlink" title="应用"></a>应用</h3><h4 id="JavaIO"><a href="#JavaIO" class="headerlink" title="JavaIO"></a>JavaIO</h4><img src="https://cynyard-blog-pics.oss-cn-beijing.aliyuncs.com/image/1617248865002-df62a600-b19f-4a26-8477-ed4c34e588f6.png" alt="image.png" style="zoom:50%;" />

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileInputStream</span> <span class="keyword">extends</span> <span class="title">InputStream</span></span>&#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="title">FileInputStream</span><span class="params">(String path)</span></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FilterInputStream</span> <span class="keyword">extends</span> <span class="title">InputStream</span></span>&#123;</span><br><span class="line">  <span class="keyword">protected</span> <span class="keyword">volatile</span> InputStream in;</span><br><span class="line">	<span class="function"><span class="keyword">protected</span> <span class="title">FilterInputStream</span><span class="params">(InputStream in)</span> </span>&#123; </span><br><span class="line">    <span class="keyword">this</span>.in = in;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="title">read</span><span class="params">(<span class="keyword">byte</span>[] data)</span></span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BufferedInputStream</span> <span class="keyword">extends</span> <span class="title">FilterInputStream</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="title">BufferedInputStream</span><span class="params">(InputSream in)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(in);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="title">read</span><span class="params">(<span class="keyword">byte</span>[] data)</span></span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.read(data);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">....</span><br><span class="line">FileInputStream inFS = <span class="keyword">new</span> FileInputStream(<span class="string">&quot;temp/fileSrc.txt&quot;</span>); </span><br><span class="line">BufferedInputStream inBS = <span class="keyword">new</span> BufferedInputStream(inFS); <span class="comment">//定义一个字节数组，用于存放缓冲数据</span></span><br><span class="line"><span class="keyword">byte</span>[] data = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">inBS.read(data);</span><br><span class="line">  </span><br></pre></td></tr></table></figure>
<h3 id="拓展-4"><a href="#拓展-4" class="headerlink" title="拓展"></a>拓展</h3><h4 id="简化"><a href="#简化" class="headerlink" title="简化"></a>简化</h4><img src="https://cynyard-blog-pics.oss-cn-beijing.aliyuncs.com/image/image-20210627153308009.png" alt="image-20210627153308009" style="zoom:50%;" />

<h4 id="透明装饰"><a href="#透明装饰" class="headerlink" title="透明装饰"></a>透明装饰</h4><ul>
<li>面向抽象编程，不能声明具体构件类型和具体装饰类型，应该全部声明为抽象构件类型</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Cipher sc,cc,ac;</span><br><span class="line">sc=<span class="keyword">new</span> SimpleCipher(); </span><br><span class="line">cc=<span class="keyword">new</span> ComplexCipher(sc); </span><br><span class="line">ac=<span class="keyword">new</span> AdvancedCipher(cc);</span><br></pre></td></tr></table></figure>
<h4 id="半透明"><a href="#半透明" class="headerlink" title="半透明"></a>半透明</h4><ul>
<li>允许声明具体装饰者类型的对象</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Transform camaro;</span><br><span class="line">camaro=<span class="keyword">new</span> Car();</span><br><span class="line">camaro.move();</span><br><span class="line">Robot bumblebee=<span class="keyword">new</span> Robot(camaro); bumblebee.move();</span><br><span class="line">bumblebee.say();</span><br></pre></td></tr></table></figure>
<h2 id="外观模式"><a href="#外观模式" class="headerlink" title="外观模式"></a>外观模式</h2><h3 id="动机-10"><a href="#动机-10" class="headerlink" title="动机"></a>动机</h3><p>引入外观角色过后，用户只需要与外观角色交互，用户与子系统之间的复杂关系由外观角色来实现，从而降低了系统的耦合度</p>
<img src="https://cynyard-blog-pics.oss-cn-beijing.aliyuncs.com/image/1617676986683-685402f8-e460-46a3-93e0-239094a2ceb1.png" alt="image.png" style="zoom:50%;" />

<h3 id="定义-13"><a href="#定义-13" class="headerlink" title="定义"></a>定义</h3><ul>
<li>外部与子系统之间的通信必须通过一个统一的接口</li>
<li>使得子系统更加容易使用</li>
<li>门面模式，一种对象结构型模式</li>
</ul>
<h3 id="结构-8"><a href="#结构-8" class="headerlink" title="结构"></a>结构</h3><img src="https://cynyard-blog-pics.oss-cn-beijing.aliyuncs.com/image/1617677139824-3bd5ae19-e3c4-4c9f-8480-310b01a72ede.png" alt="image.png" style="zoom:50%;" />

<ul>
<li>facade：外观角色</li>
<li>subsystem：子系统角色</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Facade</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> SubSystemA obj1 = <span class="keyword">new</span> SubSystemA(); </span><br><span class="line">  <span class="keyword">private</span> SubSystemB obj2 = <span class="keyword">new</span> SubSystemB(); 	</span><br><span class="line">  <span class="keyword">private</span> SubSystemC obj3 = <span class="keyword">new</span> SubSystemC(); </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		obj1.method(); </span><br><span class="line">    obj2.method(); </span><br><span class="line">    obj3.method();</span><br><span class="line">	&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="分析-12"><a href="#分析-12" class="headerlink" title="分析"></a>分析</h3><ul>
<li>单一职责原则的体现，一个系统被划分为若干个子系统，有利于降低整个系统的复杂性</li>
<li>达到这个目标的途径之一，就是引入一个外观对象，为子系统的访问提供了一个简单并且单一的入口</li>
<li>迪米特法则的体现，降低系统复杂度以及降低客户类与子系统类的耦合度</li>
</ul>
<h3 id="实例-10"><a href="#实例-10" class="headerlink" title="实例"></a>实例</h3><h4 id="电源开关"><a href="#电源开关" class="headerlink" title="电源开关"></a>电源开关</h4><img src="https://cynyard-blog-pics.oss-cn-beijing.aliyuncs.com/image/1617677454600-8225ee33-b1dd-4070-aca1-cd94619dc370.png" alt="image.png" style="zoom:50%;" />

<h4 id="文件加密"><a href="#文件加密" class="headerlink" title="文件加密"></a>文件加密</h4><p>先用reader读，在用cipher加密，在用writer卸乳</p>
<img src="https://cynyard-blog-pics.oss-cn-beijing.aliyuncs.com/image/1617677483802-fd0bb04b-1446-4004-9fa7-76fd4ecc2401.png" alt="image.png" style="zoom: 50%;" />

<h3 id="优点-13"><a href="#优点-13" class="headerlink" title="优点"></a>优点</h3><ul>
<li>减少客户处理的对象数目，客户代码简单</li>
<li>子系统的组件变化不会影响客户</li>
<li>子系统的修改对其他子系统没有影响，内部变化也不会影响外观对象</li>
</ul>
<h3 id="缺点-14"><a href="#缺点-14" class="headerlink" title="缺点"></a>缺点</h3><ul>
<li>增加新的子系统可能会违背开闭原则</li>
</ul>
<h3 id="应用-3"><a href="#应用-3" class="headerlink" title="应用"></a>应用</h3><h4 id="JDBC数据库操作"><a href="#JDBC数据库操作" class="headerlink" title="JDBC数据库操作"></a>JDBC数据库操作</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JDBCFacade</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> Connection conn=<span class="keyword">null</span>;</span><br><span class="line">	<span class="keyword">private</span> Statement statement=<span class="keyword">null</span>;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">open</span><span class="params">(String driver,String jdbcUrl,String userName,String userPwd)</span> </span>&#123;</span><br><span class="line">  		......</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">executeUpdate</span><span class="params">(String sql)</span> </span>&#123;</span><br><span class="line">  ......</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> ResultSet <span class="title">executeQuery</span><span class="params">(String sql)</span> </span>&#123;</span><br><span class="line">  	......</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  	......</span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Session外观模式"><a href="#Session外观模式" class="headerlink" title="Session外观模式"></a>Session外观模式</h4><img src="https://cynyard-blog-pics.oss-cn-beijing.aliyuncs.com/image/image-20210628144529050.png" alt="image-20210628144529050" style="zoom:50%;" />

<h3 id="拓展-5"><a href="#拓展-5" class="headerlink" title="拓展"></a>拓展</h3><h4 id="单例模式-多个不同的外观类"><a href="#单例模式-多个不同的外观类" class="headerlink" title="单例模式+多个不同的外观类"></a>单例模式+多个不同的外观类</h4><p>一个外观类一个实例，但是可以涉及多个外观类，每个外观类负责和一些特定的子系统交互</p>
<h4 id="不要用外观类添加新行为"><a href="#不要用外观类添加新行为" class="headerlink" title="不要用外观类添加新行为"></a>不要用外观类添加新行为</h4><p>新的行为通过修改原有子系统类或者增加新的子系统类来实现</p>
<h4 id="迪米特法则"><a href="#迪米特法则" class="headerlink" title="迪米特法则"></a>迪米特法则</h4><p>代码重构达到了迪米特法则的要求，使得客户端与子系统内部的对象的相互作用被外观对象所取代</p>
<h4 id="抽象外观类"><a href="#抽象外观类" class="headerlink" title="抽象外观类"></a>抽象外观类</h4><ul>
<li>客户端针对抽象外观类进行编程，新的业务需求增加新的外观类，修改配置文件来更换外观类</li>
</ul>
<img src="https://cynyard-blog-pics.oss-cn-beijing.aliyuncs.com/image/image-20210627155232694.png" alt="image-20210627155232694" style="zoom:50%;" />

<h2 id="享元模式"><a href="#享元模式" class="headerlink" title="享元模式"></a>享元模式</h2><h3 id="模式动机-5"><a href="#模式动机-5" class="headerlink" title="模式动机"></a>模式动机</h3><ul>
<li>对象太多的时候，运行代价过高，带来性能下降的问题</li>
<li>享元模式通过共享技术实现相同或相似对象的重用</li>
<li>共享的相同内容称为<strong>内部状态</strong>；</li>
<li>需要外部环境来设置的，不能共享的内容称为<strong>外部状态</strong>，因此可以通过设置不同的外部状态使得相同的对象可以拥有一些不同的特征</li>
<li>通常会出现工厂模式，需要创建一个享元工厂来负责为一个享元池</li>
<li>能够共享的内部状态是有限的，所包含的内部状态较少，称为细粒度对象，享元模式的目的就是使用共享技术来实现大量细粒度对象的复用</li>
</ul>
<h3 id="模式定义"><a href="#模式定义" class="headerlink" title="模式定义"></a>模式定义</h3><ul>
<li>使用共享技术，有效的支持大量细粒度对象的复用，系统只使用少量的对象，实现对象的多次复用</li>
<li>轻量级模式</li>
<li>对象结构形模式</li>
</ul>
<h3 id="模式结构-4"><a href="#模式结构-4" class="headerlink" title="模式结构"></a>模式结构</h3><img src="https://cynyard-blog-pics.oss-cn-beijing.aliyuncs.com/image/image-20210627155452566.png" alt="image-20210627155452566" style="zoom:50%;" />

<ul>
<li>抽象享元类</li>
<li>具体享元类：内部状态作为成员属性，可以共享，可以有多个对象</li>
<li>非共享具体享元类：不可以共享</li>
<li>享元工厂类：提供一个存储享元对象的池，需要享元对象的时候就从里面获取，如果没有池就创建新的对象给用户，并保存这个对象</li>
</ul>
<h3 id="模式分析"><a href="#模式分析" class="headerlink" title="模式分析"></a>模式分析</h3><ul>
<li>共享的关键是区分内部状态和外部状态</li>
<li>内部状态可以共享，不会改变</li>
<li>外部状态可以随环境改变，不可以共享</li>
</ul>
<h3 id="实例-11"><a href="#实例-11" class="headerlink" title="实例"></a>实例</h3><h4 id="网络设备"><a href="#网络设备" class="headerlink" title="网络设备"></a>网络设备</h4><img src="https://cynyard-blog-pics.oss-cn-beijing.aliyuncs.com/image/image-20210627161033660.png" alt="image-20210627161033660" style="zoom:50%;" />

<h4 id="共享网络设备"><a href="#共享网络设备" class="headerlink" title="共享网络设备"></a>共享网络设备</h4><p>多台计算机共享一个网络设备，但必须使用不同的端口</p>
<img src="https://cynyard-blog-pics.oss-cn-beijing.aliyuncs.com/image/image-20210627161122942.png" alt="image-20210627161122942" style="zoom:50%;" />

<h3 id="优点-14"><a href="#优点-14" class="headerlink" title="优点"></a>优点</h3><ul>
<li>极大减少内存中对象的数量</li>
<li>享元对象可以在不同的环境中被共享</li>
</ul>
<h3 id="缺点-15"><a href="#缺点-15" class="headerlink" title="缺点"></a>缺点</h3><ul>
<li>需要分离出内部状态和外部状态</li>
<li>读取外部状态运行时间更长</li>
</ul>
<h3 id="适用"><a href="#适用" class="headerlink" title="适用"></a>适用</h3><ul>
<li>大量相同或者相似的对象，大部分状态都可以外部化</li>
<li>多次重复使用享元对象</li>
</ul>
<h3 id="模式拓展-3"><a href="#模式拓展-3" class="headerlink" title="模式拓展"></a>模式拓展</h3><h4 id="单纯享元模式"><a href="#单纯享元模式" class="headerlink" title="单纯享元模式"></a>单纯享元模式</h4><p>所有享元对象都是可以共享的，不存在非共享具体享元类，参考上面的网络设备</p>
<h4 id="复合享元模式"><a href="#复合享元模式" class="headerlink" title="复合享元模式"></a>复合享元模式</h4><p>单纯享元使用组合模式形成复合享元</p>
<img src="https://cynyard-blog-pics.oss-cn-beijing.aliyuncs.com/image/image-20210627162825047.png" alt="image-20210627162825047" style="zoom:50%;" />

<h3 id="对比原型模式"><a href="#对比原型模式" class="headerlink" title="对比原型模式"></a>对比原型模式</h3><img src="https://cynyard-blog-pics.oss-cn-beijing.aliyuncs.com/image/image-20210624182118396.png" alt="image-20210624182118396" style="zoom:50%;" />

<h2 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h2><h3 id="动机-11"><a href="#动机-11" class="headerlink" title="动机"></a>动机</h3><ul>
<li>通过引入一个新的对象来实现对真实对象的操作，或者将这个新的对象作为真实对象的替身，来间接访问真实对象</li>
<li>客户不能使用真正的对象，外观模式是可以访问真正的对象的</li>
</ul>
<h3 id="定义-14"><a href="#定义-14" class="headerlink" title="定义"></a>定义</h3><ul>
<li>给某一个对象提供一个代理Proxy，并由代理对象控制对原对象的引用</li>
</ul>
<h3 id="结构-9"><a href="#结构-9" class="headerlink" title="结构"></a>结构</h3><img src="https://cynyard-blog-pics.oss-cn-beijing.aliyuncs.com/image/1617680342813-26bfc5dc-9fd8-4e70-a372-184acf21415d.png" alt="image.png" style="zoom:50%;" />

<ul>
<li>Subject 抽象主题角色</li>
<li>Proxy 代理主题角色，也是Subject，包含了对真正对象的应用</li>
<li>RealSubject</li>
</ul>
<h3 id="实例-12"><a href="#实例-12" class="headerlink" title="实例"></a>实例</h3><h4 id="论坛权限控制"><a href="#论坛权限控制" class="headerlink" title="论坛权限控制"></a>论坛权限控制</h4><p><img src="https://cynyard-blog-pics.oss-cn-beijing.aliyuncs.com/image/image-20210627163100286.png" alt="image-20210627163100286"></p>
<h4 id="数学运算"><a href="#数学运算" class="headerlink" title="数学运算"></a>数学运算</h4><img src="https://cynyard-blog-pics.oss-cn-beijing.aliyuncs.com/image/image-20210627163315521.png" alt="image-20210627163315521" style="zoom:50%;" />

<h3 id="优点-15"><a href="#优点-15" class="headerlink" title="优点"></a>优点</h3><ul>
<li>协调调用者和被调用者，降低系统耦合度</li>
<li>远程代理远程访问</li>
<li>虚拟代理减少消耗</li>
<li>保护代理控制权限</li>
</ul>
<h3 id="缺点-16"><a href="#缺点-16" class="headerlink" title="缺点"></a>缺点</h3><ul>
<li>处理速度变慢</li>
<li>额外的工作</li>
</ul>
<h3 id="适用-1"><a href="#适用-1" class="headerlink" title="适用"></a>适用</h3><ul>
<li>远程代理</li>
<li>虚拟代理，内存节省技术，例如对大图浏览的控制，多线程，先小图</li>
<li>Copy-on-Write代理，延迟操作</li>
</ul>

        </div>

        
            <section class="post-copyright">
                
                    <p class="copyright-item">
                        <span>Author:</span>
                        <span>Cynyard Qiu</span>
                    </p>
                
                
                
                

            </section>
        
        <section class="post-tags">
            <div>
                <span>Tag(s):</span>
                <span class="tag">
                    
                    
                        <a href="/tags/design/"># design</a>
                    
                        <a href="/tags/object-oriented/"># object-oriented</a>
                    
                        <a href="/tags/code/"># code</a>
                    
                        
                </span>
            </div>
            <div>
                <a href="javascript:window.history.back();">back</a>
                <span>· </span>
                <a href="/">home</a>
            </div>
        </section>
        <section class="post-nav">
            
                <a class="prev" rel="prev" href="/2021/06/29/object-oriented-design-principles/">面向对象设计原则</a>
            
            
            <a class="next" rel="next" href="/2021/03/01/Synchronized/">Synchronized的各种问题</a>
            
        </section>


    </article>
</div>

        </div>
        <footer id="footer" class="footer">
    <div class="copyright">
        <span>© Cynyard Qiu | Powered by <a href="https://hexo.io" target="_blank">Hexo</a> & <a href="https://github.com/Siricee/hexo-theme-Chic" target="_blank">Chic</a> 
        
        </span>
    </div>
</footer>

    </div>
</body>
</html>

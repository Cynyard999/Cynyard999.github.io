<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
<meta name="viewport"
      content="width=device-width, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
<meta http-equiv="X-UA-Compatible" content="ie=edge">

    <meta name="author" content="Cynyard Qiu">





<title>Linux系统基础 | Cynyard&#39;s Blog</title>



    <link rel="icon" href="/cloud.ico">




    <!-- stylesheets list from _config.yml -->
    
    <link rel="stylesheet" href="/css/style.css">
    



    <!-- scripts list from _config.yml -->
    
    <script src="/js/script.js"></script>
    
    <script src="/js/tocbot.min.js"></script>
    



    
    
        
    


<meta name="generator" content="Hexo 5.3.0"></head>
<body>
    <div class="wrapper">
        <header>
    <nav class="navbar">
        <div class="container">
            <div class="navbar-header header-logo"><a href="/">Cynyard&#39;s Blog</a></div>
            <div class="menu navbar-right">
                
                    <a class="menu-item" href="/archives">Posts</a>
                
                    <a class="menu-item" href="/category">Categories</a>
                
                    <a class="menu-item" href="/tag">Tags</a>
                
                    <a class="menu-item" href="/about">About</a>
                
                <input id="switch_default" type="checkbox" class="switch_default">
                <label for="switch_default" class="toggleBtn"></label>
            </div>
        </div>
    </nav>

    
    <nav class="navbar-mobile" id="nav-mobile">
        <div class="container">
            <div class="navbar-header">
                <div>
                    <a href="/">Cynyard&#39;s Blog</a><a id="mobile-toggle-theme">·&nbsp;Light</a>
                </div>
                <div class="menu-toggle" onclick="mobileBtn()">&#9776; Menu</div>
            </div>
            <div class="menu" id="mobile-menu">
                
                    <a class="menu-item" href="/archives">Posts</a>
                
                    <a class="menu-item" href="/category">Categories</a>
                
                    <a class="menu-item" href="/tag">Tags</a>
                
                    <a class="menu-item" href="/about">About</a>
                
            </div>
        </div>
    </nav>

</header>
<script>
    var mobileBtn = function f() {
        var toggleMenu = document.getElementsByClassName("menu-toggle")[0];
        var mobileMenu = document.getElementById("mobile-menu");
        if(toggleMenu.classList.contains("active")){
           toggleMenu.classList.remove("active")
            mobileMenu.classList.remove("active")
        }else{
            toggleMenu.classList.add("active")
            mobileMenu.classList.add("active")
        }
    }
</script>
        <div class="main">
            <div class="container">
    
    
        <div class="post-toc">
    <div class="tocbot-list">
    </div>
    <div class="tocbot-list-menu">
        <a class="tocbot-toc-expand" onclick="expand_toc()">Expand all</a>
        <a onclick="go_top()">Back to top</a>
        <a onclick="go_bottom()">Go to bottom</a>
    </div>
</div>

<script>
    document.ready(
        function () {
            tocbot.init({
                tocSelector: '.tocbot-list',
                contentSelector: '.post-content',
                headingSelector: 'h1, h2, h3, h4, h5',
                collapseDepth: 1,
                orderedList: false,
                scrollSmooth: true,
            })
        }
    )

    function expand_toc() {
        var b = document.querySelector(".tocbot-toc-expand");
        tocbot.init({
            tocSelector: '.tocbot-list',
            contentSelector: '.post-content',
            headingSelector: 'h1, h2, h3, h4, h5',
            collapseDepth: 6,
            orderedList: false,
            scrollSmooth: true,
        });
        b.setAttribute("onclick", "collapse_toc()");
        b.innerHTML = "Collapse all"
    }

    function collapse_toc() {
        var b = document.querySelector(".tocbot-toc-expand");
        tocbot.init({
            tocSelector: '.tocbot-list',
            contentSelector: '.post-content',
            headingSelector: 'h1, h2, h3, h4, h5',
            collapseDepth: 1,
            orderedList: false,
            scrollSmooth: true,
        });
        b.setAttribute("onclick", "expand_toc()");
        b.innerHTML = "Expand all"
    }

    function go_top() {
        window.scrollTo(0, 0);
    }

    function go_bottom() {
        window.scrollTo(0, document.body.scrollHeight);
    }

</script>
    

    
    <article class="post-wrap">
        <header class="post-header">
            <h1 class="post-title">Linux系统基础</h1>
            
                <div class="post-meta">
                    
                        Author: <a itemprop="author" rel="author" href="/">Cynyard Qiu</a>
                    

                    
                        <span class="post-time">
                        Date: <a href="#">August 24, 2020&nbsp;&nbsp;0:14:00</a>
                        </span>
                    
                    
                        <span class="post-category">
                    Category:
                            
                                <a href="/categories/Course/">Course</a>
                            
                        </span>
                    
                    
                </div>
            
        </header>

        <div class="post-content">
            <h1 id="课程笔记"><a href="#课程笔记" class="headerlink" title="课程笔记"></a>课程笔记</h1><h2 id="Ch1-认识Linux系统"><a href="#Ch1-认识Linux系统" class="headerlink" title="Ch1 认识Linux系统"></a>Ch1 认识Linux系统</h2><h3 id="Linux用途："><a href="#Linux用途：" class="headerlink" title="Linux用途："></a>Linux用途：</h3><p>Linux服务器，嵌入式Linux系统，桌面应用，软件开发平台</p>
<h3 id="Linux特点："><a href="#Linux特点：" class="headerlink" title="Linux特点："></a>Linux特点：</h3><ol>
<li>开放性 </li>
<li>多用户 </li>
<li>多任务 </li>
<li>良好的用户界面 </li>
<li>设备独立性 </li>
<li>丰富的网络功能 </li>
<li>可靠的系统安全 </li>
<li>良好的可移植性</li>
</ol>
<h3 id="Linux组成："><a href="#Linux组成：" class="headerlink" title="Linux组成："></a>Linux组成：</h3><p>内核，Shell，文件系统，应用程序</p>
<ul>
<li>内核：存储，cpu，进程，文件，网络等等功能，与硬件打交道并为用户提供一个有限服务集的低级支撑软件</li>
<li>Shell：命令解释器，解释命令输送到内核</li>
<li>文件系统：文件存放的组织方法</li>
<li>应用程序：程序集</li>
</ul>
<h3 id="内核的版本，怎么命名的，什么是发行版，有哪些常见的发行版"><a href="#内核的版本，怎么命名的，什么是发行版，有哪些常见的发行版" class="headerlink" title="内核的版本，怎么命名的，什么是发行版，有哪些常见的发行版"></a>内核的版本，怎么命名的，什么是发行版，有哪些常见的发行版</h3><p>Linux的版本号分为两部分,即内核版本与发行版本。<br /></p>
<blockquote>
<p>内核版本号由3个数字组成:r.x.y。<br>r:目前发布的内核主版本。<br>x:偶数表示稳定版本;奇数表示开发版本。<br>y:错误修补的次数。</p>
</blockquote>
<blockquote>
<p>发行版本：一些组织和厂家,将Linux系统的内核、应用软件和文档包装起来,并提供一些系统安装界面、系统配置设定管理工具等就构成了 Linux发行版本 。<br>相对于Linux操作系统内核版本，各发布厂商发行版本的版本号各不相同，与Linux系统内核的版本号是相对独立的。</p>
</blockquote>
<p>主流发行版：Mandriva、Red Hat、SUSE、Debian、Ubuntu、CentOS、Arch、Gentoo、Oracle等。</p>
<h3 id="RHEL新特性"><a href="#RHEL新特性" class="headerlink" title="RHEL新特性"></a>RHEL新特性</h3><ol>
<li>基于内核的虚拟化大量改进</li>
<li>LVM缓存，将xfs作为默认的文件系统</li>
<li>引入Linux容器Docker</li>
<li>编译工具链方面，RHEL 7包含GCC 4.8.x、glibc 2.17、GDB 7.6.1。</li>
<li>包含Ruby 2.0.0、Python 2.7.5、Java 7等编程语言。</li>
<li>在系统和服务方面，RHEL 7使用systemd替换了SysV</li>
</ol>
<h2 id="Ch2-安装Linux系统"><a href="#Ch2-安装Linux系统" class="headerlink" title="Ch2 安装Linux系统"></a><strong>Ch2 安装Linux系统</strong></h2><h3 id="硬件要求"><a href="#硬件要求" class="headerlink" title="硬件要求"></a>硬件要求</h3><ol>
<li>CPU：</li>
<li>内存</li>
<li>磁盘空间</li>
<li>显示器和显卡</li>
<li>DVD光驱</li>
</ol>
<h3 id="分区命名方案"><a href="#分区命名方案" class="headerlink" title="分区命名方案"></a>分区命名方案</h3><p>Linux系统使用字母和数字的组合来指代硬盘分区</p>
<p>Linux系统使用一种更加灵活的命名方案, 该命名方案是基于文件的,文件名的格式为 /dev/xxyN/dev:</p>
<p>这是Linux系统下所有设备文件所在的目录名。 因为分区处在磁盘上，磁盘是设备，这些文件也代表了所有可能的分区</p>
<p>xx:分区名的前两个字母表示分区所在设备的类型,通常是hd(IDE硬盘)或sd(SCSI硬盘)。</p>
<p>y:这个字母表示分区所在的设备号。</p>
<p>N:最后的数字N代表分区。</p>
<ul>
<li>/dev/hda3是第1个IDE 硬盘上的第3个主分区或扩展分区;</li>
<li>/dev/sdb6是第2个SCSI硬盘上的第2个逻辑驱动器。</li>
</ul>
<h3 id="分区方案"><a href="#分区方案" class="headerlink" title="分区方案"></a>分区方案</h3><h4 id="最简单的分区方案（至少需要的分区）"><a href="#最简单的分区方案（至少需要的分区）" class="headerlink" title="最简单的分区方案（至少需要的分区）"></a>最简单的分区方案（至少需要的分区）</h4><p><strong>SWAP分区</strong>:即交换分区,建议大小是物理内存的1~2倍。当然你内存足够大的时候，就不需要这么做了。</p>
<p>/分区</p>
<p>/boot分区<strong>：存放与Linux启动相关程序，最少200MB</strong></p>
<p><strong>使用以上的分区方案,所有的数据都放在</strong>/分区上,对于系统来说不安全,数据不容易备份</p>
<h4 id="合理的分区方案。6个，注意SWAP没有-且是大写"><a href="#合理的分区方案。6个，注意SWAP没有-且是大写" class="headerlink" title="合理的分区方案。6个，注意SWAP没有/且是大写"></a>合理的分区方案。6个，注意SWAP没有/且是大写</h4><p><code>/boot分区</code>:用来存放与Linux系统启动有关的程序,比如启动引导装载程序等,建议大小为100MB</p>
<p><code>/usr分区</code>:用来存放Linux系统中的应用程序,其相关数据较多,建议大于8GB。</p>
<p><code>/var分区</code>:用来存放Linux系统中经常变化的数据以及日志文件,建议大小为1GB。</p>
<p><code>/分区</code>:Linux系统的根目录,所有的目录都挂在这个目录下面,建议大小为1GB。</p>
<p><code>SWAP分区</code>:交换分区，实现虚拟内存,建议大小是物理内存的1~2倍。没有挂载点</p>
<p><code>/home分区</code>:存放普通用户的数据,是普通用户的宿主目录,建议大小为剩下的空间。</p>
<h3 id="防火墙"><a href="#防火墙" class="headerlink" title="防火墙"></a>防火墙</h3><p>FireWallID防火墙，通过将网络划分成不同的区域，制定出不同区域 之间的访问控制策略，以此来控制不同程度区域间传送的数据流，理解成火车站的安检，不同的入口见车的严格度不一样</p>
<p>默认情况下FirewallD防火墙的连 接区域为public，public在公共区域内使用，指定 外部连接可以进入内部网络或主机。</p>
<h2 id="Ch3-字符界面操作基础"><a href="#Ch3-字符界面操作基础" class="headerlink" title="Ch3 字符界面操作基础"></a>Ch3 字符界面操作基础</h2><h3 id="两种界面：图形化界面、字符界面"><a href="#两种界面：图形化界面、字符界面" class="headerlink" title="两种界面：图形化界面、字符界面"></a>两种界面：图形化界面、字符界面</h3><p><br />systemctl set-default multi-user.target//将字符洁面设置为启动计算机后要进入的默认目标，<br /></p>
<blockquote>
<p>graphical.target为图形化界面</p>
</blockquote>
<h3 id="关闭和重启Linux系统："><a href="#关闭和重启Linux系统：" class="headerlink" title="关闭和重启Linux系统："></a>关闭和重启Linux系统：</h3><p>如果需要以超级管理员（root）身份登录系统进行管理，在登录提示后输入用户名为“root”，按“回车”键后，在口令提示中输入安装时设置的根口令，然后按“回车”键即可。</p>
<p>shutdown<strong>：安全地关闭系统</strong> </p>
<p>shutdown [选项] [时间] [警告信息]</p>
<p>shutdown -h now 立即关闭系统</p>
<p>shutdown -h 45 定时45分钟后关闭系统</p>
<p>shutdown -r now “System will be reboot now.”重新启动系统,并发出警告信息</p>
<p>shutdown -r 01:38</p>
<p><strong>halt</strong>：引发主机关闭系统=调用 “shutdown -h”命令执行关闭系统</p>
<p>[root@PC-LINUX ~]# halt</p>
<p><strong>reboot</strong>：引发主机重启,参数与“halt”相似。</p>
<p>[root@PC-LINUX~]# reboot </p>
<h3 id="运行级别"><a href="#运行级别" class="headerlink" title="运行级别"></a>运行级别</h3><p><strong>要很清楚，3字符、5图形、0关机、6重启</strong></p>
<p>注意到CentOS7中已经改变了采用运行级别这样的做法，而是采用systemd和target的模式。但是事实上仍保留了一定的向前兼容性。</p>
<table>
<thead>
<tr>
<th>运行级别</th>
<th>对应目标</th>
<th>目标链接文件</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>poweroff.target</td>
<td>runlevel0.target</td>
<td>关闭系统</td>
</tr>
<tr>
<td>1</td>
<td>rescue.target</td>
<td>runlevel1.target</td>
<td>救援模式</td>
</tr>
<tr>
<td>2</td>
<td>multi-user.target</td>
<td>runlevel2.target</td>
<td>命令行多用户</td>
</tr>
<tr>
<td>3</td>
<td>multi-user.target</td>
<td>runlevel3.target</td>
<td>命令行多用户</td>
</tr>
<tr>
<td>4</td>
<td>multi-user.target</td>
<td>runlevel4.target</td>
<td>命令行多用户</td>
</tr>
<tr>
<td>5</td>
<td>graphical.target</td>
<td>runlevel5.target</td>
<td>图形界面多用户</td>
</tr>
<tr>
<td>6</td>
<td>reboot.target</td>
<td>runlevel6.target</td>
<td>重启</td>
</tr>
</tbody></table>
<p>shutdown –h now和init 0用于关机+halt</p>
<p>shutdown –r now和init 6用户重启+reboot</p>
<p>系统日志保存在哪个目录下</p>
<p>一般保存在/var/log目录下</p>
<p>终端的命名tty pty pts</p>
<p><strong>进入命令行的方式</strong></p>
<p>字符界面、图形界面下的终端以及虚拟控制台（远程）</p>
<p><strong>虚拟控制台的切换</strong></p>
<p><img src="https://cdn.nlark.com/yuque/0/2020/png/1096029/1599992418130-8cfedc15-0799-4808-9475-3933c74073d2.png" alt="image.png"><img src="https://cynyard-blog-pics.oss-cn-beijing.aliyuncs.com/image/1599992455235-f0a055ee-7ec2-4165-8ce2-69dc332c74df.png" alt="image.png"></p>
<h3 id="man帮助命令"><a href="#man帮助命令" class="headerlink" title="man帮助命令"></a><strong>man帮助命令</strong></h3><p>man是一种显示Unix/Linux在线手册的命令。可以用来查看命令、函数或文件的帮助手册,另外它还可以显示一些gzip压缩格式的文件。<br>man命令格式化并显示在线的手册页。<br>man ls<br>man mkdir</p>
<h3 id="help帮助命令"><a href="#help帮助命令" class="headerlink" title="help帮助命令"></a>help帮助命令</h3><p>help使用help命令可以查找Shell命令的用法</p>
<p>查看mkdir命令帮助：mkdir –help</p>
<h3 id="Shell"><a href="#Shell" class="headerlink" title="Shell"></a>Shell</h3><ol>
<li>与计算机交流，接受用户命令，然后调用相应的应用程序。作为命令语言可以交互的解释和执行用户输入的命令或者预先设定好的一连串的命令；作为程序设计语言，可以定义各种变量和参数，并且提供控制结构（循环和分支）</li>
<li>bash介绍</li>
<li>Shell操作<ol>
<li>命令行自动补全：tab键</li>
<li>命令替换 参数由另外一个命令的结果来替代<ul>
<li>kill -9 $(pidof less)</li>
</ul>
</li>
<li>一行上执行多个命令<ol>
<li>；先执行命令1，不管是否出错，执行命令2</li>
<li>&amp;&amp; 只有当命令1成功执行完毕过后才能执行命令2</li>
</ol>
</li>
<li>别名<ol>
<li>alias mk=mkdir</li>
<li>unalias mk</li>
</ol>
</li>
<li><img src="https://cynyard-blog-pics.oss-cn-beijing.aliyuncs.com/image/1598167208565-828d8c73-75ee-4dff-b38b-3b405267aead.png" alt="image.png"></li>
<li><img src="https://cynyard-blog-pics.oss-cn-beijing.aliyuncs.com/image/1598167295857-7ec82a25-b5d9-4144-80a1-d99540834118.png" alt="image.png"></li>
<li><img src="https://cynyard-blog-pics.oss-cn-beijing.aliyuncs.com/image/1598167349293-309d03e3-f656-4e1f-97a9-c36bfc1f810a.png" alt="image.png"></li>
<li><img src="https://cynyard-blog-pics.oss-cn-beijing.aliyuncs.com/image/1598167396880-3964bc2e-3bc7-49eb-8dda-5f31270e7a33.png" alt="image.png"></li>
</ol>
</li>
</ol>
<h3 id="管道"><a href="#管道" class="headerlink" title="管道"></a>管道</h3><p>管道可以通过组合许多小程序共同完成复杂的任务，可以将某个命令的输出信息当作某个命令的输入，由管道符号“|”来标识。</p>
<p>命令1｜命令2｜命令3｜..</p>
<p>rpm -qa|grep a|more //命令rpm -qa显示已经安装在系统上的RPM包，命令grep a是过滤软件 包，命令more是分页显示这些信息</p>
<h3 id="重定向"><a href="#重定向" class="headerlink" title="重定向"></a>重定向</h3><h4 id="输出重定向，将某一命令执行的输出保存到文件中，如果已经存在相同的文件，覆盖原文件的内容"><a href="#输出重定向，将某一命令执行的输出保存到文件中，如果已经存在相同的文件，覆盖原文件的内容" class="headerlink" title="输出重定向，将某一命令执行的输出保存到文件中，如果已经存在相同的文件，覆盖原文件的内容"></a>输出重定向，将某一命令执行的输出保存到文件中，如果已经存在相同的文件，覆盖原文件的内容</h4><p>ls/boot &gt;/root/abc</p>
<p>echo Hello &gt;/root/mm</p>
<h4 id="输出追加重定向"><a href="#输出追加重定向" class="headerlink" title="输出追加重定向"></a>输出追加重定向</h4><p>echo Hello &gt;&gt;/root/mm</p>
<h4 id="输入重定向"><a href="#输入重定向" class="headerlink" title="输入重定向"></a>输入重定向</h4><h4 id="输入追加重定向"><a href="#输入追加重定向" class="headerlink" title="输入追加重定向"></a>输入追加重定向</h4><h4 id="错误重定向"><a href="#错误重定向" class="headerlink" title="错误重定向"></a>错误重定向</h4><p>cat /root/kk 2&gt; /root/b</p>
<h4 id="错误追加重定向"><a href="#错误追加重定向" class="headerlink" title="错误追加重定向"></a>错误追加重定向</h4><p>cat /root/kk 2&gt;&gt; /root/b</p>
<h4 id="输出和错误重定向"><a href="#输出和错误重定向" class="headerlink" title="输出和错误重定向"></a>输出和错误重定向</h4><p>ls /boot &amp;&gt; /root/kk</p>
<h3 id="vi-（编辑的是ASCII文本）"><a href="#vi-（编辑的是ASCII文本）" class="headerlink" title="vi （编辑的是ASCII文本）"></a>vi （编辑的是ASCII文本）</h3><h4 id="三种模式，三种模式之间的转换及命令"><a href="#三种模式，三种模式之间的转换及命令" class="headerlink" title="三种模式，三种模式之间的转换及命令"></a><strong>三种模式，三种模式之间的转换及命令</strong></h4><ol>
<li>当在Shell提示符下输入“vim 文件名”之后就进入了命令行模式,在命令行模式下是不能输入任何数据的。</li>
<li>在命令行模式下输入文本插入命令就可以进入插入模式,这时候就可以开始输入文字了。</li>
<li>从插入模式切换为命令行模式只需按“Esc”键。</li>
<li>在命令行模式下,<strong>按转义命令冒号键“:”</strong>可以进入末行模式。</li>
</ol>
<p><img src="https://cynyard-blog-pics.oss-cn-beijing.aliyuncs.com/image/1598168627496-b8583c0d-2761-4bc0-ab7e-c37c7cf0b692.png" alt="image.png"><br><strong>命令行模式</strong>：<strong>控制屏幕光标的移动，字符、字或行的删除，移动、复制某区域</strong>及进入插入模式，或者到末行模式</p>
<ol>
<li><p>进入插入模式</p>
<p><img src="https://cynyard-blog-pics.oss-cn-beijing.aliyuncs.com/image/1598168849297-5dbad619-c8ba-4345-9248-d714104d23e5.png" alt="image.png"></p>
</li>
<li><p>光标移动，</p>
<ol>
<li>上下左右箭头，kjhl（快结婚了，nk，nj，</li>
<li>0使光标移动所在行的行首，gg文件首，G文件尾部</li>
</ol>
</li>
<li><p>命令模式</p>
<ol>
<li>x删除字符，X删除前面的字符，dd删除行，nx，nX，ndd</li>
<li>yw复制当前位置到单词尾部，nyw所在位置开始的n个单词，YY复制当前行，y$光标到行尾，y^光标到行首，p粘贴</li>
<li>r替换，R替换直到ESC，u撤销，/查找</li>
</ol>
</li>
</ol>
<p><strong>插入模式</strong>：编辑</p>
<p><strong>末行模式</strong>：保存退出</p>
<ol>
<li><p>:wq :w :wq! :q! :q</p>
</li>
<li><p>:d 删除当前行</p>
</li>
</ol>
<h2 id="Ch4-目录和文件管理"><a href="#Ch4-目录和文件管理" class="headerlink" title="Ch4 目录和文件管理"></a>Ch4 目录和文件管理</h2><blockquote>
<p>一切都是文件</p>
</blockquote>
<h3 id="ls-l详解"><a href="#ls-l详解" class="headerlink" title="ls -l详解"></a>ls -l详解</h3><ul>
<li>第一列：drwxr-xr-x，d代表目录，-代表普通文件。开始3个字符rwx代表该文件的属主的权限，中间3个字符r-x代表该文件属主所在用户组的其他用户的权限，最后r-x代表其他用户的权限。</li>
<li>第二列：若是文件则代表该文件的硬链接数。若是目录，则代表该目录下的子目录数，其实default-host目录下并没有子目录，为什么会显示有2个子目录呢，因为任何目录都有2个子目录，当前目录（.）和子目录（..）。</li>
<li>第三列：当前文件所属的用户名，若该用户被删除，则会显示该用户删除前的用户id。</li>
<li>第四列：当前文件所属的用户组。</li>
<li>第五列：若是文件则代表该文件的大小，若是目录则代表该目录的大小（不包括目录下的子目录和文件的大小）。</li>
<li>第六列：该文件最近修改或者查看的时间。</li>
<li>第七列：文件名称。</li>
</ul>
<h3 id="常见的文件类型"><a href="#常见的文件类型" class="headerlink" title="常见的文件类型"></a>常见的文件类型</h3><blockquote>
<p>在Linux系统中，内核为每一个新创建的文件分配一个inode，保存在索引节点里，访问文件的时候，索引节点被复制到内存，从而实现文件的快速访问</p>
</blockquote>
<p><strong>普通文件</strong>：文件属性符号（第一个符号） -  图像工具、文档工具、归档工具；</p>
<p><strong>目录文件</strong>：文件属性符号 d  ；</p>
<p><strong>设备文件</strong>：/dev目录下的设备文件 ；</p>
<p><strong>字符设备文件</strong>：文件属性符号 c   接收字符流，打印机和终端；</p>
<p><strong>块设备文件</strong>：  文件属性符号 b   随机读写，如磁盘；</p>
<p><strong>管道文件/FIFO文件</strong>：文件属性符号p   一头流入，从另一头流出；</p>
<h4 id="链接文件-删除不会影响源文件"><a href="#链接文件-删除不会影响源文件" class="headerlink" title="链接文件 删除不会影响源文件"></a>链接文件 删除不会影响源文件</h4><ul>
<li><strong>软链接</strong> 第一个符号l，对软链接进行编辑，自动把操作转换为源文件的操作</li>
<li><strong>硬链接</strong> 删除源文件，硬连接依然存在，忘记自己是硬链接件，还是可以打开文件</li>
</ul>
<h3 id="常见目录及其用途"><a href="#常见目录及其用途" class="headerlink" title="常见目录及其用途"></a>常见目录及其用途</h3><table>
<thead>
<tr>
<th>目录</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>/</td>
<td>根目录</td>
</tr>
<tr>
<td>/home</td>
<td>用户目录的宿主目录，存放普通用户的数据</td>
</tr>
<tr>
<td>/bin</td>
<td>存放普通的可执行命令</td>
</tr>
<tr>
<td>/sbin</td>
<td>存放root使用的系统管理程序</td>
</tr>
<tr>
<td>/dev</td>
<td>设备文件保存目录</td>
</tr>
<tr>
<td>/mnt和/media</td>
<td>手动/自动挂载的设备目录目录</td>
</tr>
<tr>
<td>/boot</td>
<td>启动目录，用来存放与Linux系统启动有关的程序</td>
</tr>
<tr>
<td>/proc</td>
<td>虚拟目录，系统内存映射</td>
</tr>
<tr>
<td>/opt</td>
<td>可选程序的安装目录</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>目录</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>/var</td>
<td>存放经常变化的数据以及日志文件</td>
</tr>
<tr>
<td>/etc</td>
<td>配置文件保存目录</td>
</tr>
<tr>
<td>/usr</td>
<td>用来存放Linux系统中的应用程序</td>
</tr>
<tr>
<td>/lost+found</td>
<td>存修复或损坏的文件</td>
</tr>
<tr>
<td>/srv</td>
<td>存特定服务所需文件的目录</td>
</tr>
<tr>
<td>/selinux</td>
<td>SELinux相关</td>
</tr>
</tbody></table>
<h3 id="常见操作"><a href="#常见操作" class="headerlink" title="常见操作"></a>常见操作</h3><ol>
<li>cp -r dir dir 将目录中的所有文件以及子目录复制到另一个目录中</li>
<li>mv 可以用来改名</li>
<li>pwd 工作path</li>
<li>rm -df / rm -rf 差别不大 递归删除</li>
<li>wc 行数单词数字符数**</li>
</ol>
<h3 id="硬链接软链接"><a href="#硬链接软链接" class="headerlink" title="硬链接软链接"></a>硬链接软链接</h3><blockquote>
<p>Linux是通过link的数量来控制文件删除的，只有当一个文件不存在任何link的时候，这个文件才会被删除</p>
<p>所以即使执行rm操作，但系统并没有真正删除这个文件，只是删除了指向inode的一个链接</p>
<p>所以删除原文件，还是可以通过硬链接打开“被删除“的文件</p>
</blockquote>
<h4 id="软链接文件"><a href="#软链接文件" class="headerlink" title="软链接文件"></a>软链接文件</h4><p>软链接又称为符号链接,这个文件包含了另一个文件/目录的路径名。</p>
<p>用“ls -l”命令查看某个文件的属性,可以看到有类似“lrwxrwxrwx”的属性符号,其属性第一个符号是“l”,这样的文件在 Linux系统中就是软链接文件。会有断链的问题</p>
<p>可以做不同分区的链接</p>
<p>使用频率更高</p>
<p>可以看成快捷方式？</p>
<p>ln -s a b//b为a的软链接</p>
<h4 id="硬链接文件"><a href="#硬链接文件" class="headerlink" title="硬链接文件"></a>硬链接文件</h4><p>硬链接是一个指针,指向文件索引节点,系统并不为它重新分配inode。可以用ln命令来建立硬链接。硬链接节省空间,也是Linux 系统整合文件系统的传统方式。</p>
<p>硬链接文件有两个限制:</p>
<ul>
<li>不允许给目录创建硬链接;(但是软连接中可以为一个目录创建一个快捷方式)</li>
<li>只有在同一文件系统中的文件之间才能创建硬链接。（软链接可以跨文件系统）</li>
</ul>
<p>ln a b//b为a的硬链接</p>
<h4 id="硬链接和软链接的区别"><a href="#硬链接和软链接的区别" class="headerlink" title="硬链接和软链接的区别"></a>硬链接和软链接的区别</h4><ul>
<li>硬链接记录的是目标的inode,软链接记录的是目标的路径。</li>
<li>软链接就像是快捷方式,而硬链接就像是备份（不恰当）。</li>
<li>软链接可以做跨分区的链接,而硬链接由于inode的缘故,只能在本分区中做链接。所以,软链接的使用频率要高得多。</li>
<li>软连接可以对一个不存在的文件名进行连接 。</li>
<li>软连接可以对目录进行连接。</li>
</ul>
<h2 id="Ch5-Linux常用操作命令"><a href="#Ch5-Linux常用操作命令" class="headerlink" title="Ch5 Linux常用操作命令"></a>Ch5 Linux常用操作命令</h2><h3 id="文本显示和处理命令"><a href="#文本显示和处理命令" class="headerlink" title="文本显示和处理命令"></a>文本显示和处理命令</h3><p><code>cat命令</code>可以显示文本文件内容,或把几个文件内容附加到另一个文件中。</p>
<p>cat -n textfile1 &gt; textfile2//加上行号重定向</p>
<p>cat &gt;mm.txt&lt;&lt;EOF//创建并且编辑mm.txt直到EOF</p>
<p><code>more命令</code>可以分页显示文本文件的内容。</p>
<p>more -2 xx.txt//一次两行</p>
<p><code>less命令</code>和more相同，可以回卷显示文本文件的内容。</p>
<p><code>head命令</code>可以显示指定文件的前若干行文件或者若干个字符（-c）内容。</p>
<p><code>tail命令</code>可以查看文件的末尾数据。</p>
<p><code>sort命令</code>可以对文件中的数据进行排序,并将结果显示在标准输出上。（但是并不改变来源中的内容）</p>
<p><code>sort –r</code> 倒序排序</p>
<p><code>uniq命令</code>将重复行从输出文件中删除</p>
<p><code>cut命令</code>可以从文件的每行中显示出选定的字节、字符或字段。</p>
<p><code>comm命令</code>可以比较两个已排过序的文件,并将其结果显示出来。</p>
<p>comm -12 相同行</p>
<p><code>diff命令</code>可以逐行比较两个文本文件,列出其不同之处。它比comm命令完成更复杂的检查。它对给出的文件进行系统的检查,并显示出两个文件中所有不同的行,不要求事先对文件进行排序。</p>
<blockquote>
<p>comm是只要两个文件都包含了，就是相同的，而diff必须在同一行才相同，并且comm要排序，diff不需要</p>
</blockquote>
<h3 id="文件和命令查找命令"><a href="#文件和命令查找命令" class="headerlink" title="文件和命令查找命令"></a>文件和命令查找命令</h3><p><code>grep命令</code>可以查找文件中符合条件的字符串。</p>
<p><code>find命令</code>可以将文件系统中符合条件的文件或目录列出来,可以指定文件的名称、类别、时间、大小以及权限等不同信息的组合,只有完全相符的文件才会被列出来。</p>
<p>find . -ctime -20//最近二十天更改过的文件</p>
<p>find / -name</p>
<p><code>.conf</code>//以conf为扩展名的文件</p>
<p><code>locate命令</code>用于在数据库中查找文件。比find命令的搜索速度快,它需要一个数据库,这个数据库由每天的例行工作(crontab)程序来建立。当建立好这个数据库后,就可以方便地搜寻所需文件了。</p>
<p><code>whereis命令</code>可以查找指定文件、命令和手册页的位置。</p>
<p>（与man比较：显示文件、命令、函数的手册页内容）</p>
<p><code>file命令</code>可以查询指定文件的文件类型。</p>
<p><code>whatis [命令]</code>可以查询指定命令的功能。</p>
<p><code>which [命令]</code>可以显示可执行命令的路径和它的别名。</p>
<p><code>uname</code>：显示计算机及操作系统相关信息</p>
<p><code>uname –r</code> //显示系统内核版本</p>
<p><code>uname –n</code> //显示计算机主机名</p>
<p><code>uname –m</code> //显示计算机硬件类型</p>
<p><code>uname –a</code> //显示全部信息</p>
<p><code>hostname</code>：显示或修改计算机主机名</p>
<p><code>dmesg</code>：显示计算机开机信息</p>
<p><code>cal</code>：显示日历信息</p>
<p><code>date</code>：显示和设置系统日期和时间</p>
<p>date 0202191428//设置计算机日期和时间为2028年2月2日19点14分。</p>
<p>date +’%r%a%d%h%y’</p>
<p>date -s 240414//设置计算机时间</p>
<p> hwclock -w//以系统时间更新硬件时间</p>
<p> hwclock -s//以硬件时间更新系统时间</p>
<p><code>echo</code>  echo命令可以在计算机显示器上显示一段文字,一般起到一个提示的作用。或者把信息输出到文件</p>
<p><code>mesg</code>：设置其他用户发送信息的权限</p>
<p><code>wall</code>：对全部已登录用户发送信息</p>
<p><code>write</code>：向用户发送消息</p>
<p><code>clear</code>：清除计算机屏幕上信息</p>
<p><code>sync</code>：将缓冲区内的文件写到硬盘中</p>
<p><code>uptime</code>：显示系统已经运行的时间</p>
<p><code>last</code>：显示近期用户登录情况</p>
<h2 id="Ch6-Shell编程"><a href="#Ch6-Shell编程" class="headerlink" title="Ch6 Shell编程"></a>Ch6 Shell编程</h2><h3 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h3><h4 id="1-简述简单Shell程序的创建过程"><a href="#1-简述简单Shell程序的创建过程" class="headerlink" title="1. 简述简单Shell程序的创建过程"></a>1. 简述简单Shell程序的创建过程</h4><ul>
<li>创建文件、设置可执行权限、执行shell程序</li>
<li>创建文件、使用bash命令执行程序</li>
</ul>
<h4 id="2-简述执行Shell程序有那些方法"><a href="#2-简述执行Shell程序有那些方法" class="headerlink" title="2. 简述执行Shell程序有那些方法"></a>2. 简述执行Shell程序有那些方法</h4><ul>
<li>bash Shell程序文件名</li>
<li>bash &lt; Shell程序名</li>
<li>chmod +ux Shell程序文件名//Shell程序变成可以执行的文件<ul>
<li>Shell程序文件名//直接运行</li>
</ul>
</li>
<li>source Shell程序文件名或者 . Shell程序文件名</li>
</ul>
<h3 id="Shell程序创建"><a href="#Shell程序创建" class="headerlink" title="Shell程序创建"></a>Shell程序创建</h3><ol>
<li>通常情况下，从命令行每输入一次命令就 能够得到系统响应，如果需要一个接着一个地输入命令才得到结果的时候，这样的做法效率很低。使用Shell程序或者Shell 脚本可以很好地解决这个问题。<ol>
<li>作为命令语言互动式地解释和执行用户输入的命令是Shell的功能之一，Shell还可以用来进行程序设计，它提供了定义变量和参数的手段以及丰富的过程控制结构。使用Shell编程类似于使用DOS中的批处理文件，称为Shell脚本，又叫做Shell程序或Shell命令文件。</li>
<li>Shell程序就是放在一个文件中的一系列 Linux命令和实用程序，在执行的时候，通 过Linux系统一个接着一个地解释和执行每个命令</li>
</ol>
</li>
<li>创建示例<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="comment">#filename:date</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;Mr.<span class="variable">$USER</span>,Today is:&quot;</span><span class="comment">#echo后面有变量就要加双引号</span></span><br><span class="line"><span class="built_in">echo</span> `date`</span><br><span class="line"><span class="built_in">echo</span> Whish you a lucky day !</span><br></pre></td></tr></table></figure></li>
<li>修改权限<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">chmod u+x /root/date</span><br><span class="line">ls -l /root/date</span><br><span class="line"><span class="comment"># -rwxr--r--. 1 root root 88 6月 3 05:37 /root/date</span></span><br><span class="line">/root/data</span><br><span class="line"><span class="comment">#Mr.root,Today is:</span></span><br><span class="line"><span class="comment">#2012年 06月 03日 星期日 05:37:34 CST</span></span><br><span class="line"><span class="comment">#Whish you a lucky day !</span></span><br></pre></td></tr></table></figure></li>
<li>如果不设置权限，可以用bash来运行</li>
</ol>
<p><code>bash /root/date</code> </p>
<h3 id="Shell-变量"><a href="#Shell-变量" class="headerlink" title="Shell 变量"></a>Shell 变量</h3><ol>
<li>Shell程序采用$var的形式来引用名为var的变量的值<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="variable">$HOME</span></span><br><span class="line">/root</span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$PWD</span></span><br><span class="line">/root</span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$PS1</span></span><br><span class="line">[\u@\h \W]\$</span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$PS2</span></span><br><span class="line">&gt;</span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$PATH</span> /usr/lib/ccache:/usr/<span class="built_in">local</span>/sbin:/usr/<span class="built_in">local</span>/bin:/sbin:/bin:/usr/sbin:/usr/bin:/root/bin [root@rhel ~]<span class="comment"># echo $TERM</span></span><br><span class="line">vt100</span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$UID</span></span><br><span class="line">0</span><br></pre></td></tr></table></figure></li>
<li>用户定义的变量<ol>
<li>变量名=变量值/等号两边一定不能留空格，如果变量本身就有空格，那么就用双括号括起来</li>
</ol>
</li>
<li>位置参数：程序名之后输入的参数，第一个在程序中 <code>$1</code> ,依次类推， <code>$0</code> 是文件名</li>
<li>预定义变量</li>
</ol>
<p><img src="https://cynyard-blog-pics.oss-cn-beijing.aliyuncs.com/image/1598175491527-1f34040f-60e7-4c59-bc1c-5d41bf1165ee.png" alt="image.png"></p>
<ol start="5">
<li>参数替换<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var=<span class="string">&quot;hello&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$var</span> <span class="variable">$&#123;title-&quot;somebody&quot;&#125;</span>!//如果有参数，那么就变量等于参数，每有参数，那么变量等于word</span><br><span class="line">hello somebody!</span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$var</span> <span class="variable">$&#123;title+&quot;somebody&quot;&#125;</span>!//如果有参数，word替换变量</span><br><span class="line">hello !</span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$var</span> <span class="variable">$&#123;title?&quot;title is null or empty&quot;&#125;</span>! //出错提示</span><br><span class="line">bash: title: title is null or empty!</span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$var</span> <span class="variable">$&#123;title=&quot;tom and jerry&quot;&#125;</span>!//如果有参数，那么就变量等于参数，每有参数，那么变量等于word，参数等于word</span><br><span class="line">hello tom and jerry!</span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$var</span> <span class="variable">$&#123;title+&quot;somebbody&quot;&#125;</span>!//title不为空，</span><br><span class="line">hello somebbody!</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h3 id="变量表达式"><a href="#变量表达式" class="headerlink" title="变量表达式"></a>变量表达式</h3><ol>
<li>test是Shell程序中的一个表达式，通过和Shell提供的if等条件语句相结合可以方便的测试字符串，文件状态和数字 <code>test xxx</code> </li>
</ol>
<p><strong>字符串比较</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">str1=abcd</span><br><span class="line"><span class="built_in">test</span> <span class="variable">$str1</span> = abcd</span><br><span class="line"><span class="built_in">echo</span> $?</span><br><span class="line">0</span><br><span class="line">str=abcd</span><br><span class="line"><span class="built_in">test</span> <span class="variable">$str</span>-n</span><br><span class="line"><span class="built_in">echo</span> $?</span><br><span class="line">0</span><br></pre></td></tr></table></figure>
<p><strong>数字比较</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">int1=1234 </span><br><span class="line">int2=01234 </span><br><span class="line"><span class="built_in">test</span> <span class="variable">$int1</span> -eq <span class="variable">$int2</span></span><br><span class="line"><span class="built_in">echo</span> $?</span><br><span class="line">0</span><br></pre></td></tr></table></figure>
<p>source命令和shell scripts的区别是，source在当前bash环境下执行命令，而scripts是启动一个子shell来执行命令。这样如果把环境变量的设置命令写进scripts中，就只会影响子shell，无法改变当前的bash，所以通过文件设置环境变量时，要用source命令</p>
<p><strong>目前流行的Shell有sh，csh，ksh，tcsh和bash等</strong></p>
<h3 id="Shell部分"><a href="#Shell部分" class="headerlink" title="Shell部分"></a>Shell部分</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash 求所有输入的数的和</span></span><br><span class="line"><span class="comment">#filename bash3t</span></span><br><span class="line">sum=0</span><br><span class="line"><span class="keyword">for</span> int <span class="keyword">in</span> $*</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">   sum=`expr <span class="variable">$sum</span> + <span class="variable">$int</span>`</span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$sum</span></span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="comment">#filename:za</span></span><br><span class="line"><span class="comment">#Display a menu</span></span><br><span class="line"><span class="built_in">echo</span> _</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;1 Restore&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;2 Backup&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;3 Unload&quot;</span></span><br><span class="line"><span class="built_in">echo</span></span><br><span class="line"><span class="comment">#Read and excute the user&#x27;s selection</span></span><br><span class="line"><span class="built_in">echo</span> -n <span class="string">&quot;Enter Choice:&quot;</span></span><br><span class="line"><span class="built_in">read</span> CHOICE</span><br><span class="line"><span class="keyword">case</span> <span class="string">&quot;<span class="variable">$CHOICE</span>&quot;</span> <span class="keyword">in</span></span><br><span class="line">1) <span class="built_in">echo</span> <span class="string">&quot;Restore&quot;</span>;;</span><br><span class="line">2) <span class="built_in">echo</span> <span class="string">&quot;Backup&quot;</span>;;</span><br><span class="line">3) <span class="built_in">echo</span> <span class="string">&quot;Unload&quot;</span>;;</span><br><span class="line">*) <span class="built_in">echo</span> <span class="string">&quot;Sorry <span class="variable">$CHOICE</span> is not a valid choice&quot;</span></span><br><span class="line"><span class="built_in">exit</span> 1</span><br><span class="line"><span class="keyword">esac</span></span><br></pre></td></tr></table></figure>

<h2 id="Ch7-用户和组群账号管理"><a href="#Ch7-用户和组群账号管理" class="headerlink" title="Ch7 用户和组群账号管理"></a><strong>Ch7 用户和组群账号管理</strong></h2><h3 id="用户类型"><a href="#用户类型" class="headerlink" title="用户类型"></a><strong>用户类型</strong></h3><p>在Linux系统中主要有root用户、虚拟用户和普通用户这3类用户。</p>
<p>通过UID来标识。</p>
<p>每个用户类型的权限和所能完成的任务也不同</p>
<p>root用户也被称为超级管理用户。UID为0，在系统中的每个文件、目录和进程都归属于某一个用户，没有用户许可，其他普通用户都不能操作，除了root用户</p>
<p>虚拟用户是内置用户，不具备登录系统的能力，但却是系统运行不可缺少的用户 bin，daemon，adm，ftp，mail；UID为1-999</p>
<p>普通用户：只能操作自己目录内的文件，UID为1000～60k</p>
<h3 id="组群"><a href="#组群" class="headerlink" title="组群"></a>组群</h3><p>具有某种共同特征的用户集合就是组群。通过组群可以集中设置访问权限和分配管理任务。</p>
<p>比如把某一用户加入到root组群，那么 这个用户就可以浏览root用户主目录的文件，如果root用 户把某个文件读写执行权限开放，root组群的所有用户 都可以修改此文件;如果是可执行的文件，root组群的用 户也是可以执行的。</p>
<p>分类</p>
<ol>
<li>私有组群标准组群<ol>
<li>私有：创建的时候没有制定，同名的组群，只包含这一个用户</li>
<li>标准：创建的时候制定的组群，</li>
</ol>
</li>
<li>主要组群次要组群<ol>
<li>登陆后所属的组群</li>
<li>附加组群</li>
</ol>
</li>
</ol>
<h3 id="常用配置文件的特定行"><a href="#常用配置文件的特定行" class="headerlink" title="常用配置文件的特定行"></a>常用配置文件的特定行</h3><h4 id="etc-passwd"><a href="#etc-passwd" class="headerlink" title="/etc/passwd"></a>/etc/passwd</h4><p>是系统识别用户的一个文件,Linux系统中所有的用户都记录在该文件中。用户登录系统的时候时候，首先检查这个文件看是否有这个账户，然后确定UID，通过UID确定身份，最后读取/etc/shadow中对应的秘密</p>
<p>一行有7个段位，每个段位冒号分隔。</p>
<table>
<thead>
<tr>
<th>用户名</th>
<th>口令</th>
<th>用户标识号UID-唯一</th>
<th>组群标识号GID-唯一</th>
<th>用户名全称</th>
<th>主目录</th>
<th>登录Shell</th>
</tr>
</thead>
<tbody><tr>
<td>zhangsan</td>
<td>x</td>
<td>1000</td>
<td>1000</td>
<td>张三（用户名全称指用户名描述，可以不设置）</td>
<td>/home/zhangsan</td>
<td>/bin/bash</td>
</tr>
</tbody></table>
<h4 id="etc-shadow"><a href="#etc-shadow" class="headerlink" title="/etc/shadow"></a>/etc/shadow</h4><p>是/etc/passwd文件的影子文件,两个文件是对应互补的。</p>
<p>内容包括用户及加密的口令及其他/etc/passwd不能包括的信息，比如用户账号的有限期限等。（他们的权限不同）</p>
<p>一行有9个段位，每个段位冒号分隔。</p>
<table>
<thead>
<tr>
<th>用户名</th>
<th>加密口令</th>
<th>用户最后一次更改口令的日期</th>
<th>口令允许更换前的天数</th>
<th>口令需要更换的天数</th>
<th>口令更换前警告的天数</th>
<th>账户被取消激活前的天数</th>
<th>用户账户过期日期</th>
<th>保留字段</th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<h4 id="etc-group"><a href="#etc-group" class="headerlink" title="/etc/group"></a>/etc/group</h4><p>是用户组群的配置文件<br>内容包括用户和用户组群,并且能显示出用户是归属哪个用户组群或哪几个用户组群。</p>
<table>
<thead>
<tr>
<th>组群名</th>
<th>组群口令</th>
<th>组群标识号</th>
<th>组群成员</th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td>这里的 “x” 仅仅是密码标识，</td>
<td></td>
<td></td>
</tr>
</tbody></table>
<p>GID为0的组群是root组群；GID从1000开始，预留1000个</p>
<h4 id="etc-gshadow"><a href="#etc-gshadow" class="headerlink" title="/etc/gshadow"></a>/etc/gshadow</h4><p>是/etc/group的加密文件,这两个文件是对应互补的。</p>
<table>
<thead>
<tr>
<th>组群名</th>
<th>组群口令</th>
<th>组管理员</th>
<th>组群成员</th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td>此处存储加密后的口令，如果没有设置，则为<code>!</code></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<p><img src="https://cdn.nlark.com/yuque/0/2020/png/1096029/1600003746438-e060b23b-28b9-46a1-ac03-f846d8c8095d.png" alt="image.png"><img src="https://cynyard-blog-pics.oss-cn-beijing.aliyuncs.com/image/1600003797633-284754a2-6eee-4bc1-9da7-3229d6486cd4.png" alt="image.png"></p>
<h3 id="账户信息显示"><a href="#账户信息显示" class="headerlink" title="账户信息显示"></a>账户信息显示</h3><p><code>finger命令</code>可以显示用户账户的信息。<br><code>groups命令</code>可以显示指定用户账户的组群成员身份。<br><code>id命令可以</code>显示用户的ID以及该用户所属组群的GID。<br><code>w命令</code>可以详细查询已登录当前计算机的用户。<br><code>who命令</code>可以显示已登录当前计算机用户的简单信息。</p>
<h2 id="Ch8-磁盘和文件系统管理"><a href="#Ch8-磁盘和文件系统管理" class="headerlink" title="Ch8 磁盘和文件系统管理"></a>Ch8 磁盘和文件系统管理</h2><blockquote>
<p>在Linux系统中，如果需要在某个磁盘上存储数据，则需要将磁盘进行分区，然后创建文件系统，最后将文件系统挂载到目录下才可以。<br>在安装Linux系统后需要添加更多的交换空间，可以通过添加一个交换分区或添加一个交换文件来实现。</p>
</blockquote>
<h3 id="分区回顾"><a href="#分区回顾" class="headerlink" title="分区回顾"></a>分区回顾</h3><blockquote>
<p>硬盘分区一共有3种:主分区、扩展分区和逻辑分区。扩展分区就是逻辑驱动器的容器，只有主分区和逻辑驱动器才能进行数据存储</p>
</blockquote>
<h4 id="分区的命名"><a href="#分区的命名" class="headerlink" title="分区的命名"></a>分区的命名</h4><p>硬盘类型用sd/hd/vd（虚拟盘）表示，硬盘名顺序通过abc，分区用1234表示，主分区为 1<del>4 中的一段，扩展分区为 2</del>4 分区之间的剩余。<br />逻辑分区是在扩展分区的再分，命名从5开始。主分区最多有4个（若多于4个，那么除了前三个剩下的必然是逻辑分区）**</p>
<h3 id="格式化"><a href="#格式化" class="headerlink" title="格式化"></a>格式化</h3><h4 id="定义："><a href="#定义：" class="headerlink" title="定义："></a>定义：</h4><p>格式化是指对磁盘分区进行初始化的一种操作，这种操作通常会导致 现有的分区中所有的数据被清除。就是把一张空白的磁盘划分成一个个小区域并编号，供计算机储存和读取数据使用，也就是在磁盘中建立磁道以及扇区</p>
<h3 id="文件系统"><a href="#文件系统" class="headerlink" title="文件系统"></a>文件系统</h3><p><strong>Linux</strong>系统最常用的几种文件系统</p>
<ol>
<li>ext3/ext4</li>
<li>JFS</li>
<li>XFS（推荐，它是CentOS所默认的分区文件系统）</li>
</ol>
<p><img src="https://cynyard-blog-pics.oss-cn-beijing.aliyuncs.com/image/1600003521418-dda242ce-b329-4a76-86fd-e71b78294789.png" alt="image.png"></p>
<h3 id="创建文件系统整个过程"><a href="#创建文件系统整个过程" class="headerlink" title="创建文件系统整个过程"></a>创建文件系统整个过程</h3><h4 id="使用fdisk命令在硬盘上创建分区。"><a href="#使用fdisk命令在硬盘上创建分区。" class="headerlink" title="使用fdisk命令在硬盘上创建分区。"></a>使用fdisk命令在硬盘上创建分区。</h4><p>Linux系统使用fdsik命令能将磁盘划分成为若干个区,同时也能为每个分区指定分区的文件系统。<br /><img src="https://cynyard-blog-pics.oss-cn-beijing.aliyuncs.com/image/1598183506155-2937e195-4a95-43e3-bc89-f67379e130ee.gif"></p>
<h4 id="使用mkfs命令在分区上创建文件系统。"><a href="#使用mkfs命令在分区上创建文件系统。" class="headerlink" title="使用mkfs命令在分区上创建文件系统。"></a>使用mkfs命令在分区上创建文件系统。</h4><p><code>partprobe</code> 避免了重启系统，可以直接让内核重新给i能读取分区信息</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkfs -t ext4 /dev/sda5</span><br></pre></td></tr></table></figure>

<h4 id="使用mount命令挂载文件系统-或修改-etc-fstab文件使得开机自动挂载文件系统。"><a href="#使用mount命令挂载文件系统-或修改-etc-fstab文件使得开机自动挂载文件系统。" class="headerlink" title="使用mount命令挂载文件系统,或修改/etc/fstab文件使得开机自动挂载文件系统。"></a>使用mount命令挂载文件系统,或修改/etc/fstab文件使得开机自动挂载文件系统。</h4><p>mount命令可以将某个分区、光盘、软盘或是U盘挂载到Linux系统的目录下。<br /><code>mount [选项][设备名称][挂载点]</code></p>
<h4 id="使用umount卸载文件系统。"><a href="#使用umount卸载文件系统。" class="headerlink" title="使用umount卸载文件系统。"></a>使用umount卸载文件系统。</h4><p>umount命令可以将某个分区、光盘、软盘或是U盘进行卸载。<br /><code>umount [选项][-t &lt;文件系统类型&gt;][文件系统]</code><br />命令语法:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mkdir /mnt/kk</span><br><span class="line">mount /dev/sda5 /mnt/kk</span><br><span class="line"><span class="comment">#以只读方式创建</span></span><br><span class="line">mount -o ro /dev/sda5/mnt/kk</span><br><span class="line">df<span class="comment">#显示磁盘空间的使用情况</span></span><br><span class="line">umount /dev/sda5</span><br></pre></td></tr></table></figure>

<h3 id="查看分区挂载情况"><a href="#查看分区挂载情况" class="headerlink" title="查看分区挂载情况"></a>查看分区挂载情况</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">df</span><br><span class="line">mount -s</span><br><span class="line">cat /etc/mtab</span><br></pre></td></tr></table></figure>

<h3 id="自动挂载"><a href="#自动挂载" class="headerlink" title="自动挂载"></a>自动挂载</h3><h4 id="挂载"><a href="#挂载" class="headerlink" title="挂载"></a>挂载</h4><p>/etc/fstab是一个配置文件，它包含了所有分区以及存储设备的信息。<br />root用户才可以编辑该文件。<br />可以通过修改/etc/fstab文件实现开机自动挂载文件系统。<br />**把末尾的0 0 修改为 1 2 **<br />各段含义：<br />设备名或设备UUID号 |挂载点 |文件系统格式|挂载参数 |转储选项|文件系统检查选项</p>
<table>
<thead>
<tr>
<th>设备名或设备UUID号</th>
<th>挂载点</th>
<th>文件系统格式</th>
<th>挂载参数</th>
<th>转储选项</th>
<th>文件系统检查选项</th>
</tr>
</thead>
<tbody><tr>
<td>/dev/sda5</td>
<td>/mnt/kk</td>
<td>xfs</td>
<td>defaults</td>
<td>1</td>
<td>2</td>
</tr>
</tbody></table>
<h4 id="查看uuid"><a href="#查看uuid" class="headerlink" title="查看uuid"></a>查看uuid</h4><p>ls –l /dev/disk/by-uuid</p>
<h3 id="创建交换分区"><a href="#创建交换分区" class="headerlink" title="创建交换分区"></a>创建交换分区</h3><blockquote>
<p>Linux系统中的交换空间在物理内存被用完时使用。 如果系统需要更多的内存资源，而物理内存已经 用完，内存中不活跃的页就会被转移到交换空间 中。虽然交换空间可以为带有少量内存的计算机 提供帮助，但是这种方法不应该被当做是对内存 的取代</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">mkswap /dev/sda5</span><br><span class="line">free<span class="comment">#看不到</span></span><br><span class="line">swapon /dev/sda5</span><br><span class="line">free<span class="comment"># 显示系统的物理内存和swap的使用情况。</span></span><br><span class="line">cat /proc/swaps</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;/dev/sda5 swap swap defaults 0 0&quot;</span> &gt;&gt; /etc/fstab</span><br><span class="line">swapoff /dev/sda5</span><br><span class="line">vim /etc/fstab <span class="comment">#删除加的东西</span></span><br><span class="line"><span class="comment">#### swapfile同理</span></span><br></pre></td></tr></table></figure>

<h2 id="Ch9-Linux日常管理和维护"><a href="#Ch9-Linux日常管理和维护" class="headerlink" title="Ch9 Linux日常管理和维护"></a><strong>Ch9 Linux日常管理和维护</strong></h2><h3 id="RPM"><a href="#RPM" class="headerlink" title="RPM"></a>RPM</h3><blockquote>
<p>RPM软件包管理器是一种开放的软件包管理系统</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#安装、卸载、刷新、升级、查询</span></span><br><span class="line">rpm -ivh xxx 安装</span><br><span class="line">rpm -e xxx 卸载</span><br><span class="line">rpm -Uvh xxx <span class="comment">#升级</span></span><br><span class="line">rpm -Fvh xxx <span class="comment">#刷新</span></span><br><span class="line">rpm -q xxx 有没有安装</span><br><span class="line">rpm -qa</span><br><span class="line">rpm -qi xxx 描述信息</span><br><span class="line">rpm -ql xxx 文件列表</span><br><span class="line">rpm -qR xxx 依赖要求</span><br><span class="line">rpm -qf xxx <span class="comment">#查询属于那个软件包</span></span><br></pre></td></tr></table></figure>

<h4 id="yum安装RPM"><a href="#yum安装RPM" class="headerlink" title="yum安装RPM"></a>yum安装RPM</h4><p>自动化地升级、安装和删除RPM软件包，收集RPM软件包的相关信息， 检查依赖性并且一次安装所有依赖的软件包，无 须繁琐地一次次安装。</p>
<blockquote>
<p>yum的关键之处是要有可靠的软件仓库，软件仓 库可以是HTTP站点、FTP站点或者是本地软件 池，但必须包含rpm的header，header包括了 RPM软件包的各种信息，包括描述、功能、提供 的文件以及依赖性等</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">yum install xxx</span><br><span class="line">yum remove xxx</span><br><span class="line">yum update xxx</span><br><span class="line">yum info xxx</span><br></pre></td></tr></table></figure>

<h3 id="tar命令，两组：创建压缩包，解压缩包，两种选项，每组下面各有4个字母"><a href="#tar命令，两组：创建压缩包，解压缩包，两种选项，每组下面各有4个字母" class="headerlink" title="tar命令，两组：创建压缩包，解压缩包，两种选项，每组下面各有4个字母"></a>tar命令，两组：创建压缩包，解压缩包，两种选项，每组下面各有4个字母</h3><p>使用tar命令可以将文件和目录进行打包或压缩以做备份用。<br />打包是指将许多文件和目录变成一个总的文件，压缩则是将一个大的文件通过一些压缩算法变成一个小文件。<br />Linux系统中很多压缩程序只能针对一个文件进行压缩，这样当需要压缩一大堆文件时，就得先借助其他的工具将这一大堆文件先打成一个包，然后再用原来的压缩程序进行压缩。tar+gzip  tar+bzip2<br /><img src="https://cynyard-blog-pics.oss-cn-beijing.aliyuncs.com/image/1600003589507-5bedded3-0cbe-440f-a926-390bdcf4770d.png" alt="image.png"></p>
<h2 id="Ch10-权限与所有者"><a href="#Ch10-权限与所有者" class="headerlink" title="Ch10 权限与所有者"></a>Ch10 权限与所有者</h2><blockquote>
<p>在Linux系统中，每种用户都有对文件或目录的读取、写入和执行权限。只有系统管理员和文件的所有者才可以更改文件或目录的权限。</p>
</blockquote>
<h3 id="权限与用户"><a href="#权限与用户" class="headerlink" title="权限与用户"></a>权限与用户</h3><ol>
<li>通过设定权限可以限制或允许以下3种用户访问:<ul>
<li>文件的所有者、</li>
<li>文件所有者所在组的同组用户、</li>
<li>系统中的其他用户。</li>
</ul>
</li>
<li>权限：<ol>
<li>r<ol>
<li>可以读取文件内容</li>
<li>可以浏览目录</li>
</ol>
</li>
<li>w<ol>
<li>可以修改文件内容</li>
<li>可以删除，移动目录内的文件</li>
</ol>
</li>
<li>x<ol>
<li>可以执行文件</li>
<li>可以进入目录</li>
</ol>
</li>
</ol>
</li>
<li>-rwxr—w-<ol>
<li>用户所有者拥有三种权限</li>
<li>组群所有者只能读</li>
<li>其他用户只能写</li>
</ol>
</li>
</ol>
<h3 id="文件管理器更改权限"><a href="#文件管理器更改权限" class="headerlink" title="文件管理器更改权限"></a>文件管理器更改权限</h3><h4 id="文字设定法"><a href="#文字设定法" class="headerlink" title="文字设定法"></a>文字设定法</h4><p>u表示该文件的所有者,g表示与该文件的所有者属于同一个组的用户,o表示其他用户,a表示以上三者;</p>
<p>+表示增加指定权限,-表示取消指定权限,= 表示设定权限等于指定权限; </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">chmod u+w a</span><br><span class="line">chmod g-r a</span><br><span class="line">chmod o=w a <span class="comment">#其他用户只能写</span></span><br></pre></td></tr></table></figure>

<h4 id="数字设定法"><a href="#数字设定法" class="headerlink" title="数字设定法"></a>数字设定法</h4><p>r w x - 对应数值 4读取权限 2写入权限 1可执行权限 0没有权限</p>
<p>一共三位，分别表示所有者、所在群组其它成员和其它用户的权限之和</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">chomod 777 a</span><br><span class="line">chmod 7 a <span class="comment">#其他用户拥有读取、写入和执行的权限 相当于007</span></span><br></pre></td></tr></table></figure>

<h4 id="三个特殊权限"><a href="#三个特殊权限" class="headerlink" title="三个特殊权限"></a>三个特殊权限</h4><ol>
<li>SUID：一个可执行文件是以这个文件的用户所有者来执行 对应u 4000</li>
<li>SGID：一个可执行文件是以组群所有者身份来执行 对应g 2000</li>
<li>Sticky：对目录执行Sticky后，只有文件所有者才能删除和移动 对应o 1000</li>
</ol>
<h4 id="所有权"><a href="#所有权" class="headerlink" title="所有权"></a>所有权</h4><p><code>chown命令</code>可以更改文件和目录的所有者和用户组</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">chown newuser a</span><br><span class="line">chown .newuser a <span class="comment">#用户组</span></span><br><span class="line">chown root.newuser a</span><br><span class="line">chown -R newuser.newuser /root/b</span><br></pre></td></tr></table></figure>

<h2 id="Ch11-Linux日常管理和维护"><a href="#Ch11-Linux日常管理和维护" class="headerlink" title="Ch11 Linux日常管理和维护"></a>Ch11 Linux日常管理和维护</h2><h3 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h3><p>Linux系统上所有运行的内容都可以称为进程。正在执行的一个或者多个相关进程称为一个作业</p>
<p>进程是在自身的虚拟地址空间运行的一个单独的程序。</p>
<p>三种进程：<strong>交互式进程、批处理进程、守护进程</strong></p>
<p>程序只是一个静态的命令几何，不占系统的运行资源，进程是一个随时都可能发生变化的、动态的、使用系统运行资源的程序</p>
<h4 id="进程查看"><a href="#进程查看" class="headerlink" title="进程查看"></a>进程查看</h4><p><code>ps命令</code>是最基本同时也是非常强大的进程查看命令。</p>
<p>使用该命令可以确定有哪些进程正在运行以及进程运行的状态、进程是否结束,进程有没有僵死,哪些进程占用了过多的资源等。</p>
<p>使用ps命令可以用于监控后台进程的工作情况。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ps -e 显示所有进程</span><br><span class="line">ps -aux 显示所有不带控制台终端的进程</span><br><span class="line">ps -ax|grep less 查看进程是否在进行</span><br><span class="line">ps -u xxx 查看xxx的进程</span><br><span class="line">ps -t tty1 显示tty1终端下的进程</span><br></pre></td></tr></table></figure>
<p><code>top命令</code>：显示当前正运行的进程及重要信息,包括它们的内存和CPU用量。（它其实是多种功能的复合，可以视作Windows的任务管理器）</p>
<h4 id="进程停止"><a href="#进程停止" class="headerlink" title="进程停止"></a>进程停止</h4><p>终止前台命令,[Ctrl+C]键</p>
<p>终止后台进程, kill命令</p>
<p>先用ps命令获得进程号，然后用kill命令终止</p>
<p>不能终止,可使用更有效的kill -9命令</p>
<p><code>kill -9 5975</code>：强制杀死进程号为5975的进程</p>
<h4 id="进程启动"><a href="#进程启动" class="headerlink" title="进程启动"></a>进程启动</h4><p>两种途径：手工启动和调度启动</p>
<p>1.手工启动</p>
<ul>
<li>前台启动</li>
<li>后台启动—在命令结尾加上一个 “&amp;”号</li>
</ul>
<p>2.调度启动</p>
<ul>
<li>事先进行设置，根据用户要求自行启动。任务可以被配置在指定的时间、指定的日期或系统平均负载量低于指定的数量时自动运行</li>
</ul>
<h4 id="进程挂起与恢复"><a href="#进程挂起与恢复" class="headerlink" title="进程挂起与恢复"></a>进程挂起与恢复</h4><p>挂起：[Ctrl+Z]键</p>
<p>显示shell作业清单：jobs命令</p>
<p>恢复：<code>fg</code>命令将挂起的作业放回前台执行</p>
<p><code>bg</code>命令将挂起的作业放回后台执行</p>
<h3 id="任务计划"><a href="#任务计划" class="headerlink" title="任务计划"></a>任务计划</h3><p>在固定的时间上触发某个作业，需要创建任务计划，按时执行该作业cron和at<br>cron命令被用来调度重复的任务<br>at命令被用来在指定时间内调度一次性的任务</p>
<ol>
<li><p>cron实现自动化</p>
<p>/etc/crontab文件实现</p>
<p>cron守护进程可在无需人工干预的情况下调度执行重复任务的守护进程</p>
<p>文件格式：分钟 小时 日期 月份 星期 执行的命</p>
</li>
<li><p>crontab命令实现</p>
<p>crontab [-u 用户名] –e //root用户创建或编辑crontab</p>
<p>crontab [-u 用户名] –l //root用户列出crontab文件</p>
<p>crontab [-u 用户名] –r //root用户删除crontab文件</p>
<p>crontab –e       //普通用户创建或编辑crontab</p>
<p>crontab –l       //普通用户列出crontab文件</p>
<p>crontab –r       //普通用户删除crontab文件</p>
<p>crontab   xxx //恢复丢失的crontab文件</p>
<p>编辑和创建的命令是一样的。但是编辑时root用户多了一个用vi直接编辑/var/pool/cron/文件的选择，普通用户是打不开的。</p>
</li>
<li><p>使用at实现自动化</p>
<p>一旦一个作业被提交，at命令将会保留所有当前的环境变量，包括路径，该作业的所有输出都将以电子邮件的形式发送给用户。</p>
<p>和crontab一样，root用户可以通过/etc目录下的at.allow和at.deny文件来控制哪些用户可以使用at命令</p>
</li>
</ol>
<h3 id="系统启动"><a href="#系统启动" class="headerlink" title="系统启动"></a>系统启动</h3><ol>
<li>BIOS自检</li>
</ol>
<p>计算机在接通电源之后首先由BIOS进行POST自检，然后依据BIOS内设置的引导顺序从硬盘、软盘或CDROM中读入引导块</p>
<ol start="2">
<li>启动GRUB 2</li>
</ol>
<p>GRUB 2 是引导加载程序，用于引导操作系统启动</p>
<ol start="3">
<li>加载内核</li>
</ol>
<p>加载内核映像到内存中</p>
<ol start="4">
<li>执行systemd进程</li>
</ol>
<p>systemd进程是系统所有进程的起点，内核在完成核内引导之后，即在本进程空间内加载systemd程序，它的进程号是1，失去了父进程的子进程就都会以systemd作为他们的父进程<br /></p>
<ol start="5">
<li>初始化系统环境</li>
</ol>
<p>使用systemd作为引导管理程序，之后的引导过程将由systemd完成<br /></p>
<ol start="6">
<li>执行/bin/login程序</li>
</ol>
<p>login程序会提示使用者输入账号及密码，接着编码并确认密码的正确性， 如果账号与密码相符，则为使用者初始化环境，并将控制权交给shell，即等待用户登录。<br /></p>
<h3 id="维护GRUB"><a href="#维护GRUB" class="headerlink" title="维护GRUB"></a>维护GRUB</h3><p>GRUB 2采用模块化动态加载的思想，相比GRUB来讲不 用在构建时将所有功能都加入<br /></p>
<h2 id="Ch12-Linux网络基本配置"><a href="#Ch12-Linux网络基本配置" class="headerlink" title="Ch12 Linux网络基本配置"></a>Ch12 Linux网络基本配置</h2><h3 id="网络命令"><a href="#网络命令" class="headerlink" title="网络命令"></a>网络命令</h3><p><img src="https://cynyard-blog-pics.oss-cn-beijing.aliyuncs.com/image/1600003657755-2510a040-2b3b-43c5-b8f3-da44a3edff72.png" alt="image.png">netstat：显示<strong>网络状态</strong>信息</p>
<p><strong>netstat -r :显示路由表信息</strong></p>
<p><strong>arp：增加、删除和显示arp缓存</strong></p>
<p>tcpdump：**可以监视TCP/IP连接,并直接读取数据链路层的数据包头,可以指定哪些数据包被监视以及哪些控制要显示格式（抓包）</p>
<p>tcpdump -i eno16777736</p>
<h3 id="管理网络服务的3种方式"><a href="#管理网络服务的3种方式" class="headerlink" title="管理网络服务的3种方式"></a>管理网络服务的3种方式</h3><p>启动或停止Linux系统服务</p>
<h4 id="systemctl命令"><a href="#systemctl命令" class="headerlink" title="systemctl命令"></a>systemctl命令</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl 选项 [服务名].service  `.service` 可以省略。</span><br></pre></td></tr></table></figure>
<p>命令中各选项的含义如下。</p>
<p><code>start</code>:表示启动服务。</p>
<p><code>stop</code>:表示停止服务。</p>
<p><code>status</code>:表示查看服务状态。</p>
<p><code>restart</code>:表示重新启动服务。</p>
<p><code>reload</code>:表示加载服务配置文件。</p>
<p><code>enable</code>:表示开机自动启动服务。</p>
<p><code>disable</code>:表示开机禁止启动服务。</p>
<p><code>is-enabled</code>:表示查看服务是否开机自动启动。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">list-units --<span class="built_in">type</span>=service:显示所有已启动的服务。</span><br></pre></td></tr></table></figure>

<h4 id="chkconfig和service命令"><a href="#chkconfig和service命令" class="headerlink" title="chkconfig和service命令"></a>chkconfig和service命令</h4><p>允许在不同运行级别启动和关闭服务的命令行工具</p>
<p><code>service命令</code>控制服务可以马上生效</p>
<p><code>chkconfig命令</code>控制服务需要等计算机重新启动后才会生效</p>
<h3 id="提高Linux系统安全性的一些方法"><a href="#提高Linux系统安全性的一些方法" class="headerlink" title="提高Linux系统安全性的一些方法"></a>提高Linux系统安全性的一些方法</h3><table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>部署防火墙</td>
<td>关闭不用的服务和端口</td>
</tr>
<tr>
<td>严格禁止设置默认路由</td>
<td>口令管理</td>
</tr>
<tr>
<td>分区管理</td>
<td>防范网络嗅探</td>
</tr>
<tr>
<td>完整的日志管理</td>
<td>使用安全工具软件（比如说SELinux）</td>
</tr>
<tr>
<td>使用保留的IP地址</td>
<td>部署Linux防病毒软件</td>
</tr>
<tr>
<td>加强登录安全</td>
<td>安装补丁</td>
</tr>
</tbody></table>
<h2 id="Ch13-远程连接服务器配置"><a href="#Ch13-远程连接服务器配置" class="headerlink" title="Ch13 远程连接服务器配置"></a>Ch13 远程连接服务器配置</h2><ul>
<li>使用ssh命令允许用户在远程计算机上登录并执行相关命令，建立在应用层和传输层基础上的安全协议</li>
<li>OpenSSH(Open Secure Shell)是SSH的替代软件，而且是免费的。默认使用RSA密钥，它采用安全、加密的网络连接工具代替 telnet、ftp、rlogin、rsh和rcp工具。</li>
<li>VNC，虚拟网络计算，可以用图形界面的方式连接到远程服务器，以达到远程控制。</li>
<li>配置NFS服务器可以让客户端挂载服务器上的共享目录，可以很方便地实现在同一网络上的多个用户间共享目标。</li>
</ul>
<h3 id="ssh"><a href="#ssh" class="headerlink" title="ssh"></a>ssh</h3><p><code>ssh -l [用户名] [远程主机IP地址]</code></p>
<p>或</p>
<p><code>ssh [用户名]@[远程主机IP地址]</code></p>
<p>/etc/ssh/sshd_config</p>
<h3 id="scp"><a href="#scp" class="headerlink" title="scp"></a>scp</h3><p>把本地文件传输到远程主机：</p>
<p><code>scp [本地文件] [用户名@远程主机IP地址:/目标文件]</code></p>
<p>把远程文件传输到本地主机：</p>
<p><code>scp [用户名@远程主机IP地址:/源文件] [本地文件]</code></p>
<h3 id="sftp"><a href="#sftp" class="headerlink" title="sftp"></a>sftp</h3><p>sftp [用户名@远程主机IP地址]</p>
<h3 id="VNC"><a href="#VNC" class="headerlink" title="VNC"></a>VNC</h3><p>服务端的VNC server和客户端的VNC viewer。用户需先将VNC server安装在被远程操控的计算机上后， 才能在主控端执行VNC viewer进行远程操控。</p>
<h2 id="Ch14-NFS服务器配置"><a href="#Ch14-NFS服务器配置" class="headerlink" title="Ch14 NFS服务器配置"></a>Ch14 NFS服务器配置</h2><p>NFS是一个文件系统， 而RPC是负责信息的传输。这样NFS服务器端与NFS客 户端才能由RPC协议来进行端口的对应。NFS主要管理 分享出来的目录，而至于文件的传递，就直接将它交给 RPC协议来运作。<br />字符界面配置NFS服务器</p>
<p>网络上的多个用户间共享目录和文件很有用途</p>
<p>在NFS服务器的主要配置文件/etc/exports中加一行：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[共享目录] [主机] (参数)</span><br></pre></td></tr></table></figure>
<p>主机：限定哪些计算机可以访问。</p>
<p>主机名或是该计算机的IP地址/使用通配符指定的域名/IP网络/Netgroups；</p>
<p>参数如 rw，sync，ro</p>
<p>开机自动挂载<code>192.168.0.100:/it /mnt/it nfs defaults 0 0</code> </p>
<h2 id="补充内容：LVM逻辑卷"><a href="#补充内容：LVM逻辑卷" class="headerlink" title="补充内容：LVM逻辑卷"></a>补充内容：LVM逻辑卷</h2><h3 id="LVM机制的基本概念"><a href="#LVM机制的基本概念" class="headerlink" title="LVM机制的基本概念"></a>LVM机制的基本概念</h3><p>Logical Volume Manager，逻辑卷管理</p>
<ul>
<li><p>它是Linux环境下对磁盘分区进行管理的一种机制</p>
</li>
<li><p>屏蔽了底层磁盘布局，便于动态调整磁盘容量<br />• 需要注意：/boot分区用于存放引导文件，不能应用LVM机制</p>
</li>
</ul>
<h3 id="PV（Physical-Volume，物理卷）"><a href="#PV（Physical-Volume，物理卷）" class="headerlink" title="PV（Physical Volume，物理卷）"></a>PV（Physical Volume，物理卷）</h3><p>整个硬盘，或使用fdisk等工具建立的普通分区，包括许多默认<strong>4MB</strong>（可设置）大小的PE（Physical Extent，基本单元）</p>
<h3 id="VG（Volume-Group，卷组）"><a href="#VG（Volume-Group，卷组）" class="headerlink" title="VG（Volume Group，卷组）"></a>VG（Volume Group，卷组）</h3><p>一个或多个物理卷组合而成的整体。</p>
<h3 id="LV（Logical-Volume，逻辑卷）"><a href="#LV（Logical-Volume，逻辑卷）" class="headerlink" title="LV（Logical Volume，逻辑卷）"></a>LV（Logical Volume，逻辑卷）</h3><p>从卷组中分割出的一块空间，用于建立文件系统。</p>
<h3 id="创建LVM分区"><a href="#创建LVM分区" class="headerlink" title="创建LVM分区"></a>创建LVM分区</h3><h4 id="新建空分区"><a href="#新建空分区" class="headerlink" title="新建空分区"></a>新建空分区</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">fdisk -c /dev/vdb</span><br><span class="line">n</span><br></pre></td></tr></table></figure>

<h4 id="初始化分区（创建PV物理卷）"><a href="#初始化分区（创建PV物理卷）" class="headerlink" title="初始化分区（创建PV物理卷）"></a>初始化分区（创建PV物理卷）</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">lvm</span><br><span class="line">pvcreate /dev/vdb2</span><br><span class="line">pvcreate /dev/vdb3</span><br><span class="line">pvdisplay</span><br></pre></td></tr></table></figure>

<h4 id="创建卷组"><a href="#创建卷组" class="headerlink" title="创建卷组"></a>创建卷组</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vgcreate –s [块大小] [卷组名] [物理卷1][物理卷2] [设备名]</span><br><span class="line">vgcreate -s 8M wgroup /dev/vdb2</span><br><span class="line">vgdisplay</span><br></pre></td></tr></table></figure>

<h4 id="创建逻辑卷"><a href="#创建逻辑卷" class="headerlink" title="创建逻辑卷"></a>创建逻辑卷</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">lvcreate -n [逻辑卷名] –L [逻辑卷大小] [已存在卷组名]</span><br><span class="line">lvcreate -n lv1 -L 100m wgroup</span><br><span class="line">lvdisplay</span><br></pre></td></tr></table></figure>
<blockquote>
<p>把大写的L换成小写的l时，后面逻辑卷大小对应的填VG中块的个数。当然无论如何，到最后大小都会是逻辑卷大小的整数倍。</p>
</blockquote>
<h4 id="创建文件系统及挂载"><a href="#创建文件系统及挂载" class="headerlink" title="创建文件系统及挂载"></a>创建文件系统及挂载</h4><p>这一部分和前面的一样。但是请注意逻辑卷的设备名。它是<code>/dev/[卷组名]/逻辑卷名</code> ！</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">fdisk -l</span><br><span class="line">mkfs -t ext4 /dev/wgroup/lv1</span><br></pre></td></tr></table></figure>

<h3 id="管理逻辑卷"><a href="#管理逻辑卷" class="headerlink" title="管理逻辑卷"></a>管理逻辑卷</h3><p>扩大/缩小：请注意操作顺序！</p>
<p>扩大时<strong>先扩大逻辑卷</strong>，然后<strong>再扩大文件系统空间</strong>；缩小时<strong>先缩小文件系统空间</strong>，<strong>后缩小逻辑卷</strong>（如果有必要的话）<img src="https://cynyard-blog-pics.oss-cn-beijing.aliyuncs.com/image/1599992580575-f426b19e-c507-46fb-9e15-45738a3f3c43.png" alt="image.png"></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">lvextend -L +[大小] /dev/[卷组名]/[逻辑卷名]</span><br><span class="line">lvreduce -L +[大小] /dev/[卷组名]/[逻辑卷名]</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">resize2fs –p /dev/[卷组名]/[逻辑卷名]</span><br></pre></td></tr></table></figure>
<p>注意到缩小文件系统时必须要先将逻辑卷卸载并确定数据使用量！（扩大文件系统时不用）</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">umount /dev/[卷组名]/[逻辑卷名]</span><br><span class="line">fsck -f /dev/[卷组名]/[逻辑卷名]</span><br></pre></td></tr></table></figure>

<h3 id="快照卷"><a href="#快照卷" class="headerlink" title="快照卷"></a>快照卷</h3><p>快照是临时保留所更改的逻辑卷的原始数据的逻辑卷。快照提供原始卷的静态视图，从而能够以一致状态备份其数据。<strong>但是快照本身是不断地在变化的</strong>。</p>
<h4 id="确定快照的大小"><a href="#确定快照的大小" class="headerlink" title="确定快照的大小"></a>确定快照的大小</h4><ol>
<li>预期更改率 2. 所需快照时间</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">lvcreate –s –n snaplv–L 20M /dev/vgname/lvname</span><br><span class="line">mkdir/snapmount</span><br><span class="line">mount –ro /dev/vgname/snaplv/snapmount</span><br><span class="line"><span class="comment"># 验证快照状态</span></span><br><span class="line">lvscan /dev/vgname/lvname</span><br><span class="line"><span class="comment"># 卸载快照</span></span><br><span class="line">umount /snapmount</span><br><span class="line">lvremove /dev/vgname/lvname</span><br></pre></td></tr></table></figure>
        </div>

        
            <section class="post-copyright">
                
                    <p class="copyright-item">
                        <span>Author:</span>
                        <span>Cynyard Qiu</span>
                    </p>
                
                
                
                

            </section>
        
        <section class="post-tags">
            <div>
                <span>Tag(s):</span>
                <span class="tag">
                    
                    
                        <a href="/tags/writing/"># writing</a>
                    
                        
                </span>
            </div>
            <div>
                <a href="javascript:window.history.back();">back</a>
                <span>· </span>
                <a href="/">home</a>
            </div>
        </section>
        <section class="post-nav">
            
                <a class="prev" rel="prev" href="/2020/09/21/Java-Reflection/">Java反射</a>
            
            
            <a class="next" rel="next" href="/2020/08/10/Cpp/">C++高级程序设计</a>
            
        </section>


    </article>
</div>

        </div>
        <footer id="footer" class="footer">
    <div class="copyright">
        <span>© Cynyard Qiu | Powered by <a href="https://hexo.io" target="_blank">Hexo</a> & <a href="https://github.com/Siricee/hexo-theme-Chic" target="_blank">Chic</a> 
        
        </span>
    </div>
</footer>

    </div>
</body>
</html>

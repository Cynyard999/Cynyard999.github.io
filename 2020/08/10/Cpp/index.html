<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
<meta name="viewport"
      content="width=device-width, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
<meta http-equiv="X-UA-Compatible" content="ie=edge">
<meta name="referrer" content="no-referrer">

    <meta name="author" content="Cynyard Qiu">





<title>C++高级程序设计 | Cynyard&#39;s Blog</title>



    <link rel="icon" href="/moon.ico">




    <!-- stylesheets list from _config.yml -->
    
    <link rel="stylesheet" href="/css/style.css">
    



    <!-- scripts list from _config.yml -->
    
    <script src="/js/script.js"></script>
    
    <script src="/js/tocbot.min.js"></script>
    



    
    
        
    


<meta name="generator" content="Hexo 5.3.0"></head>
<body>
    <div class="wrapper">
        <header>
    <nav class="navbar">
        <div class="container">
            <div class="navbar-header header-logo"><a href="/">Cynyard&#39;s Blog</a></div>
            <div class="menu navbar-right">
                
                    <a class="menu-item" href="/archives">Posts</a>
                
                    <a class="menu-item" href="/category">Categories</a>
                
                    <a class="menu-item" href="/tag">Tags</a>
                
                    <a class="menu-item" href="/about">About</a>
                
                <input id="switch_default" type="checkbox" class="switch_default">
                <label for="switch_default" class="toggleBtn"></label>
            </div>
        </div>
    </nav>

    
    <nav class="navbar-mobile" id="nav-mobile">
        <div class="container">
            <div class="navbar-header">
                <div>
                    <a href="/">Cynyard&#39;s Blog</a><a id="mobile-toggle-theme">·&nbsp;Light</a>
                </div>
                <div class="menu-toggle" onclick="mobileBtn()">&#9776; Menu</div>
            </div>
            <div class="menu" id="mobile-menu">
                
                    <a class="menu-item" href="/archives">Posts</a>
                
                    <a class="menu-item" href="/category">Categories</a>
                
                    <a class="menu-item" href="/tag">Tags</a>
                
                    <a class="menu-item" href="/about">About</a>
                
            </div>
        </div>
    </nav>

</header>
<script>
    var mobileBtn = function f() {
        var toggleMenu = document.getElementsByClassName("menu-toggle")[0];
        var mobileMenu = document.getElementById("mobile-menu");
        if(toggleMenu.classList.contains("active")){
           toggleMenu.classList.remove("active")
            mobileMenu.classList.remove("active")
        }else{
            toggleMenu.classList.add("active")
            mobileMenu.classList.add("active")
        }
    }
</script>
        <div class="main">
            <div class="container">
    
    
        <div class="post-toc">
    <div class="tocbot-list">
    </div>
    <div class="tocbot-list-menu">
        <a class="tocbot-toc-expand" onclick="expand_toc()">Expand all</a>
        <a onclick="go_top()">Back to top</a>
        <a onclick="go_bottom()">Go to bottom</a>
    </div>
</div>

<script>
    document.ready(
        function () {
            tocbot.init({
                tocSelector: '.tocbot-list',
                contentSelector: '.post-content',
                headingSelector: 'h1, h2, h3, h4, h5',
                collapseDepth: 1,
                orderedList: false,
                scrollSmooth: true,
            })
        }
    )

    function expand_toc() {
        var b = document.querySelector(".tocbot-toc-expand");
        tocbot.init({
            tocSelector: '.tocbot-list',
            contentSelector: '.post-content',
            headingSelector: 'h1, h2, h3, h4, h5',
            collapseDepth: 6,
            orderedList: false,
            scrollSmooth: true,
        });
        b.setAttribute("onclick", "collapse_toc()");
        b.innerHTML = "Collapse all"
    }

    function collapse_toc() {
        var b = document.querySelector(".tocbot-toc-expand");
        tocbot.init({
            tocSelector: '.tocbot-list',
            contentSelector: '.post-content',
            headingSelector: 'h1, h2, h3, h4, h5',
            collapseDepth: 1,
            orderedList: false,
            scrollSmooth: true,
        });
        b.setAttribute("onclick", "expand_toc()");
        b.innerHTML = "Expand all"
    }

    function go_top() {
        window.scrollTo(0, 0);
    }

    function go_bottom() {
        window.scrollTo(0, document.body.scrollHeight);
    }

</script>
    

    
    <article class="post-wrap">
        <header class="post-header">
            <h1 class="post-title">C++高级程序设计</h1>
            
                <div class="post-meta">
                    
                        Author: <a itemprop="author" rel="author" href="/">Cynyard Qiu</a>
                    

                    
                        <span class="post-time">
                        Date: <a href="#">August 10, 2020&nbsp;&nbsp;0:14:00</a>
                        </span>
                    
                    
                        <span class="post-category">
                    Category:
                            
                                <a href="/categories/Course/">Course</a>
                            
                        </span>
                    
                    
                </div>
            
        </header>

        <div class="post-content">
            <p>课程笔记</p>
<h1 id="Part1-Fundamentals"><a href="#Part1-Fundamentals" class="headerlink" title="Part1 Fundamentals"></a>Part1 Fundamentals</h1><h2 id="History"><a href="#History" class="headerlink" title="History"></a>History</h2><blockquote>
<p>与可能出现的错误相比，更重要的是能做什么好的事情。Programmers needs to be trusted</p>
</blockquote>
<ol>
<li><p>演化历程</p>
<ol>
<li>C 语言是贝尔实验室的 Dennis Ritchie 在 B 语言的基础上开发出来的。C 语言作为 UNIX操作系统的开发语言而广为人知;Dennis Ritchie 和 Ken Thompson 并称为 C 语言之父</li>
<li>为了满足管理程序的复杂性需要，1980 年，贝尔实验室的 Bjarne Stroustrup 开始对 C语言进行改进和扩充，形成了“C with class”;</li>
<li>1983 年 Rick Mascitti 将其正式命名为“C++”;</li>
<li>1994 年制定了 ANSI C++标准的草案;</li>
</ol>
</li>
<li><p>C与Cpp的关系</p>
<ol>
<li>C++完全包含C语言成分（C的超集），C是建立C++的基础，同时C++还添加了OOP的完全支持</li>
<li>C++支持C所支持的全部编程技巧</li>
<li>任何C程序都能被C++用基本相同的方法编写，并且具有相同的运行效率和空间</li>
<li>C++中允许在结构和联合中定义函数，他们也具有类的基本功能                                </li>
</ol>
</li>
<li><p>C与Cpp混合变成需要注意的问题</p>
<ol>
<li>C是结构化语言，C++支持面向编程语言，所以在混合编程的时候不应该出现class等面向对象的关键字</li>
<li>如果要调用C语言库中的函数，需要附加关键字<code>extern &quot;C&quot;</code></li>
<li>C语言不支持函数重载，在 C++中 f (int, int) 与 f(int, double) 是不同的函数，都重载了 函数 f();但是在 C 语言中却被认为是相同的函数。因为在编译时，C 语言给这几个函数的 命名为 f_;而 C++命名分别为 f_int_int, f_int_double, f_，以表示区别;所以混合编程时应注意重载函数的问题；</li>
<li>表达式的求值顺序与副作用，不同的编辑器表达式的求值顺序也不同，可能带来副作用的问题</li>
</ol>
</li>
</ol>
<h2 id="Data"><a href="#Data" class="headerlink" title="Data"></a>Data</h2><ol>
<li>静态类型语言与强类型语言<ol>
<li>静态：在写程序时要声明所有变量的数据类型</li>
<li>强类型（上课说的）：一旦一个变量被指定了某个数据类型，如果不经过强制转换，那么它就永远是这个数据类型了，数据有更多的约束</li>
<li>弱类型：</li>
</ol>
</li>
<li>基本数据类型</li>
</ol>
<img src="https://cynyard-blog-pics.oss-cn-beijing.aliyuncs.com/image/1597994257540-ba1eabe9-6913-4f1a-8f59-5eed14491f43.png" alt="image.png" style="zoom:33%;" />

<ol start="3">
<li>typedef：为已有的类型定义一个同义词</li>
</ol>
<h2 id="表达式"><a href="#表达式" class="headerlink" title="表达式"></a>表达式</h2><ol>
<li>影响表达式求值的因素：<ol>
<li>优先级：不同运算符号的优先级</li>
<li>结合性：例如a+b-c，左结合</li>
<li>求值次序：括号优先，不相邻的两个运算符的运算次序由操作系统决定</li>
<li>类型转换约定，int x = 10, float y = 2.0 x*y得到float类型的数</li>
</ol>
</li>
</ol>
<h2 id="语句"><a href="#语句" class="headerlink" title="语句"></a>语句</h2><ol>
<li>switch语句优化，表驱动<ol>
<li>表的行就可以是switch当中的case语句（可以用enum修饰），列就是对应的case里面需要完成的事情，比如说打印的语句，执行的函数指针，举例如下图</li>
</ol>
</li>
</ol>
<img src="https://cynyard-blog-pics.oss-cn-beijing.aliyuncs.com/image/1597995146745-4ac13a4e-6b64-454c-b5c5-cededefbe740.png" alt="image.png" style="zoom: 50%;" />

<ol start="2">
<li>分类：<ol>
<li>表达式语句</li>
<li>IO语句</li>
<li>控制流语句</li>
</ol>
</li>
</ol>
<h2 id="table-driven"><a href="#table-driven" class="headerlink" title="table driven"></a>table driven</h2><ol>
<li>数组实现，Map实现</li>
<li>从表里查询信息来代替逻辑语句(if,case)，减少比较，减少冗余代码</li>
<li>一目了然</li>
</ol>
<p><img src="https://cynyard-blog-pics.oss-cn-beijing.aliyuncs.com/image/1597995419320-fddca77e-c49c-4938-b665-f65bc84632e2.png" alt="image.png"></p>
<h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><ol>
<li>原则：先定义后使用，定义不允许嵌套</li>
<li>默认参数</li>
<li>执行机制：stdcall，调用者申请空间，被调用者归还，成为公共空间，调用者之后就不管了<ol>
<li>建立被调用函数的栈空间</li>
<li>参数传递<ul>
<li>值传递</li>
</ul>
</li>
</ol>
</li>
</ol>
<p>copy一个与传入参数一样的值，对这个值的操作不会影响到原来的值</p>
<ul>
<li>引用传递</li>
</ul>
<p>引用就相当于传入的那个数的别名，对这个引用的所有操作，就是对原来那个值的操作</p>
<ul>
<li>指针传递</li>
</ul>
<p>传递一个值的指针p，其中这个指针的值就是传入参数的地址，需要使用*p来操作这个指针</p>
<ol>
<li>保存调用函数的运行状态</li>
<li>控制权转交被调函数</li>
<li>释放被调函数中局部变量占用的栈空间</li>
<li>回复现场：取主调函数运行状态及返回地址，释放栈空间；</li>
<li>函数重载</li>
<li>inline函数<ol>
<li>使用频率高的小段代码</li>
<li>编译系统将为inline函数创建一段代码，每次调用的时候，用相应的代码替换，不会产生转去转回的问题，可见它是以目标代码的增加为代价来换取时间的节省</li>
<li>限制：<ol>
<li>内联函数要在函数被调用之前声明</li>
<li>非递归</li>
<li>编译系统控制</li>
<li>inline函数只是对编译器的建议，是否对函数内联，决定权在于编译器，用inline向编译系统申请，能做编译器才会做，不能做一定会付出代价</li>
</ol>
</li>
<li>建议：<ol>
<li>仅对使用频率较高的小段代码使用内联，一般行数应不超过 5 行;</li>
<li>将内联函数的定义放到头文件中;</li>
<li>在内联函数中不能含有复杂的结构控制语句，如 switch、while 等;</li>
<li>递归函数不能用来做内联函数</li>
</ol>
</li>
<li>问题：<ol>
<li>增大目标代码，因为在调用时，必须在调用该函数的每个文本文件中定义</li>
<li>病态换页</li>
<li>降低指令快取装置的命中率;</li>
</ol>
</li>
</ol>
</li>
<li>静态局部变量：作用域是函数，生命周期是在整个函数调用中，不存在于栈中，static函数中</li>
</ol>
<h2 id="stack-and-heap"><a href="#stack-and-heap" class="headerlink" title="stack and heap"></a>stack and heap</h2><ol>
<li>stack：编译器自动分配与释放，存放函数的参数值，局部变量，返回地址等等<ol>
<li>静态区（全局区）：全局变量和静态变量的存储，初始化的在一块区域，未初始化的在另外一个区域</li>
</ol>
</li>
<li>heap：程序员分配和释放，存放new的一些内存块，一般一个new对应一个delete，否则等OS来自动回收</li>
</ol>
<h2 id="struct"><a href="#struct" class="headerlink" title="struct"></a>struct</h2><ol>
<li>主要作用就是封装</li>
<li>C++中的结构体与类的区别：<ul>
<li>class中默认的成员访问权限是private的，而struct中则是public的。</li>
<li>class继承默认是private继承，而从struct继承默认是public继承。</li>
</ul>
</li>
</ol>
<h2 id="union"><a href="#union" class="headerlink" title="union"></a>union</h2><ol>
<li>共享存储空间</li>
<li>同一个内存段存放几种不同类型的数据。注意：在每一瞬时只能存放其中一种，而不是同时存放多种。换句话说，每一瞬时只有一个成员起作用，其他成员不起作用。</li>
<li>共用体变量所占的内存长度等于最长的成员的长度。</li>
<li>能够访问的是共用体变量中最后一次被赋值的成员，在对一个新的成员赋值后原有的成员就失去作用。因此在引用共用体变量时应注意当前在共用体变量中起作用的是哪个成员。</li>
</ol>
<h2 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h2><ol>
<li>定义：存储变量的地址<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span>* pointer</span><br><span class="line">pointer p,q;</span><br><span class="line">p = <span class="number">0x080483A0</span>;</span><br><span class="line"><span class="keyword">int</span> x = <span class="number">10</span>;</span><br><span class="line">q = &amp;x;</span><br><span class="line"><span class="keyword">void</span> * t = q;<span class="comment">//为所有指针定义一个公共接口，可以用任意类型的指针对void赋值</span></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;*(<span class="keyword">int</span> * t)&lt;&lt;<span class="built_in">endl</span>;<span class="comment">//需要把void指针指向其他类型的时候，需要强制类型转换</span></span><br></pre></td></tr></table></figure></li>
<li>常量指针与指针常量<ol>
<li>常量指针<ul>
<li><code>const int *p</code> 指针可以指向不同的变量的地址，但是指针指向的变量的内容不能改变（不能通过指针改变所指向的变量的内容），对于一个const变量，只能使用有const前缀的指针</li>
</ul>
</li>
<li>指针常量 <code>int * const p</code> 必须在定义的时候初始化，只能是一开始指向的那个变量的地址，但是对应的变量可以变化</li>
</ol>
</li>
<li>函数指针</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">float</span> <span class="title">add</span><span class="params">(<span class="keyword">float</span> a,<span class="keyword">float</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%f\n&quot;</span>,a+b);</span><br><span class="line">    <span class="keyword">return</span> a+b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">float</span> <span class="title">minu</span><span class="params">(<span class="keyword">float</span> a,<span class="keyword">float</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%f\n&quot;</span>,a-b);</span><br><span class="line">    <span class="keyword">return</span> a-b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">float</span><span class="params">(*pfunType)</span><span class="params">(<span class="keyword">float</span>, <span class="keyword">float</span>)</span></span>;</span><br><span class="line">pfunType p = &amp;add;<span class="comment">//定义函数指针变量</span></span><br><span class="line"><span class="keyword">float</span> (*pfunType[<span class="number">2</span>])(<span class="keyword">float</span>, <span class="keyword">float</span>) = &#123;&amp;add, &amp;minu&#125;;</span><br><span class="line">...;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fun1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;this is fun1 call\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun2</span><span class="params">(<span class="keyword">int</span> k, <span class="keyword">char</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;this is fun2 call:%d %c\n&quot;</span>, k, c);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> (*pfun1)() = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">void</span> (*pfun2)(<span class="keyword">int</span>, <span class="keyword">char</span>) = <span class="literal">NULL</span>;</span><br><span class="line">pfun1 = fun1; <span class="comment">//第一种赋值方法</span></span><br><span class="line">pfun2 = &amp;fun2;<span class="comment">//第二种赋值方法（推荐，因为和其他数据指针赋值方法一致）</span></span><br></pre></td></tr></table></figure>

<h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><ol>
<li>指针与数组<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a[<span class="number">12</span>]</span><br><span class="line"><span class="keyword">int</span> *p = a;</span><br><span class="line"><span class="keyword">int</span> *q = &amp;a[<span class="number">0</span>]</span><br><span class="line"><span class="keyword">bool</span> isEqual = p == q<span class="comment">//true</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> T[<span class="number">2</span>];<span class="comment">//一个T有两个int，一个a有6个T</span></span><br><span class="line">T a[<span class="number">6</span>];对应的就是a[<span class="number">6</span>][<span class="number">2</span>]</span><br></pre></td></tr></table></figure></li>
<li>二维数组的呈现（数组存放的元素是顺序存放，然后指针与指向指针的指针有两层的关系</li>
</ol>
<p><img src="https://cynyard-blog-pics.oss-cn-beijing.aliyuncs.com/image/1598001625176-da13dce5-9cbd-47a6-a154-0d1770c5fd3f.png" alt="image.png"></p>
<h2 id="动态变量"><a href="#动态变量" class="headerlink" title="动态变量"></a>动态变量</h2><ol>
<li>用指针+new对动态变量初始化</li>
<li>存储在堆中，不需要的时候需要delete，注意如果指针指向的是一个东西，那就delete p，如果是一个数组，就<strong>delete []p</strong></li>
<li>动态内存分配<ol>
<li>问题：如果内存空间很大，数据却很少就会使内存空间浪费。如果内存空间不足就会出现溢出的现象。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>* p = <span class="literal">nullptr</span>;</span><br><span class="line">p = (<span class="keyword">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>)* <span class="number">25</span>);<span class="comment">//malloc返回void*类型的指针，需要强制类型转换，这里是申请一个25int大小的内存空间</span></span><br><span class="line"><span class="built_in">free</span>(p);<span class="comment">//最后释放空间</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">realloc</span><span class="params">(<span class="keyword">void</span> *ptr, <span class="keyword">size_t</span> new_size)</span></span>;<span class="comment">//扩容或者缩小</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">realloc</span><span class="params">(<span class="keyword">size_t</span> new_size)</span></span>;<span class="comment">//与malloc一样</span></span><br></pre></td></tr></table></figure>

</li>
</ol>
</li>
</ol>
<h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><ol>
<li>为一块已有的内存空间取一个别名，通过引用类型可以定义一个变量，它与另一个变量占用 相同的内存空间</li>
<li>作用：引用主要用于函数的形式参数和动态变量名</li>
<li>返回引用：当函数返回引用类型时，没有复制返回值。相反,返回对象本身。</li>
<li>限制：<ol>
<li>用conts限定引用<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span> <span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> &amp;a, <span class="keyword">const</span> <span class="keyword">int</span> &amp;b)</span></span>;</span><br></pre></td></tr></table></figure></li>
<li>在堆中释放引用<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> *p = <span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">100</span>);</span><br><span class="line"><span class="keyword">int</span> &amp;x = *p;</span><br><span class="line">...;</span><br><span class="line"><span class="keyword">delete</span> &amp;x;</span><br></pre></td></tr></table></figure>

</li>
</ol>
</li>
</ol>
<h2 id="问题："><a href="#问题：" class="headerlink" title="问题："></a>问题：</h2><ol>
<li><p>当类中未自主定义构造函数，compiler会提供默认构造函数，Why?，这个时候编译器会怎么做？</p>
</li>
<li><p>When构造函数、析构函数被定义为private? </p>
<p>构造函数声明为private，希望通过static方法获得这个类的唯一对象，不能使用new构造一个对象</p>
<p>析构函数声明为private，在栈上分配空间，类在离开作用域时会调用析构函数释放空间，此时无法调用私有的析构函数，希望对象只能创建在堆上。</p>
</li>
<li><p>友元、static成员的使用，When?</p>
<ul>
<li><p>类的外部不能访问类的私有成员或者protected成员</p>
</li>
<li><p>同一个类的不同对象共享变量</p>
</li>
</ul>
</li>
<li><p>Why引入成员初始化表?</p>
<ul>
<li><p>构造函数的补充，减轻编译器的负担，尽量采用初始化表代表赋值动作（除非数据成员太多）</p>
</li>
<li><p>类类型成员放在初始化列表里，可明显提高效率。也就是说，调用构造函数的时候，先创建对象，再进入函数体。若不使用初始化成员列表会浪费一次赋值机会，进入函数体后另外赋值。</p>
</li>
</ul>
</li>
<li><p>Why初始化表执行次序只与类数据成员的定义次序相关?</p>
<ul>
<li><p>构造函数的执行可以分成两个阶段，初始化阶段和计算阶段，初始化阶段先于计算阶段。</p>
</li>
<li><p>所有类类型（class type）的成员都会在初始化阶段初始化，即使该成员没有出现在构造函数的初始化列表中。这是与声明次序有关的</p>
</li>
<li><p>成员按它们在初始化列表上出现的顺序被初始化发生，编译器就要为每一个对象跟踪其成员初始化的顺序，以保证它们的析构函数以正确的顺序被调用。这会带来昂贵的开销。同一种类型的所有对象在创建（构造）和摧毁（析构）过程中对成员的处理顺序都是相同的,而不管成员在初始化列表中的顺序如何。</p>
</li>
</ul>
</li>
<li><p>Why引入拷贝构造函数？</p>
<ul>
<li><p>创建对象的时候，用同一类的对象将其初始化**</p>
</li>
<li><p>一个对象以值进入一个函数体，在对象传递给某一函数之前，对象的一些属性可能已经被改变了，不是刚创建的状态，如果在产生对象副本的时候再执行对象的构造函数，那么这个对象的属性又再恢复到原始状态，所以<strong>产生对象副本的时候，用拷贝构造来创建</strong></p>
</li>
<li><p>从函数返回时复制一个对象；**</p>
</li>
</ul>
</li>
<li><p>= 操作符重载?</p>
<ul>
<li><p>有时候希望赋值运算符两边的类型可以不匹配，比如说char*类型的字符串赋值给字符串对象</p>
</li>
<li><p>赋值运算符“=”只能重载为成员函数</p>
</li>
</ul>
</li>
<li><p>What is Late Binding? </p>
<ul>
<li><p>运行时才确定对象的方法或者函数。动态绑定</p>
</li>
<li><p>在C++，late binding通常发生在关键字vitrual用于函数声明时，C++会创建虚拟函数表。当虚函数调用时，系统会查询虚拟函数表，来确定调用函数。这也是C++实现多态的机制。</p>
</li>
</ul>
</li>
<li><p>How C++implement vitural ?</p>
<ul>
<li><p>派生类不能改变virtual现状，基类函数没有virtual的时候派生类不能声明成有，基类有virtual的时候派生类声明不声明都一样。</p>
</li>
<li><p>这里用到了VTABLE虚函数表，当编译器发现一个类有虚函数时就会建立这样一个表，一个类对应一个VTABLE，和对象无关。</p>
</li>
<li><p>因为这样指针指到哪个对象都能通过这个对象对应的类的VTABLE找到想要的信息</p>
</li>
</ul>
</li>
<li><p>When we use virtual ?</p>
<ul>
<li>虚函数是指一个类中你希望重载的成员函数 ，当你用一个  基类指针或引用   指向一个继承类对象的时候，调用一个虚函数时, 实际调用的是继承类的版本</li>
</ul>
</li>
<li><p>What public继承和non-public继承means?</p>
<ul>
<li><p>public：基类的公有成员和保护成员作为派生类的成员时，它们都保持原有的状态，而基类的私有成员仍然是私有的，不能被这个派生类的子类所访问。</p>
</li>
<li><p>protected：保护继承的特点是基类的所有公有成员和保护成员都成为派生类的保护成员，并且只能被它的派生类成员函数或友元访问，基类的私有成员仍然是私有的。</p>
</li>
<li><p>private：基类的公有成员和保护成员都作为派生类的私有成员，并且不能被这个派生类的子类所访问。</p>
</li>
</ul>
</li>
<li><p>Why= () [] -&gt;不能作为全局函数重载?</p>
<ul>
<li><p>类的this指针会被绑定到运算符的左侧运算对象，成员运算符函数的显示参数比运算符对象总数少一个</p>
</li>
<li><p>编译器发现当类中没有定义这3个运算符的重载成员函数时，就会自己加入默认的运算符重载成员函数。</p>
</li>
<li><p>C++一个类本身对这几个运算符已经有相应的解释了</p>
</li>
</ul>
</li>
<li><p>When成员函数<strong>能</strong>返回&amp; ?</p>
<ul>
<li><p>函数体内局部对象是不能被引用的，因为函数调用完局部对象会被释放。</p>
</li>
<li><p>可以返回传入参数的引用</p>
</li>
<li><p>用引用作函数的返回值的最大的好处是在内存中不产生返回值的副本</p>
</li>
</ul>
</li>
<li><p>When and How to 重载new、delete?</p>
<ul>
<li><p>比如你想对内存的分配策略进行自定义管理或者你想监测堆内存的分配情况或者你想做堆内存的内存泄露监控等</p>
</li>
<li><p>想对某个类的堆内存分配的对象做特殊处理</p>
</li>
</ul>
</li>
<li><p>how to</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> * <span class="keyword">operator</span> <span class="title">new</span> <span class="params">(<span class="keyword">size_t</span> size,...)</span></span>;<span class="comment">//...为其他参数,返回一个void指针</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="keyword">void</span>* p,<span class="keyword">size_t</span> size)</span></span>;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h1 id="Part2-Function"><a href="#Part2-Function" class="headerlink" title="Part2 Function"></a>Part2 Function</h1><h2 id="OO-Programming"><a href="#OO-Programming" class="headerlink" title="OO Programming"></a>OO Programming</h2><ol>
<li>概念：程序由多个对象组成，一个对象就是指数据和操作，用函数调用完成消息传递，通常用类表示Object</li>
<li>分类：</li>
</ol>
<ul>
<li>面向对象：封装，继承，多态</li>
<li>基于对象</li>
</ul>
<ol start="3">
<li>评估：产品在规定的条件下和规定的时间内完成规定功能的能力</li>
</ol>
<h2 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h2><p>编译器自动写的类：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Empty</span> &#123;</span> &#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Empty</span> &#123;</span> </span><br><span class="line">    Empty();<span class="comment">//构造</span></span><br><span class="line">	Empty(<span class="keyword">const</span> Empty&amp;);<span class="comment">//拷贝构造</span></span><br><span class="line">	~Empty();<span class="comment">//析构</span></span><br><span class="line">	Empty&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> Empty&amp;); <span class="comment">//赋值操作符</span></span><br><span class="line">    Empty *<span class="keyword">operator</span> &amp;();<span class="comment">//取地址符号 Empty *pe1 = &amp;e1;</span></span><br><span class="line">	<span class="keyword">const</span> Empty* <span class="keyword">operator</span> &amp;() <span class="keyword">const</span>; <span class="comment">//const版本取地址符 const Empty *pe2 = &amp;e2;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ol>
<li>对象的初始化</li>
<li>定义：<ol>
<li>与类同名，没有返回类型，自动调用，可重载</li>
</ol>
</li>
<li>默认构造函数：当类中没有提供构造函数的时候，编译器<strong>按照需要</strong>提供<ol>
<li>数据成员都是基本数据类型，编译器不会合成一个默认构造函数。这是没有必要的</li>
<li>编译器什么时候<ol>
<li>类成员中有成员是类对象，并且该成员的类含有默认构造函数，那么C++编译器会给这个类也生成一个默认构造函数，用来调用其成员对象的构造函数，完成该成员的初始化构造。需要强调的是，如果这个成员的类也没有给出默认构造函数，那么C++编译器也不会帮你生成该类的默认构造函数。</li>
<li>类的基类有默认构造函数。生成该派生类的默认构造函数，以调用基类的默认构造函数，完成基类的初始化。如果基类没有提供这个默认构造的函数，那么C++编译器也不会为派生类生成默认的构造函数（这里包括两层意思，第一，基类没有任何形式构造函数；第二，基类存在其他形式的非默认构造函数，当然了，这种类型就是编译不过的，道理很明显）。</li>
<li>类中存在虚函数，生成默认构造函数，以初始化虚表(虚函数表vftable)。</li>
<li>存在虚基类，那么C++编译器会为你生成默认构造函数，以初始化虚基类表(vbtable)。</li>
</ol>
</li>
</ol>
</li>
<li>成员初始化表<ol>
<li>构造函数的补充</li>
<li>先于构造函数体，按照<strong>类数据成员声明次序</strong>，减轻编译器的负担，尽量<strong>采用初始化表代表赋值动作（除非数据成员太多）</strong><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">    <span class="keyword">int</span> &amp;z;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    	A():y(<span class="number">1</span>),z(x),x(<span class="number">0</span>)&#123;x=<span class="number">100</span>&#125;<span class="comment">//最终x会是100</span></span><br><span class="line">    	A(<span class="keyword">int</span> m)&#123;x = m&#125;</span><br><span class="line">&#125;;</span><br><span class="line">Class B&#123;</span><br><span class="line">	<span class="keyword">int</span> x;</span><br><span class="line">    A a;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    	B()&#123; x = <span class="number">0</span>; &#125;<span class="comment">//调用B()和A()</span></span><br><span class="line">		B(<span class="keyword">int</span> x1) &#123; x = x1; &#125;<span class="comment">//B(int) and A()</span></span><br><span class="line">		B(<span class="keyword">int</span> x1, <span class="keyword">int</span> x2): a(x2) &#123; x = x1;&#125;<span class="comment">//B(int,int) and   </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
</li>
</ol>
<h2 id="析构函数"><a href="#析构函数" class="headerlink" title="析构函数"></a>析构函数</h2><ol>
<li>对象消亡的时候，系统自动调用</li>
<li>问题：<ol>
<li>但默认生成的析构函数只能释放非内存资源, 无法释放通过 new 或 malloc 进行申请的空间, 所以需要显式定义析构函数对这些申请的空间进行释放, 避免造成内存泄露。</li>
</ol>
</li>
<li>private：想在堆中创建对象，必须找到一种方法禁止以调用“new”以外的其它手段建立对象。由于非堆对象(non-heap object)栈对象在定义它的地方被自动构造，在生存时间结束时自动被释放，所以只要禁止使用隐式的析构函数，就可以实现这种限制。<ol>
<li>禁止用户对此类型的变量进行重复定义。//不确定</li>
<li>只能在堆上声明</li>
<li>禁止用户在程序中使用delete删除此类型对象。</li>
</ol>
</li>
</ol>
<h2 id="构造拷贝函数"><a href="#构造拷贝函数" class="headerlink" title="构造拷贝函数"></a>构造拷贝函数</h2><ol>
<li>创建对象的时候，用同一类的对象将其初始化</li>
<li>自动调用</li>
<li>默认拷贝构造函数：复制所有的值<ol>
<li>如果包含成员对象的拷贝，就会递归调用成员对象的拷贝构造函数</li>
</ol>
</li>
<li>自定义拷贝构造函数：按需要拷贝<ol>
<li>如果包含成员对象的拷贝，就会递归调用成员对象的默认拷贝构造函数</li>
</ol>
</li>
<li>没有任何声明，只会隐式调用默认的拷贝构造函数</li>
</ol>
<h2 id="动态对象"><a href="#动态对象" class="headerlink" title="动态对象"></a>动态对象</h2><ol>
<li>使用new和delete在堆中创建<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>* <span class="keyword">int</span> ptr = <span class="keyword">new</span> <span class="keyword">int</span>;</span><br><span class="line">Car* carPtr = <span class="keyword">new</span> Car(<span class="string">&quot;Benz&quot;</span>);</span><br><span class="line">A *p = (A*) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(A));</span><br><span class="line">A *p = <span class="keyword">new</span> A[<span class="number">100</span>];</span><br><span class="line"><span class="keyword">delete</span> []p;</span><br><span class="line"><span class="comment">/* 动态二维数组 */</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> ROWS = <span class="number">3</span>; <span class="keyword">const</span> <span class="keyword">int</span> COLUMNS = <span class="number">4</span>;</span><br><span class="line"><span class="keyword">char</span> **chArray2;</span><br><span class="line">chArray2 = <span class="keyword">new</span> <span class="keyword">char</span>* [ ROWS ];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> row = <span class="number">0</span>; row &lt; ROWS; row++ )</span><br><span class="line">    chArray2[ row ] = <span class="keyword">new</span> <span class="keyword">char</span>[ COLUMNS ];</span><br><span class="line">	<span class="keyword">delete</span> [ ] chArray2[ row ];<span class="comment">//删除这些指针指向的对象</span></span><br><span class="line">   	chArray2[ row ] = <span class="literal">nullptr</span>;<span class="comment">//指针设置为nullptr</span></span><br><span class="line"><span class="keyword">delete</span>[] chArray2;</span><br><span class="line">chArray2 = <span class="literal">nullptr</span>;</span><br></pre></td></tr></table></figure>
<h2 id="重载，重写，覆盖"><a href="#重载，重写，覆盖" class="headerlink" title="重载，重写，覆盖"></a>重载，重写，覆盖</h2></li>
</ol>
<h2 id="成员"><a href="#成员" class="headerlink" title="成员"></a>成员</h2><ol>
<li>const成员<ol>
<li>const成员函数<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> x,y;</span><br><span class="line">    <span class="keyword">int</span> &amp;z;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line">...;</span><br><span class="line"><span class="keyword">void</span> A::f()</span><br><span class="line">&#123; x=<span class="number">1</span>;y=<span class="number">1</span>;&#125;<span class="comment">//void f( A * const this);</span></span><br><span class="line"><span class="keyword">void</span> A::show() <span class="keyword">const</span> </span><br><span class="line">&#123; cout &lt;&lt;x &lt;&lt; y;&#125;<span class="comment">//void show(const A* const this);</span></span><br><span class="line"><span class="keyword">void</span> A::g()<span class="keyword">const</span></span><br><span class="line">&#123;z++;&#125;</span><br><span class="line">...;</span><br><span class="line"><span class="function"><span class="keyword">const</span> A <span class="title">a</span><span class="params">(<span class="number">0</span>,<span class="number">0</span>,x)</span></span>;</span><br><span class="line">a.f();<span class="comment">//不能调用，因为A是const类型，本身不能修改</span></span><br><span class="line">a.show();<span class="comment">//可以调用</span></span><br><span class="line">a.g();<span class="comment">//可以跑</span></span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li>static成员：同一个类的不同对象共享变量<ol>
<li>成员函数，只能存取静态成员变量，调用静态成员函数<ol>
<li>通过对象使用 <code>A a;a.f();</code> </li>
<li>通过类使用 <code>A::f()</code> </li>
</ol>
</li>
</ol>
</li>
</ol>
<h2 id="友元"><a href="#友元" class="headerlink" title="友元"></a>友元</h2><ol>
<li>类外部不能访问该类的private成员，解决<ol>
<li>通过public方法访问</li>
<li>友元访问</li>
</ol>
</li>
<li>分类：<ol>
<li>友元函数</li>
<li>友元类</li>
<li>友元类成员函数</li>
</ol>
</li>
<li>使用<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">()</span> </span>; </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>;</span> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span></span></span><br><span class="line"><span class="class">&#123;</span> ...</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span>; &#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span>...</span><br><span class="line">	<span class="function"><span class="keyword">friend</span> <span class="keyword">void</span> <span class="title">func</span><span class="params">()</span></span>; <span class="comment">//友元函数，前面不用生命</span></span><br><span class="line">	<span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">B</span>;</span> <span class="comment">//友元类，前面的声明不是必须的</span></span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="keyword">void</span> <span class="title">C::f</span><span class="params">()</span></span>;<span class="comment">//友元类成员函数，前面需要声明</span></span><br><span class="line">  &#125;;</span><br></pre></td></tr></table></figure></li>
<li>注意<ol>
<li>友元不具有传递性</li>
<li>友元函数或者友元类成员函数中的参数必须提前声明</li>
<li><img src="https://cynyard-blog-pics.oss-cn-beijing.aliyuncs.com/image/1598009727635-224c2b5a-be2a-4cb1-b64e-7603ff234ade.png" alt="image.png"></li>
</ol>
</li>
</ol>
<h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><ol>
<li>继承方式<ol>
<li>public</li>
<li>private：把原来的public换成private，但是原来的private还是不能访问，没有权限把派生类转化成基类类型</li>
<li>protected</li>
</ol>
</li>
<li>初始化：基类和派生类共同完成</li>
<li>执行次序：<ol>
<li>构造函数：<ol>
<li>基类</li>
<li>派生类对象成员类的构造函数</li>
<li>派生类的构造函数</li>
</ol>
</li>
<li>析构函数：<ol>
<li>与构造函数相反</li>
</ol>
</li>
</ol>
</li>
<li>调用：<ol>
<li>默认执行基类的默认构造函数</li>
<li>如果要执行基类的自定义构造函数，就要在派生类的构造函数的成员初始化表中指出</li>
</ol>
</li>
</ol>
<h2 id="虚函数"><a href="#虚函数" class="headerlink" title="虚函数"></a>虚函数</h2><ol>
<li>前期绑定，cpp默认<ol>
<li>编译时刻</li>
<li>根据对象的静态类型，即只看形参的类型</li>
<li>效率高</li>
</ol>
</li>
<li>动态绑定<ol>
<li>运行时刻判断</li>
<li>根据对象的实际类型动态决定</li>
<li>灵活性高</li>
</ol>
</li>
<li>虚函数<ol>
<li>提供动态绑定，根据实际引用和指向的对象的类型</li>
</ol>
</li>
<li>后期绑定的实现：虚函数表：一个可变的vtable存这个类的虚函数的地址，指向另外一片区域</li>
</ol>
<p><img src="https://cynyard-blog-pics.oss-cn-beijing.aliyuncs.com/image/1598013285157-2416703a-3e80-411d-ade9-c3d03be9f2e5.png" alt="image.png"></p>
<ol start="5">
<li>注意<ol>
<li>静态调用后还可以发生动态调用：非虚接口</li>
<li>动态调用后将不能继续静态调用</li>
</ol>
</li>
</ol>
<p><img src="https://cynyard-blog-pics.oss-cn-beijing.aliyuncs.com/image/1598013469464-91f73a86-d6df-4e2b-84dd-47aaf275111a.png" alt="image.png"></p>
<ol>
<li>构造函数中只会调用正在构造的类的版本的函数</li>
<li>如果把上图的h改为virtual，里面的东西都调B的</li>
<li>绝对不要重新定义继承而来的缺省参数值，</li>
<li>override,final<ol>
<li>override:必须在父类中是虚函数，并且函数参数都要相同，父类中是const，子类也需要是const</li>
<li>final：父类当中说明了final，就不能override</li>
</ol>
</li>
<li>纯虚函数：形如 <code>vitual int f() = 0;</code> <ol>
<li>只给出声明，不给出实现</li>
</ol>
</li>
<li>抽象类：至少包含一个纯虚函数<ol>
<li>不能用于创建对象</li>
<li>派生类需要提供抽象基类的所有成员函数的实现</li>
</ol>
</li>
<li>抽象工厂</li>
<li>虚析构函数</li>
</ol>
<p>因为析构函数没有声明为虚函数，所以只会调用B的析构函数<br><img src="https://cynyard-blog-pics.oss-cn-beijing.aliyuncs.com/image/1598065093192-dec2ac43-2184-4f4b-b101-07a93b3674aa.png" alt="image.png"></p>
<h2 id="多继承"><a href="#多继承" class="headerlink" title="多继承"></a>多继承</h2><ol>
<li>看不懂</li>
<li>如果直接基类有公共的基类，则该公共基类中的成员变量 在多继承的派生类中有多个副本，解决名冲突：基类名::基类成员名</li>
</ol>
<p><img src="https://cynyard-blog-pics.oss-cn-beijing.aliyuncs.com/image/1598014794984-3f582bbc-7871-4447-8c19-e120b8fff643.png" alt="image.png"><br><img src="https://cynyard-blog-pics.oss-cn-beijing.aliyuncs.com/image/1598014682469-8ecdd25e-bb80-440d-9857-2423ad26cec7.png" alt="image.png"></p>
<h1 id="Part3-Advance"><a href="#Part3-Advance" class="headerlink" title="Part3 Advance"></a>Part3 Advance</h1><h2 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h2><ol>
<li>同一论域中一个元素可有多种解释，提高语言灵活性</li>
<li>不影响代码而替换行为</li>
<li>程序设计语言：<ol>
<li>函数重载，一名多用<ol>
<li>在同一个作用域中，相同的标识符可以用于定义不同的函数，但要求这些函数应拥有不同的参数(参数类型或个数)</li>
<li>函数重载主要用于定义多个功能相同而参数不同的函数</li>
</ol>
</li>
<li>类属，template<ol>
<li>编译的时候多态</li>
</ol>
</li>
<li>程序设计：虚函数<ol>
<li>运行时多态</li>
</ol>
</li>
</ol>
</li>
<li>多态性可以严格的分为四类:重载多态，强制多态，包含多态，和参数多态，前面两种统称 为专用多态，而后面两种也称为通用多态</li>
</ol>
<h2 id="操作符重载"><a href="#操作符重载" class="headerlink" title="操作符重载"></a>操作符重载</h2><ol>
<li>根本上来说，也是函数重载<ol>
<li>名字相同，参数不同导致重载</li>
<li>静态绑定</li>
<li>为了改变操作符语义，对于自定义数据类型或者built_in类型有新的操作符</li>
<li>提高可用性和可拓展性</li>
</ol>
</li>
<li>使用</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Complex</span></span></span><br><span class="line"><span class="class">&#123;</span> <span class="keyword">double</span> real, imag;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		Complex() &#123; real = <span class="number">0</span>; imag = <span class="number">0</span>; &#125;</span><br><span class="line">		Complex(<span class="keyword">double</span> r, <span class="keyword">double</span> i) &#123; real = r; imag = i; &#125;</span><br><span class="line">		<span class="keyword">friend</span> Complex <span class="keyword">operator</span> + (Complex&amp; c1, Complex&amp; c2);</span><br><span class="line">&#125;;</span><br><span class="line">Complex <span class="keyword">operator</span> + (Complex&amp; c1, Complex&amp; c2)&#123;<span class="comment">//Complex的友元函数</span></span><br><span class="line">	Complex temp;</span><br><span class="line">	temp.real = c1.real + c2.real; </span><br><span class="line">    temp.imag = c1.imag + c2.imag; </span><br><span class="line">    <span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br><span class="line">Complex a(1,2),b(3,4),c; </span><br><span class="line">c = a + b;</span><br><span class="line">...;</span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Day</span> &#123;</span> SUN, MON, TUE, WED, THU, FRI, SAT&#125;;</span><br><span class="line">Day&amp; <span class="keyword">operator</span>++(Day&amp; d)&#123;</span><br><span class="line">    <span class="keyword">return</span> d= (d==SAT)? SUN: Day(d+<span class="number">1</span>); </span><br><span class="line">&#125;</span><br><span class="line">ostream&amp; <span class="keyword">operator</span> &lt;&lt; (ostream&amp; o, Day&amp; d) &#123;</span><br><span class="line">    <span class="comment">//为什么不能作为成员函数：</span></span><br><span class="line">    <span class="keyword">switch</span> (d)&#123; </span><br><span class="line">    <span class="keyword">case</span> SUN: o &lt;&lt; <span class="string">&quot;SUN&quot;</span> &lt;&lt; <span class="built_in">endl</span>;<span class="keyword">break</span>; </span><br><span class="line">	...;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> o;&#125;<span class="comment">//返回同一个引用，支持连续使用</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Counter</span></span></span><br><span class="line"><span class="class">&#123;</span> 	<span class="keyword">int</span> value;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">	Counter() &#123; value = <span class="number">0</span>; &#125;</span><br><span class="line">	Counter&amp;<span class="keyword">operator</span>++()<span class="comment">//++a &#123; </span></span><br><span class="line">        value++;</span><br><span class="line">		<span class="keyword">return</span> *<span class="keyword">this</span>; &#125;</span><br><span class="line">	Counter <span class="keyword">operator</span> ++(<span class="keyword">int</span>) <span class="comment">//a++ &#123; </span></span><br><span class="line">        Counter temp=*<span class="keyword">this</span>;</span><br><span class="line">		value++;</span><br><span class="line">		<span class="keyword">return</span> temp; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>为什么&lt;&lt;与&gt;&gt;不能作为成员函数？<br>如果是重载双目操作符（即为类的成员函数），就只要设置一个参数作为右侧运算量，而左侧运算量就是对象本身<br>而 &gt;&gt;  或&lt;&lt; 左侧运算量是 cin或cout 而不是对象本身，所以不满足后面一点。</p>
<ol start="3">
<li><p>不可重载的操作符：</p>
<ol>
<li>“.”操作符，我们需要保证访问成员的功能不能被改变，否则引起混淆，不知道访问什么成员</li>
<li>“.*”,同上</li>
<li>“::”,域运算符号，只是名称域的解析</li>
<li>“?”，操作符重载是一个函数调用，所以重载过后，可能?的条件条件都会执行</li>
<li>“sizeof”,参数是类型，而不是变量或者表达式</li>
</ol>
</li>
<li><p>双目操作符</p>
<ol>
<li><p>类成员函数重载</p>
</li>
<li><p>this隐含</p>
</li>
<li><p>使用 <code>&lt;ret type&gt; operator # (&lt;arg&gt;);&lt;class name&gt; a,b; a#b; a.operator#(b);</code> </p>
</li>
<li><p>全局函数</p>
<ol>
<li>注意友元</li>
<li>有些时候返回的新建的对象的引用，就会出现：if ((a<em>b) ==(b</em>a))</li>
<li>=,(),[],-&gt;不能作为全局函数重载</li>
</ol>
</li>
<li><p>永远不要重载&amp;&amp; 和 ｜｜,重载过后，两个都会执行，短路现象没了</p>
</li>
</ol>
</li>
<li><p>单目操作符</p>
</li>
<li><p>特殊操作符</p>
<ol>
<li>=的重载，相当于新一轮的拷贝构造，在构造完后的拷贝构造</li>
</ol>
</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">A&amp; <span class="keyword">operator</span> = (A&amp; a)</span><br><span class="line"><span class="comment">//不返回const，因为有可能会返回后马上调用函数，改变调用对象的状态</span></span><br><span class="line">&#123;<span class="comment">//这里没有考虑避免自我赋值的问题（可以开一个新的指针指向原来的数组）</span></span><br><span class="line">x = a.x; y = a.y;</span><br><span class="line"><span class="keyword">delete</span> []p;</span><br><span class="line">p = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="built_in">strlen</span>(a.p)+<span class="number">1</span>]; <span class="built_in">strcpy</span>(p,a.p);</span><br><span class="line"><span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ol>
<li>[]的重载，可以赋值和不可以赋值，看返回的是引用还是新的值</li>
<li>()的重载</li>
<li>new</li>
</ol>
<p><img src="https://cynyard-blog-pics.oss-cn-beijing.aliyuncs.com/image/1598023455615-be68b147-c33b-4ad1-86a3-00586e0120fb.png" alt="image.png"></p>
<ol start="4">
<li>delete</li>
</ol>
<p><img src="https://cynyard-blog-pics.oss-cn-beijing.aliyuncs.com/image/1598023489506-2d79acb5-6018-41ab-84d1-1df940fdcbeb.png" alt="image.png"></p>
<h2 id="模版-template"><a href="#模版-template" class="headerlink" title="模版 template"></a>模版 template</h2><ol>
<li>源代码复用机制，一名多用</li>
<li>参数化模块，对不同类型的数据实施相同的操作</li>
<li>多态的一种形式</li>
<li>C++<ol>
<li>类属函数</li>
<li>类属类</li>
</ol>
</li>
<li>类属函数：<ol>
<li>同一函数对不同类型的数据完成相同的操作</li>
<li>方法<ol>
<li>万能指针，可读性差，实现复杂</li>
<li>template<ul>
<li>函数模版定义了一类重载的函数</li>
<li>编译系统自动实例话函数模版<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span> A[], <span class="keyword">unsigned</span> <span class="keyword">int</span> num)</span></span>&#123; </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;num; i++)&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;num-i; j++)&#123;</span><br><span class="line">			<span class="keyword">if</span> (A[j] &gt; A[j+<span class="number">1</span>])</span><br><span class="line">				A[j] = A[j+<span class="number">1</span>]; A[j+<span class="number">1</span>] = t;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;<span class="comment">//必须重载操作符&gt;</span></span><br><span class="line">...;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span> </span><br><span class="line"><span class="function">T <span class="title">max</span><span class="params">(T a, T b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a&gt;b?a:b; </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">max</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">double</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123; returna&gt;b?a:b;&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ol>
</li>
</ol>
</li>
<li>类属类<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Stack</span>&#123;</span></span><br><span class="line">	T buffer[<span class="number">100</span>];</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">		<span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(T x)</span></span>;</span><br><span class="line">    	<span class="function">T <span class="title">pop</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line">...;</span><br><span class="line">Stack &lt;<span class="keyword">int</span>&gt; st1;</span><br><span class="line">Stack &lt;<span class="keyword">double</span>&gt; st2;<span class="comment">//必须显式实例化</span></span><br></pre></td></tr></table></figure>

</li>
</ol>
<h2 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h2><ol>
<li>错误<ol>
<li>语法错误</li>
<li>逻辑错误</li>
</ol>
</li>
<li>异常<ol>
<li>运行环境</li>
<li>异常处理</li>
</ol>
</li>
<li>异常处理<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123; </span><br><span class="line">	f(); </span><br><span class="line">&#125; <span class="keyword">catch</span> ( <span class="keyword">int</span> ) &#123; ... &#125;</span><br><span class="line"><span class="keyword">catch</span> ( <span class="keyword">double</span> ) &#123; ... &#125;</span><br><span class="line"><span class="keyword">catch</span> (<span class="keyword">char</span> * ) &#123; ... &#125;</span><br><span class="line"><span class="comment">//如果没有被catch，那么逐层往上面仍，直到系统自带的abort</span></span><br><span class="line">...;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(MyExceptionBase e)</span></span>&#123;</span><br><span class="line">	<span class="keyword">throw</span> e;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//应该用引用，避免被切片</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    MyExceptionDerived e;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        f(e);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (MyExceptionDerived &amp;e) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;MyExceptionDerived&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (MyExceptionBase &amp;e) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;MyExceptionBase&quot;</span> &lt;&lt; <span class="built_in">endl</span>;<span class="comment">//最后会打印这个，因为派生类被切片了</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>auto_ptr</li>
</ol>
<p>在构造的时候获取资源，在析构的时候释放资源<br>如果在构造函数中产生了异常，那么析构函数将不会调用，这样就会造成资源泄漏的隐患。比如，如果该类有2个成员变量，指向两个资源，在构造函数中申请资源A成功，但申请资源B失败，则构造函数失败，那么析构函数不会被调用，那么资源A则泄漏。<br>为了解决这个问题，我们可以利用auto_ptr取代普通指针作为成员变量，这样首先调用成功的成员变量的构造函数肯定会调用其析构函数，那么就可以避免资源泄漏问题。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Template &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">auto_ptr</span>&#123;</span> </span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">		<span class="built_in">auto_ptr</span>(T *p=<span class="number">0</span>):ptr(p)&#123;&#125; </span><br><span class="line">    	~<span class="built_in">auto_ptr</span>()&#123; <span class="keyword">delete</span> ptr; &#125;</span><br><span class="line">		T* <span class="keyword">operator</span>-&gt;() <span class="keyword">const</span> &#123; <span class="keyword">return</span> ptr;&#125; </span><br><span class="line">    	T&amp; <span class="keyword">operator</span> *() <span class="keyword">const</span> &#123; <span class="keyword">return</span> *ptr; &#125;</span><br><span class="line">	<span class="keyword">private</span>: </span><br><span class="line">    	T* ptr;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">processAdoptions</span><span class="params">(istream&amp; dataSource)</span> </span>&#123; </span><br><span class="line">    <span class="keyword">while</span> (dataSource)&#123;</span><br><span class="line">        <span class="function"><span class="built_in">auto_ptr</span>&lt;ALA&gt; <span class="title">pa</span><span class="params">(readALA(dataSource))</span></span>; </span><br><span class="line">        pa-&gt;processAdoption();</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//pa出栈的时候肯定会被析构，不会有内存泄露</span></span><br></pre></td></tr></table></figure>

<h2 id="IO处理"><a href="#IO处理" class="headerlink" title="IO处理"></a>IO处理</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CPoint2D</span></span></span><br><span class="line"><span class="class"> &#123;</span></span><br><span class="line">	<span class="keyword">double</span> x, y; </span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">		...</span><br><span class="line">		<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">(ostream&amp; out)</span></span>&#123;</span><br><span class="line">            out&lt;&lt;x&lt;&lt;‘,’&lt;&lt;y&lt;&lt;<span class="built_in">endl</span>; </span><br><span class="line">        &#125; </span><br><span class="line">&#125;;</span><br><span class="line">ostream&amp; <span class="keyword">operator</span> &lt;&lt; (ostream&amp; out, CPoint2D &amp;a) &#123; </span><br><span class="line">    a.display(out); <span class="keyword">return</span> out; </span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CPoint3D</span>:</span> <span class="keyword">public</span> CPoint2D</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">double</span> z; </span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">		...;</span><br><span class="line">		<span class="function"><span class="keyword">void</span> <span class="title">display</span><span class="params">(ostream&amp; out)</span></span>&#123;</span><br><span class="line">        CPoint2D::display(); </span><br><span class="line">        out &lt;&lt; ‘,’&lt;&lt; z &lt;&lt; <span class="built_in">endl</span>; </span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="重定向"><a href="#重定向" class="headerlink" title="重定向"></a>重定向</h2><p>cin重定向到文件读取</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ifstream <span class="title">in</span><span class="params">(“in.txt”)</span></span>;</span><br><span class="line">streambuf *cinbuf = <span class="built_in">cin</span>.rdbuf(); <span class="comment">//save old buf </span></span><br><span class="line"><span class="built_in">cin</span>.rdbuf(in.rdbuf()); <span class="comment">//redirect cin to in.txt!</span></span><br></pre></td></tr></table></figure>
<p>cout重定向到文件中输出</p>
<h2 id="虚构造"><a href="#虚构造" class="headerlink" title="虚构造"></a>虚构造</h2><p>利用父类的虚函数，动态构造对象</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">NewsLetter::NewsLetter(constNewsLetter&amp;rhs)&#123; </span><br><span class="line">    <span class="keyword">for</span> ( <span class="built_in">list</span>&lt;NLComponent *&gt;::iterator it=rhs.component.begin();</span><br><span class="line">it != rhs.component.end(); ++it ) </span><br><span class="line">        component.push_back((*it)-&gt;clone());</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<h2 id="More-Effective-C"><a href="#More-Effective-C" class="headerlink" title="More Effective C++"></a>More Effective C++</h2><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/davidsher_zhou/article/details/81104267?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromBaidu-1.edu_weight&depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromBaidu-1.edu_weight">详解1</a><br><a target="_blank" rel="noopener" href="https://blog.csdn.net/afei__/article/details/84026155">详解2</a></p>
<ul>
<li><p><strong>条款1</strong>：仔细区别 pointers 和 references；</p>
<p>Distinguish between pointers and references. </p>
</li>
</ul>
<blockquote>
<p>指针是对象的地址，引用是对象的别名必须有初值，不能被改变，指针可以指向 null，引用不允许指向null。引用类型比指针类型要安全。</p>
</blockquote>
<ul>
<li><p><strong>条款2</strong>：最好使用 C++ 转型操作符 </p>
<p>Prefer C++style casts. </p>
</li>
</ul>
<blockquote>
<p>使用新式转型符比较容易辨析</p>
</blockquote>
<ul>
<li><p><strong>条款3</strong>：绝对不要以多态（polymorphically）方式处理数组 </p>
<p>  Never treat arrays polymorphically. </p>
<blockquote>
<p>数组传递只有引用传递和首元素地址传递，如果采用多态，可能数组类型是BaseClass，派生类的sizeof大于BaseClass，那么在数组的array[i]的时候很可能出错</p>
</blockquote>
</li>
<li><p><strong>条款4</strong>：非必要不提供 default constructor </p>
<p>  Avoid gratuitous default constructors. </p>
<blockquote>
<p>添加无意义的默认构造函数显得画蛇添足，也会影响效率。</p>
</blockquote>
</li>
</ul>
<p>操作符（Operators） </p>
<ul>
<li><p>条款5：对定制的“类型转换函数”保持警觉 </p>
<p>  Be wary of user-defined conversion functions. </p>
</li>
<li><p>条款6：区别 increment/decrement 操作符的前置（prefix）和后置（postfix）形式 </p>
<p>  Distinguish between prefix and postfix forms of increment and decrement operators. </p>
</li>
<li><p><strong>条款7</strong>：千万不要重载＆＆，和, 操作符</p>
<p>  Never overload ＆＆,|| , or ，</p>
<blockquote>
<p>不管你多么努力，都无法令其行为像它们应有的那样，所以千万不要重载它们</p>
</blockquote>
</li>
<li><p><strong>条款8</strong>：了解各种不同意义的 new 和 delete </p>
<p>  Understand the different meanings of new and delete </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> *p = <span class="keyword">new</span> <span class="built_in">string</span>(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line"><span class="keyword">void</span> *p = <span class="keyword">operator</span> <span class="keyword">new</span>(<span class="keyword">sizeof</span>(<span class="built_in">string</span>));<span class="comment">//只是分配空间</span></span><br><span class="line"><span class="keyword">delete</span> p;</span><br><span class="line"><span class="keyword">delete</span> []p;</span><br></pre></td></tr></table></figure>
<p>异常（Exceptions） </p>
</li>
<li><p><strong>条款9</strong>：利用 destructors 避免泄漏资源 </p>
<p>  Use destructors to prevent resource leaks. </p>
<blockquote>
<p>坚持一个原则，将资源封装在对象内，这样即使发生异常，局部对象在自动销毁的时候也可以调用其析构函数释放资源，避免泄漏。</p>
</blockquote>
</li>
<li><p><strong>条款10</strong>：在 constructors 内阻止资源泄漏（resource leak） </p>
<p>  Prevent resource leaks in constructors. </p>
<blockquote>
<p>C++ 只会析构 已构造完成 的对象。也就是说在构造函数中发生异常的话，析构函数是不会执行的。<br>最好是使用 auto_ptr 对象来取代 pointer class members。</p>
</blockquote>
</li>
<li><p>条款11：禁止异常（exceptions）流出 destructors 之外 </p>
<p>  Prevent exceptions from leaving destructors. </p>
</li>
<li><p>条款12：了解“抛出一个 exception”与“传递一个参数” 或“调用一个虚函数”之间的差异 </p>
<p>  Understand how throwing an exception differs from passing a parameter or calling a virtual function. </p>
</li>
<li><p>条款13：以 by reference 方式捕捉 exceptions </p>
<p>  Catch exceptions by reference. </p>
</li>
<li><p>条款14：明智运用 exception specifications </p>
<p>  Use exception specifications judiciously. </p>
</li>
<li><p>条款15：了解异常处理（exception handling）的成本 </p>
<p>  Understand the costs of exception handling.<br>效率（Efficiency） </p>
</li>
<li><p>条款16：谨记 80-20 法则 </p>
<p>  Remember the 80-20 rule. </p>
</li>
<li><p>条款17：考虑使用 lazy evaluation（缓式评估） </p>
<p>  Consider using lazy evaluation. </p>
</li>
<li><p>条款18：分期摊还预期的计算成本 </p>
<p>  Amortize the cost of expected computations. </p>
</li>
<li><p>条款19：了解临时对象的来源 </p>
<p>  Understand the origin of temporary objects. </p>
</li>
<li><p>条款20：协助完成“返回值优化（RVO）” </p>
<p>  Facilitate the return value optimization. </p>
</li>
<li><p>条款21：利用重载技术（overload）避免隐式类型转换（implict type conversions） </p>
<p>  Overload to avoid implicit type conversions.    </p>
</li>
<li><p>条款22：考虑以操作符复合形式（op=）取代其独身形式（op） </p>
<p>  Consider using op= instead of stand-alone op. </p>
</li>
<li><p>条款23：考虑使用其他程序库 </p>
<p>  Consider alternative libraries. </p>
</li>
<li><p>条款24：了解 virtual functions、multiple inheritance、virtual base classes、 runtime type identification 的成本 </p>
<p>  Understand the costs of virtual functions, multiple inheritance, virtual base classes, and RTTI.<br>技术（Techniques, Idioms, Patterns） </p>
</li>
<li><p>条款25：将 constructor 和 non-member functions 虚化 </p>
<p>  Virtualizing constructors and non-member functions. </p>
</li>
<li><p>条款26：限制某个 class 所能产生的对象数量 </p>
<p>  Limiting the number of objects of a class. </p>
</li>
<li><p>条款27：要求（或禁止）对象产生于 heap 之中 </p>
<p>  Requiring or prohibiting heap-based objects. </p>
</li>
<li><p>条款28：Smart Pointers（智能指针） </p>
</li>
<li><p>条款29：Reference counting（引用计数） </p>
</li>
<li><p>条款30：Proxy classes（替身类、代理类） </p>
</li>
<li><p>条款31：让函数根据一个以上的对象类型来决定如何虚化 </p>
<p>  Making functions virtual with respect to more than one object.<br>杂项讨论（Miscellany） </p>
</li>
<li><p>条款32：在未来时态下发展程序 </p>
<p>  Program in the future tense. </p>
</li>
<li><p>条款33：将非尾端类（non-leaf classes）设计为 抽象类（abstract classes） </p>
<p>  Make non-leaf classes abstract. </p>
</li>
<li><p>条款34：如何在同一个程序中结合 C++ 和 C </p>
<p>  Understand how to combine C++ and C in the same program. </p>
</li>
<li><p>条款35：让自己习惯于标准 C++ 语言 </p>
<p>  Familiarize yourself with the language standard.                 </p>
</li>
</ul>

        </div>

        
            <section class="post-copyright">
                
                    <p class="copyright-item">
                        <span>Author:</span>
                        <span>Cynyard Qiu</span>
                    </p>
                
                
                
                

            </section>
        
        <section class="post-tags">
            <div>
                <span>Tag(s):</span>
                <span class="tag">
                    
                    
                        <a href="/tags/cpp/"># cpp</a>
                    
                        <a href="/tags/code/"># code</a>
                    
                        
                </span>
            </div>
            <div>
                <a href="javascript:window.history.back();">back</a>
                <span>· </span>
                <a href="/">home</a>
            </div>
        </section>
        <section class="post-nav">
            
                <a class="prev" rel="prev" href="/2020/08/24/linux-foundation/">Linux系统基础</a>
            
            
            <a class="next" rel="next" href="/2020/01/10/COA2/">计算机组织机构（2）</a>
            
        </section>


    </article>
</div>

        </div>
        <footer id="footer" class="footer">
    <div class="copyright">
        <span>© Cynyard Qiu | Powered by <a href="https://hexo.io" target="_blank">Hexo</a> & <a href="https://github.com/Siricee/hexo-theme-Chic" target="_blank">Chic</a> 
        
        </span>
    </div>
</footer>

    </div>
</body>
</html>

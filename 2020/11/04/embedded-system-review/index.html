<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
<meta name="viewport"
      content="width=device-width, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
<meta http-equiv="X-UA-Compatible" content="ie=edge">
<meta name="referrer" content="no-referrer" />

    <meta name="author" content="Cynyard Qiu">





<title>嵌入式系统复习 | Cynyard&#39;s Blog</title>



    <link rel="icon" href="/cloud.ico">




    <!-- stylesheets list from _config.yml -->
    
    <link rel="stylesheet" href="/css/style.css">
    



    <!-- scripts list from _config.yml -->
    
    <script src="/js/script.js"></script>
    
    <script src="/js/tocbot.min.js"></script>
    



    
    
        
    


<meta name="generator" content="Hexo 5.3.0"></head>
<body>
    <div class="wrapper">
        <header>
    <nav class="navbar">
        <div class="container">
            <div class="navbar-header header-logo"><a href="/">Cynyard&#39;s Blog</a></div>
            <div class="menu navbar-right">
                
                    <a class="menu-item" href="/archives">Posts</a>
                
                    <a class="menu-item" href="/category">Categories</a>
                
                    <a class="menu-item" href="/tag">Tags</a>
                
                    <a class="menu-item" href="/about">About</a>
                
                <input id="switch_default" type="checkbox" class="switch_default">
                <label for="switch_default" class="toggleBtn"></label>
            </div>
        </div>
    </nav>

    
    <nav class="navbar-mobile" id="nav-mobile">
        <div class="container">
            <div class="navbar-header">
                <div>
                    <a href="/">Cynyard&#39;s Blog</a><a id="mobile-toggle-theme">·&nbsp;Light</a>
                </div>
                <div class="menu-toggle" onclick="mobileBtn()">&#9776; Menu</div>
            </div>
            <div class="menu" id="mobile-menu">
                
                    <a class="menu-item" href="/archives">Posts</a>
                
                    <a class="menu-item" href="/category">Categories</a>
                
                    <a class="menu-item" href="/tag">Tags</a>
                
                    <a class="menu-item" href="/about">About</a>
                
            </div>
        </div>
    </nav>

</header>
<script>
    var mobileBtn = function f() {
        var toggleMenu = document.getElementsByClassName("menu-toggle")[0];
        var mobileMenu = document.getElementById("mobile-menu");
        if(toggleMenu.classList.contains("active")){
           toggleMenu.classList.remove("active")
            mobileMenu.classList.remove("active")
        }else{
            toggleMenu.classList.add("active")
            mobileMenu.classList.add("active")
        }
    }
</script>
        <div class="main">
            <div class="container">
    
    
        <div class="post-toc">
    <div class="tocbot-list">
    </div>
    <div class="tocbot-list-menu">
        <a class="tocbot-toc-expand" onclick="expand_toc()">Expand all</a>
        <a onclick="go_top()">Back to top</a>
        <a onclick="go_bottom()">Go to bottom</a>
    </div>
</div>

<script>
    document.ready(
        function () {
            tocbot.init({
                tocSelector: '.tocbot-list',
                contentSelector: '.post-content',
                headingSelector: 'h1, h2, h3, h4, h5',
                collapseDepth: 1,
                orderedList: false,
                scrollSmooth: true,
            })
        }
    )

    function expand_toc() {
        var b = document.querySelector(".tocbot-toc-expand");
        tocbot.init({
            tocSelector: '.tocbot-list',
            contentSelector: '.post-content',
            headingSelector: 'h1, h2, h3, h4, h5',
            collapseDepth: 6,
            orderedList: false,
            scrollSmooth: true,
        });
        b.setAttribute("onclick", "collapse_toc()");
        b.innerHTML = "Collapse all"
    }

    function collapse_toc() {
        var b = document.querySelector(".tocbot-toc-expand");
        tocbot.init({
            tocSelector: '.tocbot-list',
            contentSelector: '.post-content',
            headingSelector: 'h1, h2, h3, h4, h5',
            collapseDepth: 1,
            orderedList: false,
            scrollSmooth: true,
        });
        b.setAttribute("onclick", "expand_toc()");
        b.innerHTML = "Expand all"
    }

    function go_top() {
        window.scrollTo(0, 0);
    }

    function go_bottom() {
        window.scrollTo(0, document.body.scrollHeight);
    }

</script>
    

    
    <article class="post-wrap">
        <header class="post-header">
            <h1 class="post-title">嵌入式系统复习</h1>
            
                <div class="post-meta">
                    
                        Author: <a itemprop="author" rel="author" href="/">Cynyard Qiu</a>
                    

                    
                        <span class="post-time">
                        Date: <a href="#">November 4, 2020&nbsp;&nbsp;12:00:00</a>
                        </span>
                    
                    
                        <span class="post-category">
                    Category:
                            
                                <a href="/categories/Course/">Course</a>
                            
                        </span>
                    
                </div>
            
        </header>

        <div class="post-content">
            <h1 id="1-嵌入式系统的定义，特点，分类，典型应用"><a href="#1-嵌入式系统的定义，特点，分类，典型应用" class="headerlink" title="1. 嵌入式系统的定义，特点，分类，典型应用**"></a>1. 嵌入式系统的定义，特点，分类，典型应用**</h1><h2 id="1-1-定义"><a href="#1-1-定义" class="headerlink" title="1.1 定义"></a>1.1 定义</h2><ul>
<li>嵌入式系统：嵌入式计算机系统的简称</li>
<li><strong>IEEE</strong>：嵌入式系统是“用于控制、监视、或者辅助操作机器和设备的装置”，软件和硬件的综合体，还可以涵盖机电等附属装置</li>
<li><strong>普遍认同的定义</strong>：以应用为中心，以计算机技术为基础，软硬件可裁剪，适用于应用系统对功能、可靠性、成本、体积、功耗有着严格要求的专用计算机系统。</li>
</ul>
<blockquote>
<p>具有特定功能或用途的隐藏在某种设备中的计算机<strong>软硬件</strong>集合体，没有固定的特征形状。</p>
</blockquote>
<ul>
<li><p>三要素</p>
<ul>
<li>嵌入</li>
<li>专用</li>
<li>计算机</li>
</ul>
</li>
<li><p>其他定义：看不见的计算机，一般不能被⽤户编程, 它有一些专用的I/O设备, 对用户的接⼝是应用专⽤的。（包含有计算机 但又不是通用的计算机的计算机应用系统）</p>
</li>
</ul>
<h2 id="1-2-特点"><a href="#1-2-特点" class="headerlink" title="1.2 特点"></a>1.2 特点</h2><h4 id="形式多样面向特定应用"><a href="#形式多样面向特定应用" class="headerlink" title="形式多样面向特定应用"></a>形式多样面向特定应用</h4><ul>
<li>用于特定的任务，硬件和软件必须进行高效率的设计</li>
<li>低功耗，体积小，集成度高</li>
<li>应用程序和操作系统两种软件的一体化</li>
</ul>
<h4 id="多种类型的处理器和处理器体系结构的⽀持"><a href="#多种类型的处理器和处理器体系结构的⽀持" class="headerlink" title="多种类型的处理器和处理器体系结构的⽀持"></a>多种类型的处理器和处理器体系结构的⽀持</h4><ul>
<li>可采用多种类型的处理器和处理器体系结构，很多种嵌入式微处理器和微处理器结构可以选择<ul>
<li>通用计算机只采用少数的处理器类型和体系结构，而且主要掌握在少数大公司手中</li>
</ul>
</li>
<li>巨大产业模式也产业链</li>
</ul>
<h4 id="成本"><a href="#成本" class="headerlink" title="成本"></a>成本</h4><ul>
<li>需要关注系统成本<ul>
<li>开发成本NRE</li>
<li>产品成本，硬件，包装，版权</li>
<li>批量的总体成本</li>
</ul>
</li>
</ul>
<h4 id="实时性和可靠性的要求"><a href="#实时性和可靠性的要求" class="headerlink" title="实时性和可靠性的要求"></a>实时性和可靠性的要求</h4><ul>
<li>大多数实时系统都是嵌入式系统</li>
<li>嵌入式系统对于实时性的要求：软件一般是固化运行或者直接加载到内存中运行</li>
<li>一旦遇到错误需要有机制保证正常运行，出错处理和自动复位（特别是一些在极端环境下运行的嵌入式系统）<ul>
<li>看门狗定时器，一直定时加一，到某一个时间就复位，如果没有复位超过了溢出，那么就及时复位</li>
</ul>
</li>
</ul>
<h4 id="适应多种处理器、可裁剪、轻量级、可靠可固化的嵌入式操作系统"><a href="#适应多种处理器、可裁剪、轻量级、可靠可固化的嵌入式操作系统" class="headerlink" title="适应多种处理器、可裁剪、轻量级、可靠可固化的嵌入式操作系统"></a>适应多种处理器、可裁剪、轻量级、可靠可固化的嵌入式操作系统</h4><ul>
<li>根据应用进行裁剪、配置</li>
<li>规模小，能够固化运行</li>
<li>实时内核</li>
<li>时间空间，数据隔离，一种保护机制</li>
</ul>
<h4 id="专门的工具和特殊方法"><a href="#专门的工具和特殊方法" class="headerlink" title="专门的工具和特殊方法"></a>专门的工具和特殊方法</h4><ul>
<li>开发环境</li>
<li>开发工具（不同的连接方式）<ul>
<li>host+target</li>
</ul>
</li>
</ul>
<h2 id="1-3-分类"><a href="#1-3-分类" class="headerlink" title="1.3 分类"></a>1.3 分类</h2><h4 id="按嵌入式处理器的位数来分类"><a href="#按嵌入式处理器的位数来分类" class="headerlink" title="按嵌入式处理器的位数来分类"></a>按嵌入式处理器的位数来分类</h4><ul>
<li>4位，8位，16位嵌入式操作系统目前已经大量应用</li>
<li>32位嵌入式操作系统正在成为主流发展趋势</li>
<li>64位嵌入式操作系统作为高度复杂的、高速的嵌入式系统已经开始采用</li>
</ul>
<h4 id="按应用来分类"><a href="#按应用来分类" class="headerlink" title="按应用来分类"></a>按应用来分类</h4><ul>
<li>信息家电</li>
<li>移动终端</li>
<li>汽车电子</li>
<li>工业控制</li>
<li>通信</li>
<li>交通管理</li>
<li>环境工程</li>
<li>POS网络</li>
</ul>
<h4 id="按速度来分类"><a href="#按速度来分类" class="headerlink" title="按速度来分类"></a>按速度来分类</h4><ul>
<li>强实时系统，毫秒到微妙</li>
<li>一般实时系统，几秒</li>
<li>弱实时系统，数十秒或者更长，响应时间可能随着系统复杂的轻重而变化</li>
</ul>
<h4 id="按确定性来分类"><a href="#按确定性来分类" class="headerlink" title="按确定性来分类"></a>按确定性来分类</h4><ul>
<li>硬实时：对响应时间有严格的要求，如果不能满足就会引起崩溃</li>
<li>软实时：有要求，但是不会导致出现致命的错误或崩溃</li>
</ul>
<h4 id="按嵌入式系统软件复杂程度来分类"><a href="#按嵌入式系统软件复杂程度来分类" class="headerlink" title="按嵌入式系统软件复杂程度来分类"></a>按嵌入式系统软件复杂程度来分类</h4><ul>
<li>循环轮询系统</li>
<li>有限状态机系统</li>
<li>前后台系统</li>
<li>单处理器多任务系统</li>
<li>多处理器多任务系统</li>
</ul>
<h2 id="1-4-典型应用"><a href="#1-4-典型应用" class="headerlink" title="1.4 典型应用"></a>1.4 典型应用</h2><ul>
<li>信息家电</li>
<li>智能玩具</li>
<li>移动计算</li>
<li>通信设备</li>
<li>军用电子</li>
<li>汽车电子</li>
<li>工控设备</li>
<li>智能仪表</li>
<li>电子商务</li>
</ul>
<h1 id="2-嵌入式系统，IOT，CPS的基本组成"><a href="#2-嵌入式系统，IOT，CPS的基本组成" class="headerlink" title="2. 嵌入式系统，IOT，CPS的基本组成**"></a>2. 嵌入式系统，IOT，CPS的基本组成**</h1><h2 id="2-1-嵌入式系统的组成"><a href="#2-1-嵌入式系统的组成" class="headerlink" title="2.1 嵌入式系统的组成"></a>2.1 嵌入式系统的组成</h2><h4 id="硬件"><a href="#硬件" class="headerlink" title="硬件"></a>硬件</h4><p>以微处理器为核心集成存储器和系统专用的输⼊/输出设备</p>
<h4 id="软件"><a href="#软件" class="headerlink" title="软件"></a>软件</h4><p>初始化代码及驱动、嵌⼊式操作统和应⽤程序等，这些软件有机地结合在一起，形成系统特定的一体化软件。</p>
<h2 id="2-2-IOT"><a href="#2-2-IOT" class="headerlink" title="2.2 IOT"></a>2.2 IOT</h2><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><ul>
<li><p>物联网(IOT)是物理设备、车辆(也称为“连接设备”和“智能设备”)、建筑物和嵌入电子设备、软件、传感器、执行器和网络连接的其他物理设备之间的互联网络，这些设备使这些对 象能够收集和交换数据。通过各种信息传感器等采集所需要的信息，通过网络接入，实现车辆等物理设备与物理设备，物理设备与人之间建立广泛连接，组成互联互通的网络</p>
</li>
<li><p>物联网描述了一个由物理设备组成的网络，这些设备通常被嵌入了传感器，软件，和其他技术用以设备之间和设备与外界的连接和数据交换</p>
</li>
</ul>
<h4 id="组成"><a href="#组成" class="headerlink" title="组成"></a>组成</h4><p><img src="https://cdn.nlark.com/yuque/0/2020/png/1096029/1604390973459-b8d23093-ffd9-44eb-80e1-c1d5a7d48112.png" alt="image.png"></p>
<h4 id="RFID"><a href="#RFID" class="headerlink" title="RFID"></a>RFID</h4><p>射频识别，其原理为阅读器与标签之间进行<strong>非接触式的数据通信</strong>，达到识别目标的目 的。RFID 的应用非常广泛，目前典型应用有动物晶片、汽车晶片防盗器、门禁管制、停车场 管制、生产线自动化、物料管理。</p>
<h4 id="M2M"><a href="#M2M" class="headerlink" title="M2M"></a>M2M</h4><p>主要是由通信行业提出的。最初M2M主要是指:不具备信 息化能力的机械设备通过移动通信网络(无线网络)与其他设备或信息系统(IT系统)进行 通信。通信行业认为:网络在满足了人与人之间的通讯需求后，还可以使得“物与物”之间进 行通信联结，构成更高效的信息化应用。此后，M2M的概念又延伸出了“人与机器”或“机器与 人”的概念。总体来说，<strong>M2M就是指人、设备、信息系统，三者之间的信息互通和互动。</strong></p>
<h4 id="两化融合"><a href="#两化融合" class="headerlink" title="两化融合"></a>两化融合</h4><p>两化融合是信息化和工业化的高层次的深度结合， 是指以信息化带动工业化、以 工业化促进信息化，走新型工业化道路;两化融合的核心就是信息化支撑，追求可持续发展 模式。</p>
<h4 id="传感器"><a href="#传感器" class="headerlink" title="传感器"></a>传感器</h4><p>由随机分布并集成有传感器、数据处理单元和通信单元的微小节点，通过自组织方 式构成的无线网络</p>
<h2 id="2-3-CPS的基本组成"><a href="#2-3-CPS的基本组成" class="headerlink" title="2.3 CPS的基本组成"></a>2.3 CPS的基本组成</h2><h4 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h4><ul>
<li>信息物理系统(Cyber-Physical Systems)作为计算进程和物理进程的统一体，是集成计算、通信与控制于一体的下一代智能系统。</li>
<li>高度复杂的系统运用到控制，网络，计算，使得拓展了对系统的监视</li>
<li>IoT更像是获取信息，CPS  presents a higher combination and coordination between physical and computational elements.（物理世界和计算世界之间更复杂的结合和协作）</li>
</ul>
<h4 id="基本组成"><a href="#基本组成" class="headerlink" title="基本组成"></a>基本组成</h4><p>传感器、执行器、决策控制单元</p>
<h1 id="3-嵌入式系统设计"><a href="#3-嵌入式系统设计" class="headerlink" title="3. 嵌入式系统设计"></a>3. 嵌入式系统设计</h1><h2 id="3-1-嵌入式系统面临的挑战"><a href="#3-1-嵌入式系统面临的挑战" class="headerlink" title="3.1 嵌入式系统面临的挑战"></a>3.1 嵌入式系统面临的挑战</h2><h4 id="设计所面临的挑战"><a href="#设计所面临的挑战" class="headerlink" title="设计所面临的挑战"></a>设计所面临的挑战</h4><ul>
<li>硬件的数量</li>
<li>处理多项功能在时间上的协调一致的关系</li>
<li>降低系统的功耗</li>
<li>保证系统可以升级</li>
<li>保证系统正常工作</li>
</ul>
<h4 id="设计者要求"><a href="#设计者要求" class="headerlink" title="设计者要求"></a>设计者要求</h4><ul>
<li>懂得系统的整个构架</li>
<li>详细了解硬件的细节</li>
<li>软件设计需要满足实时性，低功耗，代码量小</li>
<li>需要详细了解领域知识</li>
</ul>
<h2 id="3-1-传统开发过程"><a href="#3-1-传统开发过程" class="headerlink" title="3.1 传统开发过程"></a>3.1 传统开发过程</h2><h4 id="基本特征"><a href="#基本特征" class="headerlink" title="基本特征"></a>基本特征</h4><ul>
<li>系统一开始就被划分为软件和硬件两大部分</li>
<li>两部分独立进行开发设计</li>
<li>通常是先开发硬件</li>
</ul>
<h4 id="隐含问题"><a href="#隐含问题" class="headerlink" title="隐含问题"></a>隐含问题</h4><ul>
<li>软硬件之间的交互收到很大限制</li>
<li>凭经验划分软件和硬件</li>
<li>软件硬件之间的相互性能影响很难评估</li>
<li>系统集成相对滞后，开发成本高</li>
</ul>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><ul>
<li>设计质量差</li>
<li>设计修改难</li>
<li>研制周期不能得到有效保障</li>
</ul>
<h2 id="3-3-软硬件协同设计"><a href="#3-3-软硬件协同设计" class="headerlink" title="3.3 软硬件协同设计-"></a>3.3 软硬件协同设计-</h2><p>并行开发</p>
<h2 id="3-4-软硬件划分"><a href="#3-4-软硬件划分" class="headerlink" title="3.4 软硬件划分"></a>3.4 软硬件划分</h2><ul>
<li>什么由硬件实现，软件实现<ul>
<li>硬件：性能高，不可更改</li>
<li>软件：成本高，灵活性更好</li>
</ul>
</li>
<li>软件硬件的双重性是划分决策的前提</li>
<li>软硬件变动对于系统决策的影响</li>
<li>多种因素影响划分</li>
</ul>
<h4 id="软件实现的部分"><a href="#软件实现的部分" class="headerlink" title="软件实现的部分"></a>软件实现的部分</h4><ul>
<li>操作系统</li>
<li>协议栈</li>
<li>应用软件框架</li>
<li>除了基本系统、物理接口、基本逻辑电路，许多由硬件实现的功能都可以由软件实现</li>
</ul>
<h4 id="硬件实现的部分"><a href="#硬件实现的部分" class="headerlink" title="硬件实现的部分"></a>硬件实现的部分</h4><ul>
<li>物理接口</li>
<li>逻辑电路</li>
</ul>
<h4 id="双重性部分"><a href="#双重性部分" class="headerlink" title="双重性部分"></a>双重性部分</h4><ul>
<li>算法</li>
<li>数学运算</li>
</ul>
<h1 id="4-嵌入式硬件系统基础"><a href="#4-嵌入式硬件系统基础" class="headerlink" title="4. 嵌入式硬件系统基础"></a>4. 嵌入式硬件系统基础</h1><h2 id="4-1-嵌入式微处理器基础"><a href="#4-1-嵌入式微处理器基础" class="headerlink" title="4.1 嵌入式微处理器基础"></a>4.1 嵌入式微处理器基础</h2><h3 id="4-1-1-嵌入式微处理器体系结构"><a href="#4-1-1-嵌入式微处理器体系结构" class="headerlink" title="4.1.1 嵌入式微处理器体系结构"></a>4.1.1 嵌入式微处理器体系结构</h3><h4 id="冯诺伊曼结构"><a href="#冯诺伊曼结构" class="headerlink" title="冯诺伊曼结构"></a>冯诺伊曼结构</h4><ul>
<li>运算器,控制器,存储器,输入设备,输出设备五大基本部分组成</li>
<li>指令和数据不加区分地存在同一个存储器</li>
<li>存储器是按地址访问的线性编址的一维结构，统一编址</li>
<li>通过指令直接发出控制信号控制计算机的操作，CPU通过指令计数器获取指令</li>
<li>以运算器为中心，IO设备与存储器间的数据传输都要经过运算器</li>
</ul>
<h4 id="哈佛结构"><a href="#哈佛结构" class="headerlink" title="哈佛结构"></a>哈佛结构</h4><ul>
<li>哈佛结构是一种存储器并行体系结构，主要特点是将程序和数据存储在不同的存储空间中</li>
<li>即程序存储器和数据存储器是两个独立的存储器，每个存储器独立编址、独立访问。</li>
<li>CPU首先到程序指令存储器中读取程序指令内容，解码后得到数据地址，再到相应的数据存储器中读取数据，并进行下一步的操作(通常是执行)。</li>
<li>程序指令存储和数据存储分开，可以使指令和数据有不同的数据宽度。</li>
<li>总线数是冯诺依曼结构的两倍，也就是说数据吞吐率是冯诺依曼结构的两倍。</li>
<li>哈佛结构有两个独立的存储器模块、两条独立的总线、执行时可以预先读取下一跳指令，有较高的执行效率</li>
</ul>
<h4 id="CISC与RISC"><a href="#CISC与RISC" class="headerlink" title="CISC与RISC"></a>CISC与RISC</h4><p><img src="https://cdn.nlark.com/yuque/0/2020/png/1096029/1604394039996-5a0d8ca7-82aa-4dff-bfc5-304f2c6aa3ec.png" alt="image.png"></p>
<h4 id="流水线技术"><a href="#流水线技术" class="headerlink" title="流水线技术"></a>流水线技术</h4><p>在CPU中由若干个不同功能的电路单元组成一条指令处理流水线，然后将一条指令分成若干 步后再由这些电路单元分别执行，这样就能实现在一个CPU时钟周期完成一条指令，因此提 高CPU的运算速度。(提高CPU利用率、并行计算)</p>
<h4 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h4><ul>
<li>按位数分为4，8，16，32，64</li>
<li>按照功能不同分为MPU，MCU，DSP，SoC</li>
</ul>
<h4 id="MPU"><a href="#MPU" class="headerlink" title="MPU"></a>MPU</h4><ul>
<li>类比于单纯的CPU，体积小，功耗小</li>
</ul>
<h4 id="MCU"><a href="#MCU" class="headerlink" title="MCU"></a>MCU</h4><ul>
<li>将整个计算机系统的主要硬件集成到一块芯片中</li>
<li>芯片内部集成 ROM/EPROM, RAM, 总线, 总线逻辑, 定时/计数器,Watchdog, I/O, 串行口等各种必要功能和外设.</li>
</ul>
<h4 id="DSP"><a href="#DSP" class="headerlink" title="DSP"></a>DSP</h4><ul>
<li>专门用于信号处理方面的处理器，在系统结构和指令算法方面进行了特殊设计，具有 很高的编译效率和指令执行速度(摩托罗拉、ADI、TI)，用软件实现处理</li>
</ul>
<h4 id="Soc"><a href="#Soc" class="headerlink" title="Soc"></a>Soc</h4><ul>
<li>追求产品系统最大包容的集成器件，绝大多数系统构建都在一个系统芯片内部(高通、骁龙、海思)</li>
</ul>
<h4 id="选型"><a href="#选型" class="headerlink" title="选型"></a>选型</h4><ul>
<li>高效并且经济的满足计算任务的计算需求<ul>
<li>速度，ROM/RAM的数量，IO端口和计时器的数量、大小、包装、功耗</li>
<li>易于升级</li>
<li>单位成本</li>
</ul>
</li>
<li>开发工具的可用性</li>
<li>微处理器的广泛可用性</li>
<li>选择步骤<ul>
<li>所需的硬件接口</li>
<li>检查软件架构</li>
<li>选择架构</li>
<li>确定内部需求</li>
<li>搜索微处理器</li>
<li>检查成本和功率限制</li>
<li>检查零件可用性</li>
<li>选择开发工具包</li>
<li>调查编译器和工具</li>
<li>开始试验</li>
</ul>
</li>
</ul>
<h3 id="4-1-2-ARM–"><a href="#4-1-2-ARM–" class="headerlink" title="4.1.2 ARM–"></a>4.1.2 ARM–</h3><h4 id="工作状态"><a href="#工作状态" class="headerlink" title="工作状态"></a>工作状态</h4><h4 id="运行模式"><a href="#运行模式" class="headerlink" title="运行模式"></a>运行模式</h4><h4 id="寄存器结构"><a href="#寄存器结构" class="headerlink" title="寄存器结构"></a>寄存器结构</h4><h4 id="中断和异常"><a href="#中断和异常" class="headerlink" title="中断和异常"></a>中断和异常</h4><h3 id="4-1-3-WatchDog"><a href="#4-1-3-WatchDog" class="headerlink" title="4.1.3 WatchDog*"></a>4.1.3 WatchDog*</h3><h4 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h4><ul>
<li>嵌入式控制系统运行时，收到外部干扰或者系统错误，程序有些时候会出现“跑飞”的情况，最终导致整个系统瘫痪，为了防止这一现象的产生，在对系统稳定性要求较高的场合往往要加入看门狗电路</li>
<li>看门狗电路的作用就是当系统跑飞而进入死循环的时候，恢复系统的运行</li>
</ul>
<h4 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h4><ul>
<li>设置本系统程序完整运行一个周期的时间是tp，看门狗的定时周期为ti，并且ti大于tp。</li>
<li>在程序运行一周期后就修改，即重新设定看门狗的定时器的计数值，只要程序正常运行，就可以在规定的时间间隔内向看门狗发送一个信号，定时器就不会溢出</li>
<li>但是如果由于干扰等原因使得系统不能在tp时刻修改定时器的计数值，定义器将会在ti时刻溢出，从而引发系统复位</li>
<li>最终系统能够重新运行，从而起到监控作用</li>
</ul>
<h4 id="看门狗定时器寄存器"><a href="#看门狗定时器寄存器" class="headerlink" title="看门狗定时器寄存器"></a>看门狗定时器寄存器</h4><ul>
<li>WTCON看门狗控制寄存器，通过这个寄存器可以使能/禁止看门狗、选择输入时钟源、使能/关闭中断、使能/关闭输出</li>
<li>WTDAT看门狗数据寄存器，用于设置看门狗定时器的初值，在初始化的时候不会自动加载到定时器中，首次定时器初始化的值是0x8000，之后该寄存器的值会被自动加载到WTCNT中</li>
<li>WTCNT看门狗计数寄存器，它的值表示该定时器的当前计数值，即到下一 次溢出还需要经历的时钟数。当该定时器工作在看门狗模式时使用该寄存器，每次溢出前需要重新设置其值，以防止发生复位。</li>
</ul>
<h2 id="4-2-嵌入式系统的存储体系"><a href="#4-2-嵌入式系统的存储体系" class="headerlink" title="4.2 嵌入式系统的存储体系"></a>4.2 嵌入式系统的存储体系</h2><h3 id="4-2-1-存储器系统：存储器系统的层次结构"><a href="#4-2-1-存储器系统：存储器系统的层次结构" class="headerlink" title="4.2.1 存储器系统：存储器系统的层次结构"></a>4.2.1 存储器系统：存储器系统的层次结构</h3><ul>
<li>金字塔层次结构，从上到下依次是：寄存器，高速缓存存储器，主存，硬盘，网络文件</li>
<li>越高的越小，越贵，运行速度越快</li>
<li>越低的越大，越便宜，运行速度越慢</li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2020/png/1096029/1604400781062-ee0c4f81-3499-4bee-9da5-01438549eefb.png" alt="image.png"></p>
<h3 id="4-2-2-ROM的种类与选型"><a href="#4-2-2-ROM的种类与选型" class="headerlink" title="4.2.2 ROM的种类与选型"></a>4.2.2 ROM的种类与选型</h3><ul>
<li>ROM</li>
<li>PROM(Programmable ROM)，具有一定的灵活性，可编程一次</li>
<li>EPROM（Erasable Programmable Read Only Memory，EPROM)，可多次编程，是一种以读为主的可读可写的存储器</li>
<li>EEPROM(Electrically Erasable Programmable Read-Only Memory)，一种随时可写入而无须擦除原先内容的存储器，其写操作比读操作时间要长得多，EEPROM把不易丢失数据和修改灵活的优点组合起来，修改时只需使用普通的控制、地址和数据总线</li>
<li>Flash Memory</li>
</ul>
<h3 id="4-2-3-Flash的种类与选型"><a href="#4-2-3-Flash的种类与选型" class="headerlink" title="4.2.3 Flash的种类与选型"></a>4.2.3 Flash的种类与选型</h3><ul>
<li>Flash是电可擦除的，擦除时清除一整块</li>
<li>随机访问，写/擦除比读慢很多</li>
<li>随着擦除次数的增多逐渐失效</li>
<li>NOR FLASH存储少量数据，更灵活，按word读</li>
<li>NAND FLASH存储高密度数据，按page读取</li>
</ul>
<h3 id="4-2-4-RAM的种类与选型"><a href="#4-2-4-RAM的种类与选型" class="headerlink" title="4.2.4 RAM的种类与选型"></a>4.2.4 RAM的种类与选型</h3><ul>
<li>DRAM，更稠密，要求动态刷新电路，即隔一段时间要充电</li>
<li>SDRAM使用时钟提高性能，流水线式内存访问</li>
<li>SRAM，静态RAM，不需要刷新电路即可保存内部的数据，能够快速读取</li>
<li>NVRAM，随机访问，结合了dram的高速及耐写特定以及nand闪存的非易失性</li>
</ul>
<h3 id="4-2-4-Cache"><a href="#4-2-4-Cache" class="headerlink" title="4.2.4 Cache-"></a>4.2.4 Cache-</h3><h2 id="4-3-嵌入式系统总线"><a href="#4-3-嵌入式系统总线" class="headerlink" title="4.3 嵌入式系统总线*"></a>4.3 嵌入式系统总线*</h2><h3 id="4-3-1-总线结构，常见的总线及特点"><a href="#4-3-1-总线结构，常见的总线及特点" class="headerlink" title="4.3.1 总线结构，常见的总线及特点"></a>4.3.1 总线结构，常见的总线及特点</h3><h4 id="总线结构"><a href="#总线结构" class="headerlink" title="总线结构"></a>总线结构</h4><ul>
<li>单总线，使用一条单一的系统总线来连接CPU，主存和IO设备，总线只能分时间工作，使得信息传送的吞吐量受到限制</li>
<li>双总线，在CPU和贮存之间专门设置了一组高速的存储总线，使得CPU可以通过专用总线与存储器交换信息，并且减轻了系统总线的负担，主存仍可通过系统总线与外设之间实现DMA操作，而不必经过CPU</li>
<li>多总线，增加了IO总线，系统总线被用来在CPU，主存和通道之间进行数据传送的公共同路，IO总线用来在多个外部设备和通道之间进行数据传送的公共通路。通道IOP实际上是一台具有特殊功能的处理器，分担了一部分CPU的功能，来实现对外设的统一管理以及外设与主存之间的数据传送</li>
</ul>
<h3 id="4-3-2-输入输出编程：忙等IO和中断IO"><a href="#4-3-2-输入输出编程：忙等IO和中断IO" class="headerlink" title="4.3.2 输入输出编程：忙等IO和中断IO"></a>4.3.2 输入输出编程：忙等IO和中断IO</h3><h4 id="忙等IO"><a href="#忙等IO" class="headerlink" title="忙等IO"></a>忙等IO</h4><ul>
<li>用指令来检查设备是不是就绪</li>
<li>CPU不能再检查设备的过程中执行其他指令</li>
<li>很难处理同时发生的IO操作</li>
</ul>
<h4 id="中断IO"><a href="#中断IO" class="headerlink" title="中断IO"></a>中断IO</h4><ul>
<li>基于子程序调用，使得下一条指令为一个子程序调用的预定位置，返回位置被保存</li>
<li>CPU和设备之间通过总线连接</li>
<li>CPU和设设备之间进行握手</li>
<li>设备发出中断请求</li>
<li>当CPU能处理中断的时候发出中断确认请求</li>
</ul>
<h4 id="中断的两种机制"><a href="#中断的两种机制" class="headerlink" title="中断的两种机制"></a>中断的两种机制</h4><ul>
<li>优先级决定哪个中断先获得CPU</li>
<li>中断向量决定每个中断对应的执行代码</li>
</ul>
<h3 id="4-3-3-Programming-IO-Independent-IO-port-Memory-Mapped-IO"><a href="#4-3-3-Programming-IO-Independent-IO-port-Memory-Mapped-IO" class="headerlink" title="4.3.3 Programming IO: Independent IO port. Memory-Mapped IO"></a>4.3.3 Programming IO: Independent IO port. Memory-Mapped IO</h3><p><a target="_blank" rel="noopener" href="https://www.eefocus.com/embedded/399621">https://www.eefocus.com/embedded/399621</a></p>
<h4 id="Independent-IO"><a href="#Independent-IO" class="headerlink" title="Independent IO"></a>Independent IO</h4><ul>
<li>把外设的寄存器堪称一个独立的地址空间，访问地址的指令不能用来访问这些寄存器</li>
<li>CPU通过为外设寄存器的读写设置专用指令来访问这些空间中的地址单元</li>
<li>用于IO指令的地址空间相对来说是很小的，指令短，执行速度快，可读性强</li>
<li>专门的IO指令访问端口，IO端口地址可以和存储器地址重叠，并且不会相互混淆，</li>
<li>缺点：<ul>
<li>只能用专门的IO指令，访问端口的方法不如访问存储器的方法多</li>
</ul>
</li>
</ul>
<h4 id="Memory-Mapped-IO"><a href="#Memory-Mapped-IO" class="headerlink" title="Memory-Mapped IO"></a>Memory-Mapped IO</h4><ul>
<li>使用相同的地址总线来寻址内存和输入输出设备</li>
<li>前提是IO设备上的设备内存和寄存器是被映射到内存空间的某个地址的</li>
<li>当CPU访问某个地址的时候，可能是要访问物理内存，也可能是要访问IO设备上的内存</li>
<li>这样设备IO也可以通过内存访问指令来完成度鞋，每个IO设备会检测CPU的地址总线，如果地址区域是在本设备对应的地址区域的时候做出响应，创建数据总线和响应设备寄存器之间的连接</li>
<li>相应的地址空间必须给这些设备保留，并且不能再分配给系统物理内存</li>
<li>缺点<ul>
<li>对cache及其不友好</li>
<li>只有一个地址空间，性能方面更加薄弱</li>
</ul>
</li>
</ul>
<h3 id="4-3-4-GPIO接口基本原理与结构–"><a href="#4-3-4-GPIO接口基本原理与结构–" class="headerlink" title="4.3.4 GPIO接口基本原理与结构–"></a>4.3.4 GPIO接口基本原理与结构–</h3><h1 id="5-嵌入式系统软件知识"><a href="#5-嵌入式系统软件知识" class="headerlink" title="5. 嵌入式系统软件知识"></a>5. 嵌入式系统软件知识</h1><h2 id="5-1-嵌入式软件基础知识"><a href="#5-1-嵌入式软件基础知识" class="headerlink" title="5.1 嵌入式软件基础知识*"></a>5.1 嵌入式软件基础知识*</h2><h3 id="5-1-1-嵌入式软件的特点"><a href="#5-1-1-嵌入式软件的特点" class="headerlink" title="5.1.1 嵌入式软件的特点"></a>5.1.1 嵌入式软件的特点</h3><ul>
<li>实时性，嵌入式系统一般都对实时性有着比较高的要求，运行在上面的嵌入式软件</li>
<li>轻量性，嵌入式系统的的轻量性让嵌入式软件的代码量不能太大</li>
<li>独特性，一般在特定的嵌入式操作系统上才能运行</li>
<li>开发难度大，硬件资源有限，涉及底层开发，开发环境与运行环境不同</li>
<li>可靠性，抗干扰的能力更强</li>
<li>固态存储，结果通常需要固化在目标系统的存储器或者单片机中</li>
</ul>
<h3 id="5-1-2-嵌入式软件的分类（系统软件、支撑软件、应用软件）"><a href="#5-1-2-嵌入式软件的分类（系统软件、支撑软件、应用软件）" class="headerlink" title="5.1.2 嵌入式软件的分类（系统软件、支撑软件、应用软件）"></a>5.1.2 嵌入式软件的分类（系统软件、支撑软件、应用软件）</h3><h4 id="系统软件"><a href="#系统软件" class="headerlink" title="系统软件"></a>系统软件</h4><ul>
<li>控制和协调计算机以及外部设备，支持应用软件开发和运行的系统</li>
<li>无需用户干预的各种程序的集合</li>
<li>在购买计算机系统的时候随机携带，也可以根据需要自行安装</li>
<li>系统软件使得计算机使用者和其他软件将计算机当作一个整体</li>
</ul>
<h4 id="支撑软件"><a href="#支撑软件" class="headerlink" title="支撑软件"></a>支撑软件</h4><ul>
<li>支持其他软件的编制和维护，在软件开发中占有重要地位</li>
<li>位于系统软件和应用软件之间</li>
<li>提供应用软件设计、开发、测试、评估、运行检测等辅 助功能的软件</li>
</ul>
<h4 id="应用软件"><a href="#应用软件" class="headerlink" title="应用软件"></a>应用软件</h4><ul>
<li>用户可以使用的各种程序设计语言，以及用各种程序设计语言编制的应用程序的集合</li>
</ul>
<h3 id="5-1-3-嵌入式软件体系结构"><a href="#5-1-3-嵌入式软件体系结构" class="headerlink" title="5.1.3 嵌入式软件体系结构"></a>5.1.3 嵌入式软件体系结构</h3><h4 id="软件层次"><a href="#软件层次" class="headerlink" title="软件层次"></a>软件层次</h4><p><img src="https://cdn.nlark.com/yuque/0/2020/png/1096029/1604405247707-f24bafae-d62d-4a67-93eb-04852228f681.png" alt="image.png"></p>
<h4 id="轮询模式"><a href="#轮询模式" class="headerlink" title="轮询模式"></a>轮询模式</h4><ul>
<li>轮流询问各个task，如果需要服务，就提供服务，</li>
<li>没有优先级，所有的任务组成一个序列进行，一开始的顺序就决定了执行顺序，后面的任务的执行可能会降速</li>
<li>响应时间等于所有任务的时间的总和</li>
<li>改变的影响显著，一个任务的改变会影响其他所有的任务</li>
<li>没有共享数据的问题</li>
</ul>
<h4 id="状态机"><a href="#状态机" class="headerlink" title="状态机"></a>状态机</h4><ul>
<li>和轮训差不多，但是只有当前的状态会被执行，这里是switch，case，轮训是连续的if</li>
<li>每个状态决定了下一个状态，不是像轮训一样的sequential execution</li>
<li>每个状态决定了下一个状态的优先级</li>
<li>响应时间为所有任务的响应时间</li>
<li>改变任务或者增减任务会影响其他任务</li>
<li>简单，没有任务共享</li>
</ul>
<h4 id="中断轮询"><a href="#中断轮询" class="headerlink" title="中断轮询"></a>中断轮询</h4><ul>
<li>中断的优先级最高，在所有if的最开始，中断本身也有优先级</li>
<li>响应时间为所有任务的响应时间或者中断执行时间</li>
<li>在中断服务历程中，改变的影响不大，在主循环中和轮询是一样的</li>
<li>共享数据：要处理中断之间共享的数据</li>
</ul>
<h4 id="中断："><a href="#中断：" class="headerlink" title="中断："></a>中断：</h4><ul>
<li>中断太多会有问题</li>
<li>高优先级中断的执行时间长于低优先级中断的，可能会发生miss<ul>
<li>或者需要处理嵌套中断</li>
</ul>
</li>
<li>中断自带优先级</li>
<li>响应时间为中断的执行时间</li>
<li>改变带来的影响很小</li>
<li>需要处理中断之间的数据共享问题</li>
</ul>
<h4 id="函数队列"><a href="#函数队列" class="headerlink" title="函数队列"></a>函数队列</h4><ul>
<li>函数的指针被添加到队列中</li>
<li>循环遍历队列，执行任务</li>
<li>任务或者中断会插入新的任务</li>
<li>响应时间是最长的任务的执行时间</li>
<li>添加任务：<ul>
<li>先从当前任务index遍历到最后，有空指针就插入，然后返回</li>
<li>再从当前任务的index往前遍历，有空就插入，然后返回</li>
</ul>
</li>
<li>改变的影响小</li>
<li>中断优先级，任务依次执行</li>
<li>必须处理ISR之间的共享数据</li>
</ul>
<h4 id="函数队列的优化"><a href="#函数队列的优化" class="headerlink" title="函数队列的优化"></a>函数队列的优化</h4><ul>
<li>每一个task里面有一个time用来计时，时钟中断会降低所有task的time，当time到达0的时候，可以执行这个任务</li>
<li>每一个task里面增加优先级，高优先级的任务被添加到队列之前</li>
</ul>
<h2 id="5-2-嵌入式操作系统基础知识"><a href="#5-2-嵌入式操作系统基础知识" class="headerlink" title="5.2 嵌入式操作系统基础知识**"></a>5.2 嵌入式操作系统基础知识**</h2><h3 id="5-2-1-RTOS概念，特点，选型原则"><a href="#5-2-1-RTOS概念，特点，选型原则" class="headerlink" title="5.2.1 RTOS概念，特点，选型原则"></a>5.2.1 RTOS概念，特点，选型原则</h3><h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><ul>
<li>对外来时间能在限定的响应时间内作出处理的计算机系统</li>
<li>当外界事件或数据产生时，能够接受并以足够快的速度予以处理，其处理的结果又能在 规定的时间之内来控制生产过程或对处理系统做出快速响应</li>
<li>调度一切可利用的资源完成实时任务，并控制所有实时任务协调一致运行的操作系统。</li>
</ul>
<h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><ul>
<li>可移植性</li>
<li>强调实时性能</li>
<li>内核精简</li>
<li>抢占式内核</li>
<li>使用可重入函数</li>
<li>可配置</li>
<li>可裁剪</li>
<li>高可靠性。</li>
</ul>
<h4 id="选型原则"><a href="#选型原则" class="headerlink" title="选型原则"></a>选型原则</h4><ul>
<li>成本，使用的成本（购买）或者是学习使用的成本（开源）</li>
<li>可靠性，选择经得起时间考验的系统</li>
<li>实时性，挑选能满足自己需求的，实时性最契合的系统</li>
<li>工具链，能够选择工具链开发的权利，例如编译器，之类的</li>
<li>模块丰富，是否有集成好的模块，或者是不是支持集成外来模块，不会发生冲突</li>
<li>硬件，确保已有硬件资源能够保证顺畅的使用这个RTOS</li>
</ul>
<h3 id="5-2-2-任务管理"><a href="#5-2-2-任务管理" class="headerlink" title="5.2.2 任务管理"></a>5.2.2 任务管理</h3><h4 id="进程、线程、任务的概念"><a href="#进程、线程、任务的概念" class="headerlink" title="进程、线程、任务的概念"></a>进程、线程、任务的概念</h4><ul>
<li>进程是指运行中的应用程序，每一个进程都有自己的独立的内存空间，一个应用程序可以同时启动多个进程</li>
<li>线程是操作系统能够进行运算的最小单位，线程被包含在进程之中，是进程的世纪运行单位，一条线程就指进程中的单一顺序的控制流，一个进程中可以并行运行多个线程，线程自己不拥有系统资源，但是同一个进程之间的线程是共享进程的资源的</li>
<li>任务，是指软件完成的一个活动，又可以是一个进程，也可以是一个线程，简而言之就是指一系列共同达到某一目的的操作。</li>
</ul>
<h4 id="任务的实现（任务的层次结构，任务控制块，任务的状态以及状态转换，队列）"><a href="#任务的实现（任务的层次结构，任务控制块，任务的状态以及状态转换，队列）" class="headerlink" title="任务的实现（任务的层次结构，任务控制块，任务的状态以及状态转换，队列）"></a>任务的实现（任务的层次结构，任务控制块，任务的状态以及状态转换，队列）</h4><ul>
<li>任务的层次结构：</li>
<li>任务控制块：描述一个任务的核心数据结构，存放了它的各种管理信息，包括 任务堆栈指针，任务的状态、优先级，任务链表指针等; 一旦任务建立了，任务控制块 OS_TCB将被赋值。</li>
<li>任务状态以及状态转换</li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2020/png/1096029/1604407433552-99c7527c-7d10-4492-94fe-a08703d41859.png" alt="image.png"></p>
<ul>
<li>任务队列：系统未必能够及时处理所有任务，根据功能的不同，分为空闲队列，就绪队列，等待队列，挂起队列等等，保存未被处理的任务，后面再由调度器调度</li>
</ul>
<h4 id="任务调度（可抢占调度，不可抢占调度，先来先服务，时间片轮转算法，优先级算法）"><a href="#任务调度（可抢占调度，不可抢占调度，先来先服务，时间片轮转算法，优先级算法）" class="headerlink" title="任务调度（可抢占调度，不可抢占调度，先来先服务，时间片轮转算法，优先级算法）"></a>任务调度（可抢占调度，不可抢占调度，先来先服务，时间片轮转算法，优先级算法）</h4><ul>
<li>抢占式调度：<ul>
<li>任何时刻，最高优先级的任务被执行，如果产生了新的优先级变化或者任务状态的变化，内核可以调度新的优先级的任务来执行</li>
</ul>
</li>
<li>不可抢占调度：<ul>
<li>系统一旦把处理器分配给就绪队列中优先级最高的任务后，该任务一直执行直到完成，或者直到某个事件发生让该进程放弃处理的时候，系统才能分配cpu给其他任务</li>
</ul>
</li>
<li>先来先服务<ul>
<li>总是把处于就绪队列之首的那个任务调度到运行状态，只考虑进入就绪队列的先后，不考虑其他因素，非抢占式的调度</li>
</ul>
</li>
<li>时间片轮转<ul>
<li>每个进程被分配一个时间段，称为时间片，就是该进程允许运行的时间</li>
<li>如果在时间片结束还在运行，CPU被剥夺，跟赔给另一个进程，没有被执行完的进入队列尾部</li>
<li>如果在时间片内执行结束，cpu立刻切换</li>
</ul>
</li>
</ul>
<h4 id="实时系统以及任务调度（RMS，EDF算法）"><a href="#实时系统以及任务调度（RMS，EDF算法）" class="headerlink" title="实时系统以及任务调度（RMS，EDF算法）"></a>实时系统以及任务调度（RMS，EDF算法）</h4><ul>
<li>RMS单一速率调度，静态调度策略<ul>
<li>分配给每个进程的优先级是固定不变的</li>
<li>周期最短的进程优先级最高</li>
</ul>
</li>
<li>EDF<ul>
<li>根据截至时限的顺序制定优先级，最高优先级的进程是当前截止实现最邻近的进程</li>
</ul>
</li>
</ul>
<h4 id="任务间通信（共享内存、消息、管道、信号）"><a href="#任务间通信（共享内存、消息、管道、信号）" class="headerlink" title="任务间通信（共享内存、消息、管道、信号）"></a>任务间通信（共享内存、消息、管道、信号）</h4><ul>
<li><strong>共享内存</strong>直接申请一块物理内存通过页表映射到虚拟地址空间中，操作虚拟地址空间，其实是操作同一块物理内存区域，因此进行数据传输时相较于其他通信方式，少了两步用户态与内核态数据拷贝的过 程，因此共享内存是最快的进程间通信方式。</li>
<li><strong>消息队列</strong>实际上是操作系统在内核为我们创建的一个队列，通过这个队列的标识符key,每一个进程都可以打开这个队列，每个进程都可以通过这个队列向这个队列中插入一个结点或者获取一个结点来完成不同进程间的通信。</li>
<li><strong>管道通信</strong>的中间介质是文件，通常称这种文件为管道文件。两个进程利用管道文件进行通信时，一 个进程为写进程，另一个进程为读进程。写进程通过写端(发送端)往管道文件中写入信息;读进程通过读端(接收端)从管道文件中读取信息。两个进程协调不断地进行写、读，便会构成双方通过管道传 递信息的流水线。</li>
<li>信号，进程间通信方式之一，用于实现进程之间的同步与互斥</li>
</ul>
<h4 id="同步与互斥（竞争条件、临界区、互斥、信号量、死锁）"><a href="#同步与互斥（竞争条件、临界区、互斥、信号量、死锁）" class="headerlink" title="同步与互斥（竞争条件、临界区、互斥、信号量、死锁）"></a>同步与互斥（竞争条件、临界区、互斥、信号量、死锁）</h4><ul>
<li>竞争条件<ul>
<li>多个进程或者线程在读写一个共享数据时结果依赖于它们执行的相对时间的情形。</li>
<li>假设两个进程P1和P2共享了变量a。在某一执行时刻，P1更新a为1，在另一时 刻，P2更新a为2。</li>
<li>因此两个任务竞争地写变量a。在这个例子中，竞争的“失败者”(最后 更新的进程)决定了变量a的最终值。</li>
</ul>
</li>
<li>临界区<ul>
<li>一个访问共用资源的程序片段</li>
<li>但是这些共用资源不能被多个线程访问</li>
</ul>
</li>
<li>互斥<ul>
<li>任务A在运行某个程序片段时，其他任务不能运行该程序片段，就说这两个任务存在互斥关系。</li>
</ul>
</li>
<li>信号量<ul>
<li>用来保证两个或者多个关键代码段不被并发调用，在进入一个关键代码段之前，线程必须获取一个信号量；一旦该关键代码段完成了，那么该线程必须释放信号量</li>
<li>其它想进入该关键代码段的线程必须等待直到第一个线程释放信号量</li>
<li>对信号量的操作都是原语</li>
<li>两个进程共享信号量sv，一旦其中一个进程执行了P(sv)操作，它将得到信号量，并可以进入临界区，使sv减1。而第二个进程将被阻止进入临界区，因为当它试图执行P(sv)时，sv为0，它会被挂起以等待第一个进程离开临界区域并执行V(sv)释放信号量，这时第二个进程就可以恢复执行。</li>
</ul>
</li>
<li>死锁<ul>
<li>两个或两个以上的进程在执行过程中，由于竞争资源或者由于彼此通信而造 成的一种阻塞的现象</li>
</ul>
</li>
</ul>
<p>线程1锁住了记录1并且等待记录2，线程2锁定了记录2并等待记录1</p>
<h3 id="5-2-3-存储管理"><a href="#5-2-3-存储管理" class="headerlink" title="5.2.3 存储管理"></a>5.2.3 存储管理</h3><h4 id="嵌入式系统静态和动态内存管理"><a href="#嵌入式系统静态和动态内存管理" class="headerlink" title="嵌入式系统静态和动态内存管理*"></a>嵌入式系统静态和动态内存管理*</h4><ul>
<li>静态分配：在编译的时候分配</li>
<li>动态分配：在任务运行的时候使用malloc函数来动态申请内存空间</li>
<li>在动态分配中，可能存在内存碎片问题，特别是当用户反复的建立和删除任务的时候，内存堆中可能会存在大量的碎片，导致没有足够大的一块连续内存区域可用作任务栈，这时malloc()便无法成功地为任务分配栈空间。 μC/OS采用的是固定分区的存储管理方法，用以解决碎片问题</li>
</ul>
<h3 id="5-2-4-设备管理–"><a href="#5-2-4-设备管理–" class="headerlink" title="5.2.4 设备管理–"></a>5.2.4 设备管理–</h3><h3 id="5-2-5-文件系统基础知识–"><a href="#5-2-5-文件系统基础知识–" class="headerlink" title="5.2.5 文件系统基础知识–"></a>5.2.5 文件系统基础知识–</h3><h3 id="5-2-6-操作系统移植基础知识–"><a href="#5-2-6-操作系统移植基础知识–" class="headerlink" title="5.2.6 操作系统移植基础知识–"></a>5.2.6 操作系统移植基础知识–</h3><h2 id="5-3-嵌入式系统程序设计–"><a href="#5-3-嵌入式系统程序设计–" class="headerlink" title="5.3 嵌入式系统程序设计–"></a>5.3 嵌入式系统程序设计–</h2><h3 id="5-3-1-嵌入式软件开发基础知识"><a href="#5-3-1-嵌入式软件开发基础知识" class="headerlink" title="5.3.1 嵌入式软件开发基础知识"></a>5.3.1 嵌入式软件开发基础知识</h3><h3 id="5-3-2-嵌入式程序设计语言"><a href="#5-3-2-嵌入式程序设计语言" class="headerlink" title="5.3.2 嵌入式程序设计语言"></a>5.3.2 嵌入式程序设计语言</h3><h3 id="5-3-3-嵌入式软件开发环境"><a href="#5-3-3-嵌入式软件开发环境" class="headerlink" title="5.3.3 嵌入式软件开发环境"></a>5.3.3 嵌入式软件开发环境</h3><h3 id="5-3-4-嵌入式软件开发"><a href="#5-3-4-嵌入式软件开发" class="headerlink" title="5.3.4 嵌入式软件开发"></a>5.3.4 嵌入式软件开发</h3><h1 id="6-嵌入式实时内核（结合-ucOS-II-和-freertos）"><a href="#6-嵌入式实时内核（结合-ucOS-II-和-freertos）" class="headerlink" title="6. 嵌入式实时内核（结合 ucOS-II 和 freertos）**"></a>6. 嵌入式实时内核（结合 ucOS-II 和 freertos）**</h1><h2 id="6-1-实时任务调度"><a href="#6-1-实时任务调度" class="headerlink" title="6.1 实时任务调度"></a>6.1 实时任务调度</h2><ul>
<li>μC/OS_II进行任务调度的思想是 “近似地每时每刻总是让优先级最高的就绪任务处于运行状 态” 。为了保证这一点，它在系统或用户任务调用系统函数及执行中断服务程序结束时总是调 用调度器，来确定应该运行的任务并运行它。</li>
<li>μC/OS_II进行任务调度的依据就是任务就绪表</li>
<li>空闲任务(把32位计数器OSIdleCtr加1，该计数器被统计任务所使用)、统计任务(提供运行时间统计，可以计算当前CPU的利用率)、任务控制块、空闲列表、任务就绪表</li>
</ul>
<h2 id="6-2-中断与时钟"><a href="#6-2-中断与时钟" class="headerlink" title="6.2 中断与时钟"></a>6.2 中断与时钟</h2><h4 id="中断"><a href="#中断" class="headerlink" title="中断"></a>中断</h4><ul>
<li>μC/OS-II系统响应中断的过程为:系统接收到中断请求后，这时如果CPU处于中断允许状态(即中断是开放的)，系统就会中止正在运行的当前任务</li>
<li>而按照中断向量的指向转而去运行中断服务子程序</li>
<li>当中断服务子程序的运行结束后，系统将会根据情况返回到被中止的任务继续运行</li>
<li>或者转向运行另一个具有更高优先级别的就绪任务。</li>
</ul>
<h3 id="时钟"><a href="#时钟" class="headerlink" title="时钟"></a>时钟</h3><ul>
<li>OSTimeDLY():任务延时函数，申请该服务的任务可以延时一段时间 </li>
<li>OSTimeDLYHMSM():OSTimeDly()的另一个版本，即按时分秒延时函数 </li>
<li>OSTimeDlyResume():让处在延时期的任务提前结束延时，进入就绪状态 </li>
<li>OSTimeGet():获得该计数器的当前值</li>
</ul>
<h2 id="6-3-同步与通信"><a href="#6-3-同步与通信" class="headerlink" title="6.3 同步与通信"></a>6.3 同步与通信</h2><blockquote>
<p>系统中的多个任务在运行的时候，经常需要互相没有冲突的访问同一个共享资源，或者需要互相支持和依赖和互相的限制和制约才能保证任务的顺利运行<br>操作系统必须具有对任务的运行进行协调的能力</p>
</blockquote>
<h4 id="事件控制块ECB"><a href="#事件控制块ECB" class="headerlink" title="事件控制块ECB"></a>事件控制块ECB</h4><ul>
<li>任务间通信的管理核心</li>
</ul>
<h4 id="同步与互斥"><a href="#同步与互斥" class="headerlink" title="同步与互斥"></a>同步与互斥</h4><ul>
<li>临界区</li>
<li>信号量</li>
</ul>
<h4 id="低级通信"><a href="#低级通信" class="headerlink" title="低级通信"></a>低级通信</h4><ul>
<li>只能传递状态和整数值等控制信息，传送的信息量小</li>
</ul>
<h4 id="高级通信"><a href="#高级通信" class="headerlink" title="高级通信"></a>高级通信</h4><ul>
<li>共享内存</li>
<li>邮箱：可以使得一个任务或者中断服务子程序向另一个任务 发送一个指针型的变量，通常指针指向一个包含了消息的特定数据结构</li>
<li>消息队列：邮箱数组</li>
</ul>
<h2 id="6-4-存储管理（静态、动态）"><a href="#6-4-存储管理（静态、动态）" class="headerlink" title="6.4 存储管理（静态、动态）"></a>6.4 存储管理（静态、动态）</h2><h4 id="μC-OS"><a href="#μC-OS" class="headerlink" title="μC/OS"></a>μC/OS</h4><ul>
<li>采用固定分区的存储管理方法</li>
<li>把连续的大块内存按照分区来管理，每个分区包含有整数个大小相同的块</li>
<li>在一个系统中可以有多个内存分区，这样用户的应用程序就可以从不同的内存分区中得到不同大小的内存块</li>
<li>特定的内存块在释放的时候必须重新放回它之前所属于的内存分区</li>
<li>从而解决了内存碎片问题<h1 id="7-bsp，bootloader"><a href="#7-bsp，bootloader" class="headerlink" title="7. bsp，bootloader"></a>7. bsp，bootloader</h1></li>
</ul>
<h2 id="7-1-嵌入式系统的启动过程"><a href="#7-1-嵌入式系统的启动过程" class="headerlink" title="7.1 嵌入式系统的启动过程"></a>7.1 嵌入式系统的启动过程</h2><p><img src="https://cdn.nlark.com/yuque/0/2020/png/1096029/1604410459458-d39958b0-12e4-4309-9929-863f7b988852.png" alt="image.png"></p>
<h4 id="上电复位和板级初始化"><a href="#上电复位和板级初始化" class="headerlink" title="上电复位和板级初始化"></a>上电复位和板级初始化</h4><ul>
<li>上电复位后完成板级初始化工作</li>
<li>板级初始化程序具有完全的硬件特性，一般采用汇编语言 实现</li>
</ul>
<h4 id="系统引导阶段"><a href="#系统引导阶段" class="headerlink" title="系统引导阶段"></a>系统引导阶段</h4><ul>
<li>软件可压缩存储在Flash中，拿出来在ram中运行</li>
<li>也可以直接在NorFlash中运行</li>
<li>也可以从外存中读取出来加载到RAM中运行</li>
</ul>
<h4 id="系统升级阶段"><a href="#系统升级阶段" class="headerlink" title="系统升级阶段"></a>系统升级阶段</h4><ul>
<li>可通过网络进行升级</li>
<li>或者是通过串口进行本地升级</li>
</ul>
<h4 id="系统初始化阶段"><a href="#系统初始化阶段" class="headerlink" title="系统初始化阶段"></a>系统初始化阶段</h4><ul>
<li>进行操作系统等系统软件各功能部分必需的初始化工作，例如根据系统配置初始化数据空间、 初始化系统所需的接口和外设等</li>
<li>需要按特定顺序进行，如首先完成内核的初始化，然后完成网络、文件系统等的初始 化，最后完成中间件等的初始化工作</li>
</ul>
<h4 id="应用初始化阶段"><a href="#应用初始化阶段" class="headerlink" title="应用初始化阶段"></a>应用初始化阶段</h4><ul>
<li>进行应用任务的创建，信号量、消息队列 的创建和与应用相关的其它初始化工作</li>
</ul>
<h4 id="多任务应用运行阶段"><a href="#多任务应用运行阶段" class="headerlink" title="多任务应用运行阶段"></a>多任务应用运行阶段</h4><ul>
<li>各种初始化工作完成后，系统进入多任务状态，操 作系统按照已确定的算法进行任务的调度，各应用 任务分别完成特定的功能。</li>
</ul>
<h2 id="7-2-bsp，特点，与bios区别"><a href="#7-2-bsp，特点，与bios区别" class="headerlink" title="7.2 bsp，特点，与bios区别"></a>7.2 bsp，特点，与bios区别</h2><h3 id="BSP"><a href="#BSP" class="headerlink" title="BSP"></a>BSP</h3><blockquote>
<p>全称“板级支持包”(Board Support Packages)，类似于一段启动代码，跟计算机主板上的BIOS差不多，但是提供的功能区别相差很大<br>处于硬件和实时内核之间</p>
</blockquote>
<h3 id="特点-1"><a href="#特点-1" class="headerlink" title="特点"></a>特点</h3><ul>
<li>硬件相关性:因为嵌入式实时系统的硬件环境具有相关性，所以，作为高层软件与硬件之间的接口，BSP 必须<strong>为操作系统提供操作和控制具体硬件的方法</strong>。</li>
<li>操作系统相关性，:不同的操作系统具有各自的软件层次结构，因此，<strong>不同的操作系统具有特定的硬件接口形式</strong></li>
</ul>
<h3 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h3><ul>
<li>BIOS主要是负责在电脑开启时检测、初始化系统设备(设置 栈指针，中断分配，内存初始化..)、装入操作系统并调度操 作系统向硬件发出的指令。BIOS程序是用户不能更改的，只能改变传入的参数</li>
<li>UEFI,“统一的可扩展固件接口”, 旨在代替BIOS, 提高软件互操作性和解决BIOS的局限性。UEFI作为旧式BIOS的后继者，用来定义操作系统与系统固件之间的软件界面，作为BIOS的替代方案，UEFI没有加电自检过程（Windows），加快了启动方式</li>
<li>BSP是和操作系统绑在一起运行，尽管BSP的开始部分和BIOS 所做的工作类似，但是 BSP还包含和系统有关的基本驱动，用户可以编程修改BSP，添加一些与系统无关的驱动或者程序</li>
</ul>
<h2 id="7-3-引导模式"><a href="#7-3-引导模式" class="headerlink" title="7.3 引导模式"></a>7.3 引导模式</h2><blockquote>
<p>引导：将操作系统装入内存并开始执行的过程</p>
</blockquote>
<h4 id="不需要BootLoader的引导模式"><a href="#不需要BootLoader的引导模式" class="headerlink" title="不需要BootLoader的引导模式"></a>不需要BootLoader的引导模式</h4><ul>
<li>时间效率高，系统快速启动，直接在非易失性存储介质中运行，但是不满足运行速度的要求</li>
</ul>
<h4 id="需要BootLoader的引导模式"><a href="#需要BootLoader的引导模式" class="headerlink" title="需要BootLoader的引导模式"></a>需要BootLoader的引导模式</h4><ul>
<li>节省空间，牺牲时间，硬件成本低，运行速度快，启动速度比较慢，在RAM中运行，内核被压缩，搬迁到内存后被展开</li>
</ul>
<h2 id="7-4-bootloader及其启动过程"><a href="#7-4-bootloader及其启动过程" class="headerlink" title="7.4 bootloader及其启动过程"></a>7.4 bootloader及其启动过程</h2><h4 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h4><ul>
<li>嵌入式系统中的OS启动加载程序</li>
<li>引导加载程序包括两部分，一部分是固件中的boot代码，一部分是BootLoader</li>
<li>是系统加电后运行的第一部分<strong>软件代码</strong></li>
<li>对于操作系统来说，相当于一个硬件抽象层</li>
</ul>
<h4 id="启动第一阶段"><a href="#启动第一阶段" class="headerlink" title="启动第一阶段"></a>启动第一阶段</h4><ul>
<li>硬件设备初始化</li>
<li>为加载BootLoader的第二阶段准备ram空间</li>
<li>拷贝第二阶段的代码到ram空间中</li>
<li>设置好堆栈</li>
<li>跳转到stage2的入口</li>
</ul>
<h4 id="启动第二阶段"><a href="#启动第二阶段" class="headerlink" title="启动第二阶段"></a>启动第二阶段</h4><ul>
<li>初始化本阶段要用到的硬件设备</li>
<li>检测系统内存映射</li>
<li>将内核映像和根文件系统映像从falsh上读取到ram空间中</li>
<li>为内核设置启动参数</li>
<li>调用内核，内核接管</li>
</ul>
<h1 id="8-建模"><a href="#8-建模" class="headerlink" title="8. 建模**"></a>8. 建模**</h1><h2 id="8-1-有限状态机及其应用"><a href="#8-1-有限状态机及其应用" class="headerlink" title="8.1 有限状态机及其应用"></a>8.1 有限状态机及其应用</h2><h4 id="概念-2"><a href="#概念-2" class="headerlink" title="概念"></a>概念</h4><ul>
<li>一个有限状态机是一个设备，或者是一个设备模型，具有有限数量的状态，它可以在任何给定的时间根据输入进行操作，使得一个状态变换到另一个状态，或者是使一个输入或者一种行为的发生。一个有限状态机在任何瞬间只能处在一种状态。</li>
<li>状态寄存器的下一个状态不仅与输入信号有关，还与当前该寄存器的状态有关</li>
</ul>
<h4 id="Moore状态机"><a href="#Moore状态机" class="headerlink" title="Moore状态机"></a>Moore状态机</h4><ul>
<li>状态的输出只依赖于当前状态</li>
</ul>
<h4 id="Mealy状态机"><a href="#Mealy状态机" class="headerlink" title="Mealy状态机"></a>Mealy状态机</h4><ul>
<li>状态的输出依赖于输入和当前状态</li>
</ul>
<h4 id="分层状态机"><a href="#分层状态机" class="headerlink" title="分层状态机"></a>分层状态机</h4><p><img src="https://cdn.nlark.com/yuque/0/2020/png/1096029/1604414267400-53f8be82-d8ee-4fde-b409-85df5c7d6673.png1" alt="image.png"></p>
<h2 id="8-2-有限状态机的实现"><a href="#8-2-有限状态机的实现" class="headerlink" title="8.2 有限状态机的实现"></a>8.2 有限状态机的实现</h2><h4 id="switch-case的实现"><a href="#switch-case的实现" class="headerlink" title="switch-case的实现"></a>switch-case的实现</h4><h4 id="表驱动，函数指针实现"><a href="#表驱动，函数指针实现" class="headerlink" title="表驱动，函数指针实现"></a>表驱动，函数指针实现</h4><h4 id="if-else实现"><a href="#if-else实现" class="headerlink" title="if-else实现"></a>if-else实现</h4><h4 id="状态模式"><a href="#状态模式" class="headerlink" title="状态模式"></a>状态模式</h4><p>更易于维护和拓展，降低了实际状态之间的耦合，通过抽象接口来实现，当需要修改或者添加状态的时候，只需要修改内部实现，不用改变接口</p>
<p>​                                                            </p>
<p>​                                                            </p>

        </div>

        
            <section class="post-copyright">
                
                    <p class="copyright-item">
                        <span>Author:</span>
                        <span>Cynyard Qiu</span>
                    </p>
                
                
                
                

            </section>
        
        <section class="post-tags">
            <div>
                <span>Tag(s):</span>
                <span class="tag">
                    
                    
                        <a href="/tags/writing/"># writing</a>
                    
                        
                </span>
            </div>
            <div>
                <a href="javascript:window.history.back();">back</a>
                <span>· </span>
                <a href="/">home</a>
            </div>
        </section>
        <section class="post-nav">
            
                <a class="prev" rel="prev" href="/2021/01/15/Jekyll-to-Hexo/">从Jekyll到Hexo</a>
            
            
            <a class="next" rel="next" href="/2020/11/01/DHT/">分布式哈希表</a>
            
        </section>


    </article>
</div>

        </div>
        <footer id="footer" class="footer">
    <div class="copyright">
        <span>© Cynyard Qiu | Powered by <a href="https://hexo.io" target="_blank">Hexo</a> & <a href="https://github.com/Siricee/hexo-theme-Chic" target="_blank">Chic</a></span>
    </div>
</footer>

    </div>
</body>
</html>

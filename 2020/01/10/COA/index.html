<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
<meta name="viewport"
      content="width=device-width, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
<meta http-equiv="X-UA-Compatible" content="ie=edge">
<meta name="referrer" content="no-referrer" />

    <meta name="author" content="Cynyard Qiu">





<title>计算机组织机构（1） | Cynyard&#39;s Blog</title>



    <link rel="icon" href="/cloud.ico">




    <!-- stylesheets list from _config.yml -->
    
    <link rel="stylesheet" href="/css/style.css">
    



    <!-- scripts list from _config.yml -->
    
    <script src="/js/script.js"></script>
    
    <script src="/js/tocbot.min.js"></script>
    



    
    
        
    


<meta name="generator" content="Hexo 5.3.0"></head>
<body>
    <div class="wrapper">
        <header>
    <nav class="navbar">
        <div class="container">
            <div class="navbar-header header-logo"><a href="/">Cynyard&#39;s Blog</a></div>
            <div class="menu navbar-right">
                
                    <a class="menu-item" href="/archives">Posts</a>
                
                    <a class="menu-item" href="/category">Categories</a>
                
                    <a class="menu-item" href="/tag">Tags</a>
                
                    <a class="menu-item" href="/about">About</a>
                
                <input id="switch_default" type="checkbox" class="switch_default">
                <label for="switch_default" class="toggleBtn"></label>
            </div>
        </div>
    </nav>

    
    <nav class="navbar-mobile" id="nav-mobile">
        <div class="container">
            <div class="navbar-header">
                <div>
                    <a href="/">Cynyard&#39;s Blog</a><a id="mobile-toggle-theme">·&nbsp;Light</a>
                </div>
                <div class="menu-toggle" onclick="mobileBtn()">&#9776; Menu</div>
            </div>
            <div class="menu" id="mobile-menu">
                
                    <a class="menu-item" href="/archives">Posts</a>
                
                    <a class="menu-item" href="/category">Categories</a>
                
                    <a class="menu-item" href="/tag">Tags</a>
                
                    <a class="menu-item" href="/about">About</a>
                
            </div>
        </div>
    </nav>

</header>
<script>
    var mobileBtn = function f() {
        var toggleMenu = document.getElementsByClassName("menu-toggle")[0];
        var mobileMenu = document.getElementById("mobile-menu");
        if(toggleMenu.classList.contains("active")){
           toggleMenu.classList.remove("active")
            mobileMenu.classList.remove("active")
        }else{
            toggleMenu.classList.add("active")
            mobileMenu.classList.add("active")
        }
    }
</script>
        <div class="main">
            <div class="container">
    
    
        <div class="post-toc">
    <div class="tocbot-list">
    </div>
    <div class="tocbot-list-menu">
        <a class="tocbot-toc-expand" onclick="expand_toc()">Expand all</a>
        <a onclick="go_top()">Back to top</a>
        <a onclick="go_bottom()">Go to bottom</a>
    </div>
</div>

<script>
    document.ready(
        function () {
            tocbot.init({
                tocSelector: '.tocbot-list',
                contentSelector: '.post-content',
                headingSelector: 'h1, h2, h3, h4, h5',
                collapseDepth: 1,
                orderedList: false,
                scrollSmooth: true,
            })
        }
    )

    function expand_toc() {
        var b = document.querySelector(".tocbot-toc-expand");
        tocbot.init({
            tocSelector: '.tocbot-list',
            contentSelector: '.post-content',
            headingSelector: 'h1, h2, h3, h4, h5',
            collapseDepth: 6,
            orderedList: false,
            scrollSmooth: true,
        });
        b.setAttribute("onclick", "collapse_toc()");
        b.innerHTML = "Collapse all"
    }

    function collapse_toc() {
        var b = document.querySelector(".tocbot-toc-expand");
        tocbot.init({
            tocSelector: '.tocbot-list',
            contentSelector: '.post-content',
            headingSelector: 'h1, h2, h3, h4, h5',
            collapseDepth: 1,
            orderedList: false,
            scrollSmooth: true,
        });
        b.setAttribute("onclick", "expand_toc()");
        b.innerHTML = "Expand all"
    }

    function go_top() {
        window.scrollTo(0, 0);
    }

    function go_bottom() {
        window.scrollTo(0, document.body.scrollHeight);
    }

</script>
    

    
    <article class="post-wrap">
        <header class="post-header">
            <h1 class="post-title">计算机组织机构（1）</h1>
            
                <div class="post-meta">
                    
                        Author: <a itemprop="author" rel="author" href="/">Cynyard Qiu</a>
                    

                    
                        <span class="post-time">
                        Date: <a href="#">January 10, 2020&nbsp;&nbsp;0:14:00</a>
                        </span>
                    
                    
                        <span class="post-category">
                    Category:
                            
                                <a href="/categories/Course/">Course</a>
                            
                        </span>
                    
                    
                </div>
            
        </header>

        <div class="post-content">
            <h1 id="课程笔记"><a href="#课程笔记" class="headerlink" title="课程笔记"></a>课程笔记</h1><h2 id="Lecture-00"><a href="#Lecture-00" class="headerlink" title="Lecture 00"></a>Lecture 00</h2><h4 id="技术的不平衡"><a href="#技术的不平衡" class="headerlink" title="技术的不平衡"></a>技术的不平衡</h4><p>设计计算机系统获得高性能，但是处理器速度，存储器速度，存储容量与互联数据速率都在迅速提高，并且在以不同的速度提高，像设计出均衡的系统，但是技术的不平衡使其难以实现</p>
<h2 id="Lecture-01"><a href="#Lecture-01" class="headerlink" title="Lecture 01"></a>Lecture 01</h2><h4 id="通用电子计算机"><a href="#通用电子计算机" class="headerlink" title="通用电子计算机"></a>通用电子计算机</h4><blockquote>
<p>每个计算机都能完成同样的任务，并且不需要重新设计。</p>
</blockquote>
<ol>
<li>通用：不是专用设备，所有计算机足够时间和存储空间能完成相同计算，新的计算不需要重新设计</li>
<li>电子：电子元件</li>
<li>数字：信息采用数字化的形式表示</li>
</ol>
<h4 id="计算机系统"><a href="#计算机系统" class="headerlink" title="计算机系统"></a>计算机系统</h4><ul>
<li>硬件</li>
<li>软件</li>
</ul>
<h4 id="结构与组织的差别"><a href="#结构与组织的差别" class="headerlink" title="结构与组织的差别"></a>结构与组织的差别</h4><ul>
<li>Architecture对程序员可见并且直接影响了程序的执行（指令集…,不同数据类型需要的位数）</li>
<li>Organization对程序员不可见，操作单元及其相互之间的联系，对程序员没有直接影响。</li>
</ul>
<h4 id="历史"><a href="#历史" class="headerlink" title="历史"></a>历史</h4><p>冯诺依曼：</p>
<ul>
<li>核心：用主存存放指令以及数据<blockquote>
<p>在断电情况下，主存里面什么都没有，程序是保存在硬盘中的，通过载入内存才能运行，CPU只从内存中读取数据与指令，但是不能在内存中完成计算功能<br>CPU区分数据和指令的依据就是不同指令阶段取得的不同</p>
</blockquote>
</li>
</ul>
<p>摩尔定律：一块芯片上的晶体管数量每隔一年/18个月就能翻一番</p>
<blockquote>
<p>晶体管数量增加或者芯片的减少：性能以及便捷度，功耗降低，价格便宜</p>
</blockquote>
<p>真空管-晶体管-小中大规模集成电路</p>
<ul>
<li>真空管</li>
<li>晶体管：更小，更便宜，热量更少&gt;更复杂的算术逻辑控制单元</li>
<li>集成电路：在一块硅片上组装电路</li>
</ul>
<h4 id="Performance"><a href="#Performance" class="headerlink" title="Performance"></a>Performance</h4><blockquote>
<p>数据的处理，存储，移动</p>
</blockquote>
<ul>
<li><p><strong>时钟</strong>：一个脉冲</p>
</li>
<li><p><strong>时钟频率</strong>： 一秒钟内一个计算机能完成的最多的最基础操作的数量</p>
</li>
<li><p><strong>时钟周期</strong>： 两个脉冲间的时间</p>
<blockquote>
<p>两个机器执行一个任务需要的时钟周期数可能不同，不能确定时钟频率更大的一定更快</p>
</blockquote>
</li>
<li><p><strong>CPI（Cycles per Instruction）I（The Number of Instructions）</strong></p>
</li>
</ul>
<p><img src="https://cynyard-blog-pics.oss-cn-beijing.aliyuncs.com/image/1599740323377-ea465a42-b617-4100-b57d-61a7bee2e68b.png" alt="image.png"></p>
<ul>
<li><strong>MIPS（Million Instructions per Second）</strong>可以找一些耗时的指令，对自己的cpu做特定的优化</li>
</ul>
<p><img src="https://cynyard-blog-pics.oss-cn-beijing.aliyuncs.com/image/1599740353263-c55175c1-80f0-4c9c-b914-694f616bd745.png" alt="image.png"></p>
<h4 id="CPU"><a href="#CPU" class="headerlink" title="CPU"></a>CPU</h4><blockquote>
<p>Central Processing Units：CPU直接与内存打交道，它会读取内存中的数据进行处理，并将结果保存到内存。如果需要保存到硬盘，才会将内存中的数据复制到硬盘。</p>
</blockquote>
<ul>
<li>计算机由存储器（M），IO，CPU以及系统总线组成</li>
<li>CPU由控制器，算术逻辑单元（ALU/CA），寄存器，CPU内部互联组成</li>
<li>控制器由顺序逻辑，控制器的寄存器与译码器，控制存储器组成。<blockquote>
<p> 以上每层次的部件相互都有交集</p>
</blockquote>
</li>
</ul>
<h2 id="Lecture-02"><a href="#Lecture-02" class="headerlink" title="Lecture 02"></a>Lecture 02</h2><h3 id="计算机结构"><a href="#计算机结构" class="headerlink" title="计算机结构"></a>计算机结构</h3><blockquote>
<p>各个部件的发展速度不均衡</p>
</blockquote>
<h4 id="关键概念"><a href="#关键概念" class="headerlink" title="关键概念"></a>关键概念</h4><ul>
<li>数据与指令存于读写的存储器中</li>
<li>存储器中的内容由其位置（location）寻址，无论存储的数据类型是什么。</li>
<li>指令的执行按照一定顺序，除非被明确的调整。</li>
</ul>
<h4 id="存储器的问题"><a href="#存储器的问题" class="headerlink" title="存储器的问题"></a>存储器的问题</h4><blockquote>
<p>不能跟上cpu的速度，Memory Wall</p>
</blockquote>
<ul>
<li>使DRAM的接口更宽而不是更深，增加总线的数据宽度，增加每次能取出的位数</li>
<li>加入高速缓存Cache或者其他缓冲机制来改进，减少存储器的访问频度和数据传输率</li>
<li>通过使用高速总线与分层总线来缓冲并且使数据流结构化，增加处理器与存储器之间相互连接的带宽</li>
</ul>
<h4 id="对存储器的要求"><a href="#对存储器的要求" class="headerlink" title="对存储器的要求"></a>对存储器的要求</h4><ul>
<li>大存储容量，高速的性能，合理的价格——采用多内存层次体系</li>
</ul>
<h4 id="IO的问题"><a href="#IO的问题" class="headerlink" title="IO的问题"></a>IO的问题</h4><blockquote>
<p>不能跟上CPU的速度，不同的I/O有不同的速率</p>
</blockquote>
<ul>
<li>Buffering 不同的io传输的数据量不同</li>
<li>New interface techniques更好的接口</li>
</ul>
<h4 id="CPU（Central-Processing-Units）"><a href="#CPU（Central-Processing-Units）" class="headerlink" title="CPU（Central Processing Units）"></a>CPU（Central Processing Units）</h4><ul>
<li>问题：cpu在等待I/O的时候闲置<ul>
<li>中断：一种能够打断正常运行序列的机制</li>
<li>让cpu在执行完指令后去check是否有中断</li>
<li>按顺序处理处理中断-不能及时响应更重要的中断</li>
<li>嵌套中断-避免错失更重要的中断</li>
</ul>
</li>
</ul>
<h4 id="Bus"><a href="#Bus" class="headerlink" title="Bus"></a>Bus</h4><blockquote>
<p>如何连接各个模块？</p>
</blockquote>
<ul>
<li>多路传送与总线</li>
<li>Communication pathway connecting two or more devices</li>
<li>Type：<ul>
<li>Data lines: 在系统模块之间传输数据，数据</li>
<li>Address lines: 数据总线或者输入输出的来源或者终点，地址</li>
<li>Control lines:控制对数据或者地址线的使用，控制信号，时序信号，典型的有储存器，I/O的读写，传输响应，对总线控制的请求与准许，中断请求与响应，时钟，复位… </li>
</ul>
</li>
</ul>
<h2 id="Lecture-03"><a href="#Lecture-03" class="headerlink" title="Lecture 03"></a>Lecture 03</h2><h3 id="二进制的表示"><a href="#二进制的表示" class="headerlink" title="二进制的表示"></a>二进制的表示</h3><h4 id="补码"><a href="#补码" class="headerlink" title="补码"></a>补码</h4><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/zhuozuozhi/article/details/80896838">参考资料</a></p>
<ul>
<li>满足正负数的相加，使得负数能够使用加法器参与加法运算的一种码（原码的乘除更简单）</li>
<li>原码转补码：<ul>
<li>正数的补码即为自己，</li>
<li>负数的补码为原码符号位不变，其余逐位求反再加1</li>
<li>负数的补码取反加一即为所对应正数的补码</li>
</ul>
</li>
<li>原码取反后得到的值加本身会刚好的到所有的位都是1的二进制数，再加一就刚好进位得到模（可以理解为一个循环的周期）。所以取反加一是无论如何都能取到补码的。四位的模就是16</li>
<li>高位为什么可以直接舍弃：因为高位永远是模的倍数</li>
<li>补满的由来：取较大的数，减去能表示的（最大的数+1）来表示负数，例如1000能表示8，减去（1111表示的15+1=16）等于-8，那么就表示负数。其中16也被称为一个模，即数字表示的一个周期<blockquote>
<p>参考钟表</p>
</blockquote>
</li>
</ul>
<h4 id="浮点数"><a href="#浮点数" class="headerlink" title="浮点数"></a>浮点数</h4><blockquote>
<p>增加一个小数点的位置，表示同样多的数的数量，但是能表示更大的范围，那么说明中间稀疏了。<br>±𝑆 × 𝐵 两个相邻的数之间的间隔随着数值的增大逐渐变大，但是份数没有变化</p>
</blockquote>
<ul>
<li>定点数表达法的缺点在于固定的小数点位置决定了<strong>固定位数的整数部分和小数部分</strong>，不利于<strong>同时</strong>表达特别大的数或者特别小的数。</li>
<li>符号sign</li>
<li>偏值指数expedient 8位，没有符号，偏值为127。</li>
<li>有效数：significand</li>
<li>为了表示-2——2之间的其他数，取两个数表示0，将+-2到+-2之间的数分给+-2之间的数</li>
<li>IEEE：提出了一些非公约数的表示方法</li>
</ul>
<p><img src="https://cynyard-blog-pics.oss-cn-beijing.aliyuncs.com/image/1599741946120-05878a8e-c5e9-4a77-b2bd-fd81ea4a2c84.png" alt="image.png"><br><img src="https://cynyard-blog-pics.oss-cn-beijing.aliyuncs.com/image/1599742012723-299a0790-82f2-4962-9c46-d813aac85d6b.png" alt="image.png"></p>
<h2 id="Lecture-04"><a href="#Lecture-04" class="headerlink" title="Lecture 04"></a>Lecture 04</h2><h3 id="ALU（算数逻辑运算单元）"><a href="#ALU（算数逻辑运算单元）" class="headerlink" title="ALU（算数逻辑运算单元）"></a>ALU（算数逻辑运算单元）</h3><h4 id="全加器"><a href="#全加器" class="headerlink" title="全加器"></a>全加器</h4><p>三个输入，两个输出<br><img src="https://cynyard-blog-pics.oss-cn-beijing.aliyuncs.com/image/1599742105721-157bacb0-0b95-4ee2-b9a9-acf20f1a857a.png" alt="image.png"></p>
<p>异或：相同则为0，不同则为1，需要3个延迟（latency）</p>
<p>AND与OR需要1个延迟，并且可以同时做， 2 latency</p>
<h4 id="Serial-Carry-Adder串行"><a href="#Serial-Carry-Adder串行" class="headerlink" title="Serial Carry Adder串行"></a>Serial Carry Adder串行</h4><p><img src="https://cynyard-blog-pics.oss-cn-beijing.aliyuncs.com/image/1599742252659-7059a9db-b8fe-4528-822d-f876448f92d5.png" alt="image.png"><br> 2n+1=2（n-1）+3，在等待Cn-1的时候，可以先做x异或y（3 latency），2(n-1)&gt;=3那么n&gt;=2.5，<br> S1=6，S2=6</p>
<h4 id="Carry-Look-Ahead-Adder先行"><a href="#Carry-Look-Ahead-Adder先行" class="headerlink" title="Carry Look Ahead Adder先行"></a>Carry Look Ahead Adder先行</h4><ul>
<li>利用C的递推公式</li>
</ul>
<p><img src="https://cynyard-blog-pics.oss-cn-beijing.aliyuncs.com/image/1599742362263-9c4ef0c6-bda0-4bcc-a05a-8a2a2cf7a113.png" alt="image.png"></p>
<ul>
<li>第一个单位的延迟，用来求所有的P，所有的G。<strong>1</strong></li>
<li>再利用2个单位的延迟，求出所有的C。<strong>2</strong></li>
<li>再利用最后3个单位的延迟，求Si。之前的3个单位可以求Xi异或Yi。<strong>3</strong></li>
<li>代价：电路非常复杂，在第<strong>2</strong>步的时候</li>
</ul>
<h4 id="Partial-Carry-Look-Ahead-Adder-部分先行"><a href="#Partial-Carry-Look-Ahead-Adder-部分先行" class="headerlink" title="Partial Carry Look Ahead Adder 部分先行"></a>Partial Carry Look Ahead Adder 部分先行</h4><p><img src="https://cynyard-blog-pics.oss-cn-beijing.aliyuncs.com/image/1599742445696-97abd1b5-b394-4647-bfb0-36d13c0c0e26.png" alt="image.png"></p>
<ul>
<li>3+2+2+5，第一个<strong>3</strong>是第一个先行部分的前两个步骤，之后的两个<strong>2</strong>即为后面两个先行部分的第二个步骤（有一个1前面已经做了），最后的<strong>5</strong>为最后一个先行部分的后两个步骤。</li>
</ul>
<h3 id="Addition"><a href="#Addition" class="headerlink" title="Addition"></a>Addition</h3><h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><p>两个数相加的补码等于两个数的补码相加</p>
<h4 id="溢出"><a href="#溢出" class="headerlink" title="溢出"></a>溢出</h4><p>X=Y!=S或者C！=C，在上溢出的时候，ALU必须指出这个事实，通知其他部件不要使用这个结果（无论是否有进位，都有可能出现上溢出）</p>
<p><img src="https://cynyard-blog-pics.oss-cn-beijing.aliyuncs.com/image/1599987799308-e400edd5-d45b-4312-9aec-402836f52870.png" alt="image.png"></p>
<blockquote>
<p>上溢出，两个数最高位都是0，结果相加后出现了1</p>
</blockquote>
<h3 id="Subtraction"><a href="#Subtraction" class="headerlink" title="Subtraction"></a>Subtraction</h3><h4 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h4><p>两个数相减的补码相当于一个数的补码加上另一个数的负数的补码</p>
<h4 id="溢出-1"><a href="#溢出-1" class="headerlink" title="溢出"></a>溢出</h4><p>与加法的一样<br>加法的时候C等于0，减法的时候C等于1<br><img src="https://cynyard-blog-pics.oss-cn-beijing.aliyuncs.com/image/1599987893283-b5fe95d8-f2fb-44d5-b933-d92aeacc5a82.png" alt="image.png"></p>
<h3 id="Multiplication"><a href="#Multiplication" class="headerlink" title="Multiplication"></a>Multiplication</h3><h4 id="无符号乘法"><a href="#无符号乘法" class="headerlink" title="无符号乘法"></a>无符号乘法</h4><p>后一个乘数Y的每一位与第一个乘数X相乘，得到partial product，与原数相加，再右移，如果Y的某一位为0，那么partial product为0，再右移。partialproduct占高四位，Y占后四位，由于右移的关系，每次取的Y的那位总是在最低位。（当Y没有的时候，得到的partial product就是答案。）可以先都是无符号的乘法运算，然后再加符号（取补码）</p>
<blockquote>
<p>但是<br>乘数为负数：乘数的各位不再对应于必须发生的移位或者乘法操作<br>被乘数为负数：需要部分积左边填充1来完成</p>
</blockquote>
<h4 id="Booth算法"><a href="#Booth算法" class="headerlink" title="Booth算法"></a>Booth算法</h4><p>由于第一种无法解决补码的相乘，连续的1串与0串可以跳过</p>
<ul>
<li>一开始product全为0</li>
<li>设置Y0为0，扫描某一位与这一位右边的那一位，从左到右根据两者的数值（01为+，10为-），判断是+x还是-x还是+0，然后再右移，由于是补码表示，每次右移需要算术右移，使符号不变。为什么可以这么做ppt 17页，或者第八版206页</li>
<li><img src="https://cynyard-blog-pics.oss-cn-beijing.aliyuncs.com/image/1599988208349-75f3d388-9aa3-4132-92e4-90aa5ef6628b.png" alt="image.png"></li>
<li><img src="https://cynyard-blog-pics.oss-cn-beijing.aliyuncs.com/image/1599988253690-80a1d240-a601-4e0d-b6c7-51d10189c818.png" alt="image.png"></li>
<li><img src="https://cynyard-blog-pics.oss-cn-beijing.aliyuncs.com/image/1599988237045-1f6f322a-37db-432c-86e7-b400977bc400.png" alt="image.png"></li>
<li><img src="https://cynyard-blog-pics.oss-cn-beijing.aliyuncs.com/image/1599988215758-fbfc4b12-1ae2-48b2-9a94-356f0bcb8235.png" alt="image.png"></li>
<li><img src="https://cynyard-blog-pics.oss-cn-beijing.aliyuncs.com/image/1599988222736-f2dcacde-159d-4057-a149-8d7b736273d6.png" alt="image.png"></li>
</ul>
<h3 id="Division"><a href="#Division" class="headerlink" title="Division"></a>Division</h3><h4 id="无符号除法"><a href="#无符号除法" class="headerlink" title="无符号除法"></a>无符号除法</h4><p>从左到右检查被除数的位，知道被检查的位所表示的数大于或者等于除数，在这个过程中，一串0不断从左到右放入商，上述事件发生的时候，一个1就被放入商中，并且被除数（部分余）减去除数得到部分余。</p>
<p><img src="https://cynyard-blog-pics.oss-cn-beijing.aliyuncs.com/image/1599988430896-14ab136d-da6c-43b5-b865-7630e933d59c.png" alt="image.png"></p>
<p>除数的不断右移可以看成是被除数相对左移</p>
<ul>
<li>可以把部分余与商放在一个寄存器内，一开始商不占任何位数，dividend就是部分余数，前面补符号位，先左移，再判断remainder部分能不能减去除数，如果能最低位+1，减去除数，otherwise，+0，（recover）保持原样；最后得到商与余数。</li>
<li>如何判断remainder是足够大的呢：同号相减，异号相加。<strong>计算出来的符号</strong>与remainder（dividend）相同就足够，商加1</li>
</ul>
<p><img src="https://cynyard-blog-pics.oss-cn-beijing.aliyuncs.com/image/1599988509226-0f87d2f3-b001-4a73-8f0d-823bf5ae9f00.png" alt="image.png"></p>
<ul>
<li>先左移，试商，同号相减异号相加，如果不足够，就放0，并且recover remainder。如果足够就放1，不recover，</li>
<li>如果商与被除数有不同的符号，那么把商用补码表示</li>
<li>问题：recover耗费太大，会消耗一个寄存器</li>
</ul>
<h4 id="不回复余数除法"><a href="#不回复余数除法" class="headerlink" title="不回复余数除法"></a>不回复余数除法</h4><ul>
<li>补足符号位，dividend放在商的位置</li>
<li>remainder与divisor同号相减，异号相加，（这里会有一次quotient的加1或者0</li>
<li>得到的remainder如果符号与divisor相同，商加1，新的remainder等于两倍（左移）之前的remainder减去divisor，（先移位再加减得到新的remainder）</li>
<li>否则商加0，新的remainder等于两倍（左移）之前的remainder加上Y</li>
<li>新的remainder如果符号又与divisor相同，那么商加1，否则商加0，重复之前的步骤</li>
<li>总的重复次数（左移的次数）等于位数</li>
<li>左移quotient（remainder不受到影响，这个操作与下面的操作是并列的），如果是负数，说明除数与被除数符号不同，那么quotient加1</li>
<li>如果remainder与被除数符号不同，remainder加上divisor（除数被除数同号），或者减去divisor（除数被除数异号）即 ++-，–+，加上divisor，+–，-++减去divisor（Dividend，divisor，remainder）</li>
</ul>
<p><img src="https://cynyard-blog-pics.oss-cn-beijing.aliyuncs.com/image/1599988880563-d7a3790f-1884-4dad-acaf-980db6c8f24e.png" alt="image.png"></p>
<h2 id="Lecture-05"><a href="#Lecture-05" class="headerlink" title="Lecture 05"></a>Lecture 05</h2><h3 id="浮点数计算的问题"><a href="#浮点数计算的问题" class="headerlink" title="浮点数计算的问题"></a>浮点数计算的问题</h3><p>精确度不够，转换的时候消耗大。解决方法：用BCD表示的四个字代码来表达1到9</p>
<h3 id="加法"><a href="#加法" class="headerlink" title="加法"></a>加法</h3><h4 id="进位"><a href="#进位" class="headerlink" title="进位"></a>进位</h4><p>由于四位可以表示十五个数字，如果低位产生了进位，或者低位相加大于等于10（1010），就再加上0010，让这个位变成原本表示的数字，进位的1不能丢</p>
<h4 id="减法"><a href="#减法" class="headerlink" title="减法"></a>减法</h4><p>减去一个数就是加上他的”补码“</p>
<p><img src="https://cynyard-blog-pics.oss-cn-beijing.aliyuncs.com/image/1599988850252-8f93a4cc-a99a-41a7-8381-cc02d9cf699e.png" alt="image.png"></p>
<ol>
<li>因为是在0-9的范围内求 的所谓补码（每四个取一个inversion，然后在最后四个位加上一个“0001”），所以0的所谓补码是9，2的所谓的补码是7<ol>
<li>Inversion<ol>
<li>先取反，再加上1010；</li>
<li>先加上0110，再取反；</li>
</ol>
</li>
</ol>
</li>
<li>之后的加法<ol>
<li>在变减号为加号过后，因为最后要减去10n，如果有进位，那么舍去进位，如果没有进位，还是要强行减去，即取所谓补码（取inversion，最后再加上0001）</li>
</ol>
</li>
</ol>
<h2 id="Lecture-06-浮点数计算"><a href="#Lecture-06-浮点数计算" class="headerlink" title="Lecture 06 浮点数计算"></a>Lecture 06 浮点数计算</h2><h3 id="加减法"><a href="#加减法" class="headerlink" title="加减法"></a>加减法</h3><h3 id="符号幅值加法"><a href="#符号幅值加法" class="headerlink" title="符号幅值加法"></a>符号幅值加法</h3><h4 id="相加"><a href="#相加" class="headerlink" title="相加"></a>相加</h4><p>如果有进位就有进位嘛，符号与加数相同，并且有进位就溢出</p>
<h4 id="相减"><a href="#相减" class="headerlink" title="相减"></a>相减</h4><p>减去一个数就相当于加上这个数的补码（取反加一）即X+（-Y）=X+(111..1-Y+1）-1000..0，如果没有产生进位，就是无法减去1000..0，那么就将结果再取反加1，没有进位：符号与被减数相反。有进位：符号与被减数相同</p>
<h3 id="乘法"><a href="#乘法" class="headerlink" title="乘法"></a>乘法</h3><h3 id="除法"><a href="#除法" class="headerlink" title="除法"></a>除法</h3><h3 id="精确度考量"><a href="#精确度考量" class="headerlink" title="精确度考量"></a>精确度考量</h3><h2 id="Lecture07-内部存储器"><a href="#Lecture07-内部存储器" class="headerlink" title="Lecture07 内部存储器"></a>Lecture07 内部存储器</h2><h3 id="存储器"><a href="#存储器" class="headerlink" title="存储器"></a>存储器</h3><blockquote>
<p>一定数量的可标识的单元构成，每个单元可以存储一个数值</p>
</blockquote>
<ul>
<li>地址是单元的唯一标识符</li>
<li>随机存取：通过编排的寻址逻辑，存储器的单个字直接被取出</li>
<li>地址空间：可标识的单元总数，</li>
<li>寻址能力：存储在每个单元中的信息的位数，计算机能找到的地址位数，由计算机定义的地址长度，</li>
</ul>
<h3 id="半导体主存"><a href="#半导体主存" class="headerlink" title="半导体主存"></a>半导体主存</h3><h4 id="存储位元"><a href="#存储位元" class="headerlink" title="存储位元"></a>存储位元</h4><ul>
<li>两种稳态或者半稳态代表二进制的1或者0；</li>
<li>能够至少一次写入信息</li>
<li>能够读出状态信息</li>
<li>select：为读写操作选择一个位元；control：表明读或者写；data in；sense；</li>
</ul>
<h4 id="RAM"><a href="#RAM" class="headerlink" title="RAM"></a>RAM</h4><ul>
<li>容易读写，数据容易消失，电一消失就没了</li>
</ul>
<h4 id="SRAM"><a href="#SRAM" class="headerlink" title="SRAM"></a>SRAM</h4><ul>
<li>不需要刷新来维持数据</li>
<li>需要一直供电状态才稳定</li>
</ul>
<h4 id="两者对比"><a href="#两者对比" class="headerlink" title="两者对比"></a>两者对比</h4><ul>
<li>需要持续供电</li>
<li>DRAM密度高，体积小，集成度更高，价格更便宜，成本补偿了刷新电路的固定成本。常用于大容量存储器（内存用DRAM）</li>
<li>SRAM常用于cache，不需要刷新，只要供电就能存储数据</li>
</ul>
<h4 id="SDRAM（Synchronous-DRAM）"><a href="#SDRAM（Synchronous-DRAM）" class="headerlink" title="SDRAM（Synchronous DRAM）"></a>SDRAM（Synchronous DRAM）</h4><ul>
<li>传统DRAM是异步的，处理器传出地址，并且控制数据从DRAM存取或者写入，在DRAM执行的过程中，处理器需要等，就是需要一段时间的delay，DRAM</li>
<li>SDRAM是同步的：SDRAM moves data in time with system clock（外部clock信号）, and CPU knows when data will be ready.</li>
<li>约定好了时钟周期</li>
<li>DDRSDRAM（Double-data-rate SDRAM ）<ul>
<li>Send data twice per clock cycle, once on the rising edge of the clock pulse and once on the falling edge </li>
</ul>
</li>
</ul>
<h4 id="ROM"><a href="#ROM" class="headerlink" title="ROM"></a>ROM</h4><ul>
<li><p>含有不能改变的永久性数据，可读不可写，制造过程中数据固化到芯片上，在量产的时候，成本更低，</p>
</li>
<li><p>非易失性质：断电的时候数据不会丢失 Nonvolatile，用于操作系统啊，微程序啊，系统例程啊，函数表啊之类的</p>
<p>     但是如果有error，就废了</p>
</li>
<li><p>PROM：只能写入一次，用电；方便灵活，写入时需要特定装备READ MOSTLY</p>
</li>
<li><p>Easable PROM：可读可写，写入前需要擦除（紫外线照射）之后什么都不剩，可以修改多次，比PROM更贵，擦除很麻烦，但是能更新啊</p>
</li>
<li><p>Electrically Erasable PROM：更贵，用电，任何时候可以写入，无需擦除，但是写入很慢，集成度低</p>
</li>
<li><p>Flash memory：价格与功能介于EPROM与EEPROM之间，电擦除技术很快，可以擦除某些块而不是整块芯片，每一位只使用一个晶体管，高密度。</p>
</li>
</ul>
<h3 id="芯片逻辑"><a href="#芯片逻辑" class="headerlink" title="芯片逻辑"></a>芯片逻辑</h3><h4 id="可寻址单元"><a href="#可寻址单元" class="headerlink" title="可寻址单元"></a>可寻址单元</h4><ul>
<li>将一些cells存在一起，它们都拥有相同的地址，每次只能最多追踪到可寻址单元</li>
<li>寻址模式：按字节byte寻址（common），按word寻址</li>
</ul>
<h4 id="Memory-array"><a href="#Memory-array" class="headerlink" title="Memory array"></a>Memory array</h4><blockquote>
<p>将许多寻址单元排成方块型，地址线复用，减少了地址线的数量，降低复杂度，与寄存器的位数无关</p>
</blockquote>
<ul>
<li>只需要某一列或者某一行的地址线就能提供列与行的地址，11位地址信号定义行地址，另十一位地址信号去定义列地址，每个地址信号由行地址选通与列地址选通信号，为芯片提供时序控制信号</li>
</ul>
<h4 id="刷新"><a href="#刷新" class="headerlink" title="刷新"></a>刷新</h4><blockquote>
<p>使DRAM芯片丧失读写能力而刷新所有数据位元。刷新 计数器遍历通过所有的行的值，对每一行，刷新计数器的值被当作行地址输出到行译码器，激活RAS，数据被读出后写回源地址，从而使得相应行的所有位元被刷新</p>
</blockquote>
<ul>
<li>Centralized refresh：停止读写操作，如上述，一行一行刷新</li>
<li>Decentralized refresh： 在每个读写周期完</li>
<li>Asynchronous refresh：每64ms更新一行，高效</li>
</ul>
<h4 id="芯片"><a href="#芯片" class="headerlink" title="芯片"></a>芯片</h4><blockquote>
<p>8M*8：地址空间8M，寻址能力8bits，8M需要23位，地址线12条，数据线8条</p>
</blockquote>
<ul>
<li>引脚：写允许WE，输出允许OE，接地线Vss，电源线Vee，行地址选通RAS，列地址选通CAS，Vpp，Vss，CE，Address，Data</li>
<li>字拓展：地址线的数量增加，地址空间增加（不一定，如果以前地址线就没有达到饱和</li>
<li>位拓展：数据线数量增加，寻址能力增加（不一定，？，总线线宽</li>
</ul>
<h2 id="Lecture08-Cache"><a href="#Lecture08-Cache" class="headerlink" title="Lecture08 Cache"></a>Lecture08 Cache</h2><p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/31422201">参考1</a></p>
<p><a target="_blank" rel="noopener" href="https://www.kancloud.cn/chandler/programming_road/695583">参考2</a></p>
<h3 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h3><ul>
<li><p>更快更小的缓存器件，内存存储器，主存的速度跟不上CPU的速度。</p>
</li>
<li><p>CPU 访问数据存在时间局部性和空间局部性，所以可以将 CPU 需要频繁访问的少量热数据放在速度快但很贵的 SRAM 中，既能大幅度改善 CPU 性能也不会让成本提升太多</p>
</li>
</ul>
<h3 id="存取方式"><a href="#存取方式" class="headerlink" title="存取方式"></a>存取方式</h3><ul>
<li><p>顺序存取：按照顺序，从当前的存储位置，移动到所要求的位置，磁带</p>
</li>
<li><p>直接存取：直接到达所需的块，然后在块中顺序搜索，两者也都需要时间，磁盘</p>
</li>
<li><p>随机存取：根据可寻址的存储位置所对应的物理编排的寻址机制来寻址</p>
</li>
<li><p>关联存取：对一个字中的指定位相比较，查看是否满足特定的样式，能同时在所有的字中进行，即根据内容而不是地址进行检索</p>
</li>
</ul>
<h3 id="工作机制"><a href="#工作机制" class="headerlink" title="工作机制"></a>工作机制</h3><ul>
<li><p>check: 传入数据地址的时候，是一个地址一个地址传入的，如果这个地址的数据miss，那么搬运这个数据所在的块的所有数据到总线，总线经过数据缓冲器，同时更新cache，同时给到CPU</p>
</li>
<li><p>hit</p>
</li>
<li><p>miss</p>
</li>
</ul>
<h3 id="思考问题"><a href="#思考问题" class="headerlink" title="思考问题"></a>思考问题</h3><h4 id="hit与miss的检测"><a href="#hit与miss的检测" class="headerlink" title="hit与miss的检测"></a>hit与miss的检测</h4><p>Cache存在tags来标志他的内容，存储的是哪一块，tag与主存里的块位置有关</p>
<h4 id="为什么不直接把word搬到CPU呢"><a href="#为什么不直接把word搬到CPU呢" class="headerlink" title="为什么不直接把word搬到CPU呢"></a>为什么不直接把word搬到CPU呢</h4><p>局部访问性：同一值或者相关的存储位置会被频繁访问</p>
<ul>
<li><p>时间：某个时候访问了存储器的特定位置，不久的将来会访问相同位置的数据或者资源</p>
</li>
<li><p>空间：一个存储位置在特定的时间被访问，不久的将来将会访问附近的存储位置，所以该区域值得更快的访问</p>
</li>
<li><p>Cache利用空间局部性</p>
</li>
</ul>
<p>如果miss，主存的块会经过一个数据缓存器，然后同时更新cache，同时传送到处理器内</p>
<h4 id="为什么要读block"><a href="#为什么要读block" class="headerlink" title="为什么要读block"></a>为什么要读block</h4><p>利用空间局部性</p>
<h4 id="cache节省时间"><a href="#cache节省时间" class="headerlink" title="cache节省时间"></a>cache节省时间</h4><ul>
<li><p>时间主要花在地址的查找，那么从主存存取一个单元和从贮存存取一个块所需要的时间大致相同</p>
</li>
<li></li>
</ul>
<p><img src="https://cynyard-blog-pics.oss-cn-beijing.aliyuncs.com/image/1600780703958-891460bf-c4cd-4952-8fa9-fedc09a0e34f.png"></p>
<ul>
<li><p>如果想要T小于T，那么p就要？</p>
</li>
<li><p>hit的时候运行很快，搬一个块的时间比那个块所有的存储单元单独搬的时间快，hit节省的时间弥补了miss消耗的时间</p>
</li>
<li><p>cache读取一个块的总时间为T=mt；m为块内数据的数量，那么当命中的时候，消耗一个t，没有命中，消耗t+mnt（放入一个块的内容），n为主存和cache存储时间的比值，如果接连读取的数据是属于一个块的内容（局部访问性），那么命中后读取一个块的时间为T，miss后再读取这个块的时间为T+nT</p>
</li>
</ul>
<h3 id="设计要素"><a href="#设计要素" class="headerlink" title="设计要素"></a>设计要素</h3><h4 id="容量"><a href="#容量" class="headerlink" title="容量"></a>容量</h4><p>增加了p，但是会增加Tc，不会满足局部的概念，hit增加的速度会越来越慢</p>
<h3 id="映射方法"><a href="#映射方法" class="headerlink" title="映射方法"></a>映射方法</h3><p>M：内存中block的数量</p>
<p>C：cache中block的数量，行的数量</p>
<p>S：cache中的组数</p>
<p>K：每个cache组中行的数量</p>
<p>Tag位数 = logM-logC</p>
<h4 id="直接映射"><a href="#直接映射" class="headerlink" title="直接映射"></a>直接映射</h4><p><img src="https://cynyard-blog-pics.oss-cn-beijing.aliyuncs.com/image/1600781118145-15aace49-4641-49fa-9d66-c985a22db89d.png"></p>
<ul>
<li><p>内存里每一个block都有唯一的对应的行，对应的行号等于块号%总的行数量</p>
</li>
<li><p>cache每一行存储的是每一个块的K个字与tag标记与控制位</p>
</li>
<li><p>主存地址分为：字块标记（找到块的位置），cache字块地址（找到行的位置），字块内地址</p>
</li>
<li><p>如果cache有4行，一行8个字，主存一共有128个字，分为16个块，每个字有单独的地址。为了读取主存的数据，cpu传需要7位</p>
<ul>
<li><p>中间2位决定是4行中的哪一行被读取，（对应主存中那个部分的哪一个块被读取，确定了块在自己本身那个部分的占有的位置）</p>
</li>
<li><p>最高2位的tag与cache该一行的tag作比较，决定了是这一行对应的哪个block占据了这个cache，（每一行对应了4个块）（对应主存中哪个部分（上图中的竖列）的某个块将被读取）</p>
</li>
<li><p>最低的3位决定了是8个字中的哪一个 字被读取，（对应主存中那个部分的那一个块的哪一个字被读取）</p>
</li>
</ul>
</li>
<li><p>优点：简单，check，映射快</p>
</li>
<li><p>缺点：thrashing，如果连续取到的字对应的各自的块都对应着同一行</p>
</li>
</ul>
<h4 id="关联映射"><a href="#关联映射" class="headerlink" title="关联映射"></a>关联映射</h4><ul>
<li><p>一个块可以被加载到任意一个行当中</p>
</li>
<li><p>cache的每一行：每一块独有的tag加上该行对应的块的所有的数据</p>
</li>
<li><p>控制逻辑：将主存地址简单的表示为一个标记域加上一个字域，一个标记域对应着唯一的一个块</p>
</li>
<li><p>优点：避免了thrashing</p>
</li>
<li><p>缺点：复杂的实现，在cache中查找会相当复杂，昂贵，因为需要查找cache的每一行来判断是否命中（小cache完全ok）</p>
</li>
</ul>
<h4 id="组关联映射"><a href="#组关联映射" class="headerlink" title="组关联映射"></a>组关联映射</h4><blockquote>
<p>一个块可以被加载到任何在指定set中的line（这里是把cache分组，cache中组是按照顺序排下去的，主存中按顺序，每一行就是（组0，组1，组2，组3），（组0，组1，组2，组3）… 分别对应tag0，tag1，…<br>cache中组间采用直接映射，组内采用全相联映射。每组对应着存储器的某些块，这些块可以对应这个组里面任意的行）<br>一个块存储的行可以在set中有K个选择，再根据tag遍历有没有需要的数据（之前的直接映射可以理解为把主存，cache按行数分组，任意一个组的所有块能覆盖完cache的行）</p>
</blockquote>
<p>S：cache中的组数</p>
<p>M：存储器中块的数量</p>
<p>K：<strong>每个cache组中行的数量</strong> K-Way set</p>
<p>C：cache的行数</p>
<ul>
<li><p>控制逻辑：将主存地址认作：<strong>Tag，set，word；</strong></p>
</li>
<li><p>tag：log2（块的数量除以cache中组的数量），tag对应着cache中的set的某一行，可能存在与该set的任何一行，<strong>cache的任何一组中，每一行的tag都不可能一样</strong></p>
</li>
<li><p>Set：对应着哪一个组（块号mod组的数量）</p>
</li>
<li><p>word：对应着一个块的哪一个字</p>
</li>
<li><p>优点：结合了之前两种映射的优点，任意大小的cache中更适合，<strong>先进set，然后再顺序查找，</strong></p>
</li>
<li><p>缺点：结合了缺点</p>
</li>
<li><p>如果K等于1 ，相当于直接映射（一行一组），如果等于C，相当于关联映射</p>
</li>
</ul>
<h4 id="三者对比"><a href="#三者对比" class="headerlink" title="三者对比"></a>三者对比</h4><p>关联度：一个主存块映射到Cache中时，可能存放的位置个数 ，关联度越高，miss越少</p>
<ul>
<li><p>直接映射时间，tag最短，关联度最低，为1，命中率低</p>
</li>
<li><p>关联映射时间，tag最长，关联度最高，为Cache行数，但是check时间最长</p>
</li>
<li><p>关联映射的hit率最高，关联度居中，为N</p>
</li>
</ul>
<h3 id="替代算法："><a href="#替代算法：" class="headerlink" title="替代算法："></a>替代算法：</h3><blockquote>
<p>对于直接映射来说，没有替代算法，因为每一个主存块对应特定的cache block</p>
</blockquote>
<h4 id="Least-Recently-Used-LRU"><a href="#Least-Recently-Used-LRU" class="headerlink" title="Least Recently Used (LRU)"></a>Least Recently Used (LRU)</h4><ul>
<li><p>时间上最早使用的，长时间没有使用的，cache的每一行有一个use bit，被用过就是1，没用过就是0，被用过就更新他的timestamp，timestamp越小，那么越长时间没被使用</p>
</li>
<li><p>使用依据：最近使用的更容易被使用，时间局部性</p>
</li>
</ul>
<h4 id="First-In-First-Out-FIFO"><a href="#First-In-First-Out-FIFO" class="headerlink" title="First In First Out (FIFO)"></a>First In First Out (FIFO)</h4><ul>
<li><p>增加一个轮询系统，一开始按顺序放进来，然后按顺序出去</p>
</li>
<li><p>依据：之前放进来的更难使用，可以按照增加timestamp来计算</p>
</li>
</ul>
<h4 id="Least-Frequently-Used-LFU"><a href="#Least-Frequently-Used-LFU" class="headerlink" title="Least Frequently Used (LFU)"></a>Least Frequently Used (LFU)</h4><ul>
<li><p>使用频率最低的先出去</p>
</li>
<li><p>增加一个计数器</p>
</li>
</ul>
<h4 id="Random"><a href="#Random" class="headerlink" title="Random"></a>Random</h4><ul>
<li>依据：每个都有相似的几率被使用</li>
</ul>
<h3 id="读策略，写策略"><a href="#读策略，写策略" class="headerlink" title="读策略，写策略"></a>读策略，写策略</h3><h4 id="读策略："><a href="#读策略：" class="headerlink" title="读策略："></a>读策略：</h4><ul>
<li>如果memory被外来设备写入，那么如果cache中存在这个行，那么这个行被标记无效</li>
</ul>
<h4 id="写策略："><a href="#写策略：" class="headerlink" title="写策略："></a>写策略：</h4><ul>
<li><p>write through：cpu给出写的命令时，马上向存储器给出写入命令</p>
<ul>
<li><p>保证了主存的实时</p>
</li>
<li><p>但是会造成大量的存储器的traffic，并且减慢写入操作，与cache追求的不同</p>
</li>
</ul>
</li>
</ul>
<p><img src="https://cynyard-blog-pics.oss-cn-beijing.aliyuncs.com/image/1602918075587-f1dce3ed-70a3-4733-8a40-a0d233c5419d.png"></p>
<ul>
<li><p>write back</p>
<ul>
<li><p>如果一个block将要被覆盖，如果她之前被修改过那么将会被写回主存，增加一个dirtybit判断是否被修改了</p>
</li>
<li><p>减少了写入操作，但是主存是过时的有些数据是无效的，IO的存取只允许通过cache进行，那么电路设计更加复杂，潜在的瓶颈问题</p>
</li>
</ul>
</li>
</ul>
<p><img src="https://cynyard-blog-pics.oss-cn-beijing.aliyuncs.com/image/1602918150819-215f2216-8070-448e-832e-ccc66280c638.png"></p>
<h3 id="多重cache"><a href="#多重cache" class="headerlink" title="多重cache"></a>多重cache</h3><blockquote>
<p>进一步优化了取数据的时间</p>
</blockquote>
<ul>
<li><p>cache与处理器再同一个芯片，减少了处理器在外部总线的活动，减少了总线的占用率，加快执行</p>
</li>
<li><p>全局缺失率：存在的cache都缺失了</p>
</li>
</ul>
<p><img src="https://cynyard-blog-pics.oss-cn-beijing.aliyuncs.com/image/1602918433148-ffcb9f49-8788-4731-b25e-d9c1057206a1.png"></p>
<h2 id="Lecture-09-外部存储器"><a href="#Lecture-09-外部存储器" class="headerlink" title="Lecture 09 外部存储器"></a>Lecture 09 外部存储器</h2><h3 id="总体结构"><a href="#总体结构" class="headerlink" title="总体结构"></a>总体结构</h3><blockquote>
<p>有磁性物质包裹无磁性环状板</p>
</blockquote>
<h4 id="玻璃底板"><a href="#玻璃底板" class="headerlink" title="玻璃底板"></a>玻璃底板</h4><ul>
<li><p>磁性表层更好粘合</p>
</li>
<li><p>减少读写错误</p>
</li>
<li><p>强度高</p>
</li>
<li><p>抗破坏能力强</p>
</li>
</ul>
<h4 id="硬盘"><a href="#硬盘" class="headerlink" title="硬盘"></a>硬盘</h4><ul>
<li>读写头每个表面有一个，并且固定在一起，同时移动，相对位置不变</li>
</ul>
<p><img src="https://cynyard-blog-pics.oss-cn-beijing.aliyuncs.com/image/1602918778738-4d0eaf86-fff4-4742-9e36-c10a060e15b6.png"></p>
<h3 id="读写"><a href="#读写" class="headerlink" title="读写"></a>读写</h3><h4 id="读"><a href="#读" class="headerlink" title="读"></a>读</h4><ul>
<li>磁敏电阻，电阻变化引起电压变化</li>
</ul>
<h4 id="写"><a href="#写" class="headerlink" title="写"></a>写</h4><ul>
<li>电磁感应，磁性物质方向与外磁场方向一样</li>
</ul>
<h4 id="磁头"><a href="#磁头" class="headerlink" title="磁头"></a>磁头</h4><ul>
<li>磁头更小，一个bit占据的位置更小，磁道间距离更近，更加高密度的数据处理，更多的数据存储</li>
</ul>
<h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><h4 id="扇区与sector"><a href="#扇区与sector" class="headerlink" title="扇区与sector"></a>扇区与sector</h4><ul>
<li><p>每个扇区sector的数据量（但是总的信息量大于512B的）相同：512B（默认），扇区之间有间隔</p>
</li>
<li><p>每个track都是同心圆，最外面的为0道，最里面的为N道，因为磁头一开始都在最外面，磁道之间有间隔</p>
</li>
</ul>
<h4 id="扇区的分布"><a href="#扇区的分布" class="headerlink" title="扇区的分布"></a>扇区的分布</h4><ul>
<li><p>CAV：Constant-angular velocity</p>
<ul>
<li><p>优点：读写的角速度是一样的，那么中间的杆的速度恒定，驱动装置简单</p>
</li>
<li><p>缺点：浪费容量，每个扇区大小不同，但是数据量相同</p>
</li>
</ul>
</li>
<li><p>第二种方式：按周长划分区zone，每一区里还有tracks，同一个zone的不同的track扇区数量是恒定的，越远的越多，同一个zone按照第一种方式划分，</p>
<ul>
<li><p>优点：充分利用了磁盘的容量</p>
</li>
<li><p>缺点：驱动变速，外面的夹角更小转的更慢，保证每个区的读写速度稳定，但是只是区域的速度不同，根据区域数指定速度</p>
</li>
</ul>
</li>
</ul>
<h4 id="扇区的结构"><a href="#扇区的结构" class="headerlink" title="扇区的结构"></a>扇区的结构</h4><ul>
<li><p>间隙：缓冲时间，等待判断</p>
</li>
<li><p>id：扇区号，head号（第几层），磁道号</p>
</li>
<li><p>同步字节：标志有扇区的id或者data来临</p>
</li>
</ul>
<h4 id="cylinder："><a href="#cylinder：" class="headerlink" title="cylinder："></a>cylinder：</h4><p>所有相同相对位置的tracks组成</p>
<h4 id="formatting格式化："><a href="#formatting格式化：" class="headerlink" title="formatting格式化："></a>formatting格式化：</h4><ul>
<li><p>需要有标志一个扇区的开始以及结束的points</p>
</li>
<li><p>添加一些特殊的不能被使用者读取的数据来标志</p>
</li>
<li><p>gap用来缓冲IDfield的判断时间，17byte，41byte，20byte：前中后</p>
</li>
<li><p>SynchByte定界符，1byte</p>
</li>
</ul>
<h3 id="读取时间"><a href="#读取时间" class="headerlink" title="读取时间"></a>读取时间</h3><h4 id="Seek寻道时间"><a href="#Seek寻道时间" class="headerlink" title="Seek寻道时间"></a>Seek寻道时间</h4><p>固定，开始准备时间以及移动的时间，Ts</p>
<h4 id="旋转延迟rotational-latency"><a href="#旋转延迟rotational-latency" class="headerlink" title="旋转延迟rotational latency"></a>旋转延迟rotational latency</h4><p>转半圈的时间（平均）</p>
<h4 id="存取时间"><a href="#存取时间" class="headerlink" title="存取时间"></a>存取时间</h4><p>寻道时间+旋转延迟</p>
<h4 id="数据传输时间"><a href="#数据传输时间" class="headerlink" title="数据传输时间"></a>数据传输时间</h4><p>需要的总的数据量除以每道的数据量（需要的道数）除以一秒钟的圈数（或者乘以转每一圈的时间），一秒钟走过rN个byte，需要b个byte</p>
<p><img src="https://cynyard-blog-pics.oss-cn-beijing.aliyuncs.com/image/1602919767032-0ee8a64d-8149-4ce7-a584-71fd04324b15.png"></p>
<h4 id="文件读取"><a href="#文件读取" class="headerlink" title="文件读取"></a>文件读取</h4><ul>
<li><p>如果在相邻的track上，除了第一次，之后的寻道时间忽略不计，并且大大减少了旋转延迟，每一圈只需要一个旋转延迟</p>
</li>
<li><p>如果数据是随机分散的，那么每一个扇区都要消耗一个寻道时间，旋转延迟，以及数据传输时间</p>
</li>
<li><p>如果磁盘上已经有一些数据了，那么不是完全的在5条道上，如果是6条：在情况一的基础上再加上一条道的旋转延迟而已</p>
</li>
<li><p>碎片清理，就是把分散在各处的数据集中到一起，加快了读写速度，但是会对磁盘有损耗</p>
</li>
</ul>
<h3 id="查找算法："><a href="#查找算法：" class="headerlink" title="查找算法："></a>查找算法：</h3><ul>
<li><p>First come first service：保证了任务处理的及时性，但是牺牲了时间效率，不同的任务可能需要的数据在不同的点，那么会消耗大量的读取时间</p>
</li>
<li><p>Shortest seek time first：先处理任务中距离当前磁头距离短的数据，移动距离小，但是牺牲了及时性，任务搁置</p>
</li>
<li><p>SCAN：在0道和N道不断移动</p>
</li>
<li><p>C-SCAN：只从N道移动到0道，从里到外，然后空移到里面</p>
<ul>
<li>这个与scan需要的平均等待时间相同，但是最长的等待时间减少了，只有一次从里到外</li>
</ul>
</li>
<li><p>LOOK：当前移动方向没有任务就掉头，like elevator，但是要记住磁头的当前位置和当前的前进方向</p>
</li>
</ul>
<h3 id="光盘-Compact-Disk"><a href="#光盘-Compact-Disk" class="headerlink" title="光盘 Compact Disk"></a>光盘 Compact Disk</h3><ul>
<li><p>-R：recordable 可记录的，-RW：Rewritable 可重写的</p>
</li>
<li><p>制作过程：用激光制作母片，高精度，高集中度</p>
<ul>
<li><p>用树脂通过母片印制</p>
</li>
<li><p>不平的的表面用高反射的surface覆盖：通过激光照射，里面高低不平 从而反射的强度不同</p>
</li>
<li><p>高反射的表面再用acrylic覆盖形成最外层</p>
</li>
</ul>
</li>
<li><p>读操作：CD与CD-ROM</p>
<ul>
<li><p>到了凹处，粗糙，反射强度低</p>
</li>
<li><p>到了平处，反射强度高</p>
</li>
<li><p>只有一根轨道，spiral，所有的sectors长度相同，那么读里面的时候，旋转速度更快，线速度恒定</p>
</li>
<li><p>后者更粗糙，有错误修正装置</p>
</li>
<li><p>优点：便宜，大量复制，可以携带；但是只读不能写，读取时间远长于磁盘</p>
</li>
</ul>
</li>
<li><p>CD-R，CD-RW</p>
<ul>
<li><p>前者：有一层layer（dye layer）被高强度激光照射，能够改变反射性，之后可以在CDR或者CDROM的光驱上读</p>
</li>
<li><p>后者：有一层具有两种反射性质的材料，能被激光改变，这层材料在五十万次或者一百万次过后会逐渐丧失特性</p>
</li>
</ul>
</li>
<li><p>DVD：</p>
<ul>
<li><p>bits之间联系更紧密</p>
</li>
<li><p>有些dvd两边都可以存数据，后来没用了</p>
</li>
</ul>
</li>
<li><p>高精度光盘：High definition</p>
<ul>
<li>bits更小，使用更短波长的激光照射，一般是蓝光紫光波段，能存储更多信息</li>
</ul>
</li>
<li><p>磁带</p>
<ul>
<li><p>读写技术与磁盘相同</p>
</li>
<li><p>中间有软的tape，被磁性材料包裹</p>
</li>
<li><p>多个头：并行</p>
</li>
<li><p>一个头：串行</p>
</li>
</ul>
</li>
</ul>

        </div>

        
            <section class="post-copyright">
                
                    <p class="copyright-item">
                        <span>Author:</span>
                        <span>Cynyard Qiu</span>
                    </p>
                
                
                
                

            </section>
        
        <section class="post-tags">
            <div>
                <span>Tag(s):</span>
                <span class="tag">
                    
                    
                        <a href="/tags/writing/"># writing</a>
                    
                        <a href="/tags/computer-organization/"># computer-organization</a>
                    
                        
                </span>
            </div>
            <div>
                <a href="javascript:window.history.back();">back</a>
                <span>· </span>
                <a href="/">home</a>
            </div>
        </section>
        <section class="post-nav">
            
                <a class="prev" rel="prev" href="/2020/01/10/COA2/">计算机组织机构（2）</a>
            
            
        </section>


    </article>
</div>

        </div>
        <footer id="footer" class="footer">
    <div class="copyright">
        <span>© Cynyard Qiu | Powered by <a href="https://hexo.io" target="_blank">Hexo</a> & <a href="https://github.com/Siricee/hexo-theme-Chic" target="_blank">Chic</a> 
        
        </span>
    </div>
</footer>

    </div>
</body>
</html>
